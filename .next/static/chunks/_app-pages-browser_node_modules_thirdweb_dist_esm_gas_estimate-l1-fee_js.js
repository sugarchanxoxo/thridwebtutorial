"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_thirdweb_dist_esm_gas_estimate-l1-fee_js"],{

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: () => (/* binding */ createCurve),\n/* harmony export */   getHash: () => (/* binding */ getHash)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n/** connects noble-curves to noble-hashes */\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return { ...create(defHash), create };\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMwQztBQUNxQjtBQUNQO0FBQ3hEO0FBQ087QUFDUDtBQUNBO0FBQ0EsZ0NBQWdDLHdEQUFJLFlBQVksZ0VBQVc7QUFDM0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixxRUFBVyxHQUFHLCtCQUErQjtBQUMxRSxhQUFhO0FBQ2I7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21paW5hZG9pL0Rlc2t0b3AvZ2l0aHViUHJvamVjdC90aHJpZHdlYnR1dG9yaWFsL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVXRpbGl0aWVzIGZvciBzaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZXMsIGNvbWJpbmVkIHdpdGggbm9ibGUtaGFzaGVzLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbmltcG9ydCB7IGNvbmNhdEJ5dGVzLCByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgd2VpZXJzdHJhc3MgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbi8qKiBjb25uZWN0cyBub2JsZS1jdXJ2ZXMgdG8gbm9ibGUtaGFzaGVzICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaCxcbiAgICAgICAgaG1hYzogKGtleSwgLi4ubXNncykgPT4gaG1hYyhoYXNoLCBrZXksIGNvbmNhdEJ5dGVzKC4uLm1zZ3MpKSxcbiAgICAgICAgcmFuZG9tQnl0ZXMsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDdXJ2ZShjdXJ2ZURlZiwgZGVmSGFzaCkge1xuICAgIGNvbnN0IGNyZWF0ZSA9IChoYXNoKSA9PiB3ZWllcnN0cmFzcyh7IC4uLmN1cnZlRGVmLCAuLi5nZXRIYXNoKGhhc2gpIH0pO1xuICAgIHJldHVybiB7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hvcnR3X3V0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   pippenger: () => (/* binding */ pippenger),\n/* harmony export */   precomputeMSMUnsafe: () => (/* binding */ precomputeMSMUnsafe),\n/* harmony export */   validateBasic: () => (/* binding */ validateBasic),\n/* harmony export */   wNAF: () => (/* binding */ wNAF)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction constTimeNegate(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n}\nfunction validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n        throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\nfunction calcWOpts(W, bits) {\n    validateW(W, bits);\n    const windows = Math.ceil(bits / W) + 1; // +1, because\n    const windowSize = 2 ** (W - 1); // -1 because we skip zero\n    return { windows, windowSize };\n}\nfunction validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n        throw new Error('array expected');\n    points.forEach((p, i) => {\n        if (!(p instanceof c))\n            throw new Error('invalid point at index ' + i);\n    });\n}\nfunction validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n        throw new Error('array of scalars expected');\n    scalars.forEach((s, i) => {\n        if (!field.isValid(s))\n            throw new Error('invalid scalar at index ' + i);\n    });\n}\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap();\nconst pointWindowSizes = new WeakMap(); // This allows use make points immutable (nothing changes inside)\nfunction getW(P) {\n    return pointWindowSizes.get(P) || 1;\n}\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nfunction wNAF(c, bits) {\n    return {\n        constTimeNegate,\n        hasPrecomputes(elm) {\n            return getW(elm) !== 1;\n        },\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n, p = c.ZERO) {\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @param elm Point instance\n         * @param W window size\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = calcWOpts(W, bits);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        /**\n         * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @param acc accumulator point to add result of multiplication\n         * @returns point\n         */\n        wNAFUnsafe(W, precomputes, n, acc = c.ZERO) {\n            const { windows, windowSize } = calcWOpts(W, bits);\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                if (n === _0n)\n                    break; // No need to go over empty scalar\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                if (wbits === 0)\n                    continue;\n                let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n                if (wbits < 0)\n                    curr = curr.negate();\n                // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n                acc = acc.add(curr);\n            }\n            return acc;\n        },\n        getPrecomputes(W, P, transform) {\n            // Calculate precomputes on a first run, reuse them after\n            let comp = pointPrecomputes.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1)\n                    pointPrecomputes.set(P, transform(comp));\n            }\n            return comp;\n        },\n        wNAFCached(P, n, transform) {\n            const W = getW(P);\n            return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n        },\n        wNAFCachedUnsafe(P, n, transform, prev) {\n            const W = getW(P);\n            if (W === 1)\n                return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n            return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n        },\n        // We calculate precomputes for elliptic curve point multiplication\n        // using windowed method. This specifies window size and\n        // stores precomputed values. Usually only base point would be precomputed.\n        setWindowSize(P, W) {\n            validateW(W, bits);\n            pointWindowSizes.set(P, W);\n            pointPrecomputes.delete(P);\n        },\n    };\n}\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nfunction pippenger(c, fieldN, points, scalars) {\n    // If we split scalars by some window (let's say 8 bits), every chunk will only\n    // take 256 buckets even if there are 4096 scalars, also re-uses double.\n    // TODO:\n    // - https://eprint.iacr.org/2024/750.pdf\n    // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n    // 0 is accepted in scalars\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    if (points.length !== scalars.length)\n        throw new Error('arrays of points and scalars must have equal length');\n    const zero = c.ZERO;\n    const wbits = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitLen)(BigInt(points.length));\n    const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n    const MASK = (1 << windowSize) - 1;\n    const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n        buckets.fill(zero);\n        for (let j = 0; j < scalars.length; j++) {\n            const scalar = scalars[j];\n            const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\n            buckets[wbits] = buckets[wbits].add(points[j]);\n        }\n        let resI = zero; // not using this will do small speed-up, but will lose ct\n        // Skip first bucket, because it is zero\n        for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n            sumI = sumI.add(buckets[j]);\n            resI = resI.add(sumI);\n        }\n        sum = sum.add(resI);\n        if (i !== 0)\n            for (let j = 0; j < windowSize; j++)\n                sum = sum.double();\n    }\n    return sum;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nfunction precomputeMSMUnsafe(c, fieldN, points, windowSize) {\n    /**\n     * Performance Analysis of Window-based Precomputation\n     *\n     * Base Case (256-bit scalar, 8-bit window):\n     * - Standard precomputation requires:\n     *   - 31 additions per scalar × 256 scalars = 7,936 ops\n     *   - Plus 255 summary additions = 8,191 total ops\n     *   Note: Summary additions can be optimized via accumulator\n     *\n     * Chunked Precomputation Analysis:\n     * - Using 32 chunks requires:\n     *   - 255 additions per chunk\n     *   - 256 doublings\n     *   - Total: (255 × 32) + 256 = 8,416 ops\n     *\n     * Memory Usage Comparison:\n     * Window Size | Standard Points | Chunked Points\n     * ------------|-----------------|---------------\n     *     4-bit   |     520         |      15\n     *     8-bit   |    4,224        |     255\n     *    10-bit   |   13,824        |   1,023\n     *    16-bit   |  557,056        |  65,535\n     *\n     * Key Advantages:\n     * 1. Enables larger window sizes due to reduced memory overhead\n     * 2. More efficient for smaller scalar counts:\n     *    - 16 chunks: (16 × 255) + 256 = 4,336 ops\n     *    - ~2x faster than standard 8,191 ops\n     *\n     * Limitations:\n     * - Not suitable for plain precomputes (requires 256 constant doublings)\n     * - Performance degrades with larger scalar counts:\n     *   - Optimal for ~256 scalars\n     *   - Less efficient for 4096+ scalars (Pippenger preferred)\n     */\n    validateW(windowSize, fieldN.BITS);\n    validateMSMPoints(points, c);\n    const zero = c.ZERO;\n    const tableSize = 2 ** windowSize - 1; // table size (without zero)\n    const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n    const MASK = BigInt((1 << windowSize) - 1);\n    const tables = points.map((p) => {\n        const res = [];\n        for (let i = 0, acc = p; i < tableSize; i++) {\n            res.push(acc);\n            acc = acc.add(p);\n        }\n        return res;\n    });\n    return (scalars) => {\n        validateMSMScalars(scalars, fieldN);\n        if (scalars.length > points.length)\n            throw new Error('array of scalars must be smaller than array of points');\n        let res = zero;\n        for (let i = 0; i < chunks; i++) {\n            // No need to double if accumulator is still zero.\n            if (res !== zero)\n                for (let j = 0; j < windowSize; j++)\n                    res = res.double();\n            const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n            for (let j = 0; j < scalars.length; j++) {\n                const n = scalars[j];\n                const curr = Number((n >> shiftBy) & MASK);\n                if (!curr)\n                    continue; // skip zero scalars chunks\n                res = res.add(tables[j][curr - 1]);\n            }\n        }\n        return res;\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Q7QUFDRjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MscUNBQXFDO0FBQ3JDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUMsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaURBQU07QUFDeEIsdUZBQXVGO0FBQ3ZGO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBLHdCQUF3QixvQkFBb0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxzREFBc0QsT0FBTztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSwwREFBYTtBQUNqQixJQUFJLHlEQUFjO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFdBQVcsb0RBQU87QUFDbEI7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21paW5hZG9pL0Rlc2t0b3AvZ2l0aHViUHJvamVjdC90aHJpZHdlYnR1dG9yaWFsL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1ldGhvZHMgZm9yIGVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIGJ5IHNjYWxhcnMuXG4gKiBDb250YWlucyB3TkFGLCBwaXBwZW5nZXJcbiAqIEBtb2R1bGVcbiAqL1xuLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgbkxlbmd0aCwgdmFsaWRhdGVGaWVsZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBiaXRMZW4sIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG5mdW5jdGlvbiBjb25zdFRpbWVOZWdhdGUoY29uZGl0aW9uLCBpdGVtKSB7XG4gICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICByZXR1cm4gY29uZGl0aW9uID8gbmVnIDogaXRlbTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVyhXLCBiaXRzKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihXKSB8fCBXIDw9IDAgfHwgVyA+IGJpdHMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCB3aW5kb3cgc2l6ZSwgZXhwZWN0ZWQgWzEuLicgKyBiaXRzICsgJ10sIGdvdCBXPScgKyBXKTtcbn1cbmZ1bmN0aW9uIGNhbGNXT3B0cyhXLCBiaXRzKSB7XG4gICAgdmFsaWRhdGVXKFcsIGJpdHMpO1xuICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgIHJldHVybiB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNUG9pbnRzKHBvaW50cywgYykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShwb2ludHMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FycmF5IGV4cGVjdGVkJyk7XG4gICAgcG9pbnRzLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgaWYgKCEocCBpbnN0YW5jZW9mIGMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBvaW50IGF0IGluZGV4ICcgKyBpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTVNNU2NhbGFycyhzY2FsYXJzLCBmaWVsZCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2FsYXJzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcnJheSBvZiBzY2FsYXJzIGV4cGVjdGVkJyk7XG4gICAgc2NhbGFycy5mb3JFYWNoKChzLCBpKSA9PiB7XG4gICAgICAgIGlmICghZmllbGQuaXNWYWxpZChzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBzY2FsYXIgYXQgaW5kZXggJyArIGkpO1xuICAgIH0pO1xufVxuLy8gU2luY2UgcG9pbnRzIGluIGRpZmZlcmVudCBncm91cHMgY2Fubm90IGJlIGVxdWFsIChkaWZmZXJlbnQgb2JqZWN0IGNvbnN0cnVjdG9yKSxcbi8vIHdlIGNhbiBoYXZlIHNpbmdsZSBwbGFjZSB0byBzdG9yZSBwcmVjb21wdXRlc1xuY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBwb2ludFdpbmRvd1NpemVzID0gbmV3IFdlYWtNYXAoKTsgLy8gVGhpcyBhbGxvd3MgdXNlIG1ha2UgcG9pbnRzIGltbXV0YWJsZSAobm90aGluZyBjaGFuZ2VzIGluc2lkZSlcbmZ1bmN0aW9uIGdldFcoUCkge1xuICAgIHJldHVybiBwb2ludFdpbmRvd1NpemVzLmdldChQKSB8fCAxO1xufVxuLyoqXG4gKiBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4gKiBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbiAqIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuICogLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4gKiAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4gKiAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4gKiAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbiAqIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbiAqIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4gKlxuICogQHRvZG8gUmVzZWFyY2ggcmV0dXJuaW5nIDJkIEpTIGFycmF5IG9mIHdpbmRvd3MsIGluc3RlYWQgb2YgYSBzaW5nbGUgd2luZG93LlxuICogVGhpcyB3b3VsZCBhbGxvdyB3aW5kb3dzIHRvIGJlIGluIGRpZmZlcmVudCBtZW1vcnkgbG9jYXRpb25zXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIGhhc1ByZWNvbXB1dGVzKGVsbSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFcoZWxtKSAhPT0gMTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gbm9uLWNvbnN0IHRpbWUgbXVsdGlwbGljYXRpb24gbGFkZGVyXG4gICAgICAgIHVuc2FmZUxhZGRlcihlbG0sIG4sIHAgPSBjLlpFUk8pIHtcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHBhcmFtIGVsbSBQb2ludCBpbnN0YW5jZVxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcmV0dXJucyBwcmVjb21wdXRlZCBwb2ludCB0YWJsZXMgZmxhdHRlbmVkIHRvIGEgc2luZ2xlIGFycmF5XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlV2luZG93KGVsbSwgVykge1xuICAgICAgICAgICAgY29uc3QgeyB3aW5kb3dzLCB3aW5kb3dTaXplIH0gPSBjYWxjV09wdHMoVywgYml0cyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBCdXQgbmVlZCB0byBjYXJlZnVsbHkgcmVtb3ZlIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlXG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IGNhbGNXT3B0cyhXLCBiaXRzKTtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW1wbGVtZW50cyBlYyB1bnNhZmUgKG5vbiBjb25zdC10aW1lKSBtdWx0aXBsaWNhdGlvbiB1c2luZyBwcmVjb21wdXRlZCB0YWJsZXMgYW5kIHctYXJ5IG5vbi1hZGphY2VudCBmb3JtLlxuICAgICAgICAgKiBAcGFyYW0gVyB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiBAcGFyYW0gcHJlY29tcHV0ZXMgcHJlY29tcHV0ZWQgdGFibGVzXG4gICAgICAgICAqIEBwYXJhbSBuIHNjYWxhciAod2UgZG9uJ3QgY2hlY2sgaGVyZSwgYnV0IHNob3VsZCBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXIpXG4gICAgICAgICAqIEBwYXJhbSBhY2MgYWNjdW11bGF0b3IgcG9pbnQgdG8gYWRkIHJlc3VsdCBvZiBtdWx0aXBsaWNhdGlvblxuICAgICAgICAgKiBAcmV0dXJucyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgd05BRlVuc2FmZShXLCBwcmVjb21wdXRlcywgbiwgYWNjID0gYy5aRVJPKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IGNhbGNXT3B0cyhXLCBiaXRzKTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBCaWdJbnQoMiAqKiBXIC0gMSk7IC8vIENyZWF0ZSBtYXNrIHdpdGggVyBvbmVzOiAwYjExMTEgZm9yIFc9NCBldGMuXG4gICAgICAgICAgICBjb25zdCBtYXhOdW1iZXIgPSAyICoqIFc7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KFcpO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSB3aW5kb3cgKiB3aW5kb3dTaXplO1xuICAgICAgICAgICAgICAgIGlmIChuID09PSBfMG4pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBObyBuZWVkIHRvIGdvIG92ZXIgZW1wdHkgc2NhbGFyXG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxldCBjdXJyID0gcHJlY29tcHV0ZXNbb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMV07IC8vIC0xIGJlY2F1c2Ugd2Ugc2tpcCB6ZXJvXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzIDwgMClcbiAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnIubmVnYXRlKCk7XG4gICAgICAgICAgICAgICAgLy8gTk9URTogYnkgcmUtdXNpbmcgYWNjLCB3ZSBjYW4gc2F2ZSBhIGxvdCBvZiBhZGRpdGlvbnMgaW4gY2FzZSBvZiBNU01cbiAgICAgICAgICAgICAgICBhY2MgPSBhY2MuYWRkKGN1cnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0UHJlY29tcHV0ZXMoVywgUCwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBDYWxjdWxhdGUgcHJlY29tcHV0ZXMgb24gYSBmaXJzdCBydW4sIHJldXNlIHRoZW0gYWZ0ZXJcbiAgICAgICAgICAgIGxldCBjb21wID0gcG9pbnRQcmVjb21wdXRlcy5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKVxuICAgICAgICAgICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXA7XG4gICAgICAgIH0sXG4gICAgICAgIHdOQUZDYWNoZWQoUCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICBjb25zdCBXID0gZ2V0VyhQKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgdGhpcy5nZXRQcmVjb21wdXRlcyhXLCBQLCB0cmFuc2Zvcm0pLCBuKTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZFVuc2FmZShQLCBuLCB0cmFuc2Zvcm0sIHByZXYpIHtcbiAgICAgICAgICAgIGNvbnN0IFcgPSBnZXRXKFApO1xuICAgICAgICAgICAgaWYgKFcgPT09IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudW5zYWZlTGFkZGVyKFAsIG4sIHByZXYpOyAvLyBGb3IgVz0xIGxhZGRlciBpcyB+eDIgZmFzdGVyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGVW5zYWZlKFcsIHRoaXMuZ2V0UHJlY29tcHV0ZXMoVywgUCwgdHJhbnNmb3JtKSwgbiwgcHJldik7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIFdlIGNhbGN1bGF0ZSBwcmVjb21wdXRlcyBmb3IgZWxsaXB0aWMgY3VydmUgcG9pbnQgbXVsdGlwbGljYXRpb25cbiAgICAgICAgLy8gdXNpbmcgd2luZG93ZWQgbWV0aG9kLiBUaGlzIHNwZWNpZmllcyB3aW5kb3cgc2l6ZSBhbmRcbiAgICAgICAgLy8gc3RvcmVzIHByZWNvbXB1dGVkIHZhbHVlcy4gVXN1YWxseSBvbmx5IGJhc2UgcG9pbnQgd291bGQgYmUgcHJlY29tcHV0ZWQuXG4gICAgICAgIHNldFdpbmRvd1NpemUoUCwgVykge1xuICAgICAgICAgICAgdmFsaWRhdGVXKFcsIGJpdHMpO1xuICAgICAgICAgICAgcG9pbnRXaW5kb3dTaXplcy5zZXQoUCwgVyk7XG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZShQKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLyoqXG4gKiBQaXBwZW5nZXIgYWxnb3JpdGhtIGZvciBtdWx0aS1zY2FsYXIgbXVsdGlwbGljYXRpb24gKE1TTSwgUGEgKyBRYiArIFJjICsgLi4uKS5cbiAqIDMweCBmYXN0ZXIgdnMgbmFpdmUgYWRkaXRpb24gb24gTD00MDk2LCAxMHggZmFzdGVyIHdpdGggcHJlY29tcHV0ZXMuXG4gKiBGb3IgTj0yNTRiaXQsIEw9MSwgaXQgZG9lczogMTAyNCBBREQgKyAyNTQgREJMLiBGb3IgTD01OiAxNTM2IEFERCArIDI1NCBEQkwuXG4gKiBBbGdvcml0aG1pY2FsbHkgY29uc3RhbnQtdGltZSAoZm9yIHNhbWUgTCksIGV2ZW4gd2hlbiAxIHBvaW50ICsgc2NhbGFyLCBvciB3aGVuIHNjYWxhciA9IDAuXG4gKiBAcGFyYW0gYyBDdXJ2ZSBQb2ludCBjb25zdHJ1Y3RvclxuICogQHBhcmFtIGZpZWxkTiBmaWVsZCBvdmVyIENVUlZFLk4gLSBpbXBvcnRhbnQgdGhhdCBpdCdzIG5vdCBvdmVyIENVUlZFLlBcbiAqIEBwYXJhbSBwb2ludHMgYXJyYXkgb2YgTCBjdXJ2ZSBwb2ludHNcbiAqIEBwYXJhbSBzY2FsYXJzIGFycmF5IG9mIEwgc2NhbGFycyAoYWthIHByaXZhdGUga2V5cyAvIGJpZ2ludHMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwaXBwZW5nZXIoYywgZmllbGROLCBwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAvLyBJZiB3ZSBzcGxpdCBzY2FsYXJzIGJ5IHNvbWUgd2luZG93IChsZXQncyBzYXkgOCBiaXRzKSwgZXZlcnkgY2h1bmsgd2lsbCBvbmx5XG4gICAgLy8gdGFrZSAyNTYgYnVja2V0cyBldmVuIGlmIHRoZXJlIGFyZSA0MDk2IHNjYWxhcnMsIGFsc28gcmUtdXNlcyBkb3VibGUuXG4gICAgLy8gVE9ETzpcbiAgICAvLyAtIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMjQvNzUwLnBkZlxuICAgIC8vIC0gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzEwMjg3XG4gICAgLy8gMCBpcyBhY2NlcHRlZCBpbiBzY2FsYXJzXG4gICAgdmFsaWRhdGVNU01Qb2ludHMocG9pbnRzLCBjKTtcbiAgICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcbiAgICBpZiAocG9pbnRzLmxlbmd0aCAhPT0gc2NhbGFycy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXlzIG9mIHBvaW50cyBhbmQgc2NhbGFycyBtdXN0IGhhdmUgZXF1YWwgbGVuZ3RoJyk7XG4gICAgY29uc3QgemVybyA9IGMuWkVSTztcbiAgICBjb25zdCB3Yml0cyA9IGJpdExlbihCaWdJbnQocG9pbnRzLmxlbmd0aCkpO1xuICAgIGNvbnN0IHdpbmRvd1NpemUgPSB3Yml0cyA+IDEyID8gd2JpdHMgLSAzIDogd2JpdHMgPiA0ID8gd2JpdHMgLSAyIDogd2JpdHMgPyAyIDogMTsgLy8gaW4gYml0c1xuICAgIGNvbnN0IE1BU0sgPSAoMSA8PCB3aW5kb3dTaXplKSAtIDE7XG4gICAgY29uc3QgYnVja2V0cyA9IG5ldyBBcnJheShNQVNLICsgMSkuZmlsbCh6ZXJvKTsgLy8gKzEgZm9yIHplcm8gYXJyYXlcbiAgICBjb25zdCBsYXN0Qml0cyA9IE1hdGguZmxvb3IoKGZpZWxkTi5CSVRTIC0gMSkgLyB3aW5kb3dTaXplKSAqIHdpbmRvd1NpemU7XG4gICAgbGV0IHN1bSA9IHplcm87XG4gICAgZm9yIChsZXQgaSA9IGxhc3RCaXRzOyBpID49IDA7IGkgLT0gd2luZG93U2l6ZSkge1xuICAgICAgICBidWNrZXRzLmZpbGwoemVybyk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2NhbGFycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGFyID0gc2NhbGFyc1tqXTtcbiAgICAgICAgICAgIGNvbnN0IHdiaXRzID0gTnVtYmVyKChzY2FsYXIgPj4gQmlnSW50KGkpKSAmIEJpZ0ludChNQVNLKSk7XG4gICAgICAgICAgICBidWNrZXRzW3diaXRzXSA9IGJ1Y2tldHNbd2JpdHNdLmFkZChwb2ludHNbal0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXNJID0gemVybzsgLy8gbm90IHVzaW5nIHRoaXMgd2lsbCBkbyBzbWFsbCBzcGVlZC11cCwgYnV0IHdpbGwgbG9zZSBjdFxuICAgICAgICAvLyBTa2lwIGZpcnN0IGJ1Y2tldCwgYmVjYXVzZSBpdCBpcyB6ZXJvXG4gICAgICAgIGZvciAobGV0IGogPSBidWNrZXRzLmxlbmd0aCAtIDEsIHN1bUkgPSB6ZXJvOyBqID4gMDsgai0tKSB7XG4gICAgICAgICAgICBzdW1JID0gc3VtSS5hZGQoYnVja2V0c1tqXSk7XG4gICAgICAgICAgICByZXNJID0gcmVzSS5hZGQoc3VtSSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VtID0gc3VtLmFkZChyZXNJKTtcbiAgICAgICAgaWYgKGkgIT09IDApXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHdpbmRvd1NpemU7IGorKylcbiAgICAgICAgICAgICAgICBzdW0gPSBzdW0uZG91YmxlKCk7XG4gICAgfVxuICAgIHJldHVybiBzdW07XG59XG4vKipcbiAqIFByZWNvbXB1dGVkIG11bHRpLXNjYWxhciBtdWx0aXBsaWNhdGlvbiAoTVNNLCBQYSArIFFiICsgUmMgKyAuLi4pLlxuICogQHBhcmFtIGMgQ3VydmUgUG9pbnQgY29uc3RydWN0b3JcbiAqIEBwYXJhbSBmaWVsZE4gZmllbGQgb3ZlciBDVVJWRS5OIC0gaW1wb3J0YW50IHRoYXQgaXQncyBub3Qgb3ZlciBDVVJWRS5QXG4gKiBAcGFyYW0gcG9pbnRzIGFycmF5IG9mIEwgY3VydmUgcG9pbnRzXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB3aGljaCBtdWx0aXBsaWVzIHBvaW50cyB3aXRoIHNjYWFyc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlY29tcHV0ZU1TTVVuc2FmZShjLCBmaWVsZE4sIHBvaW50cywgd2luZG93U2l6ZSkge1xuICAgIC8qKlxuICAgICAqIFBlcmZvcm1hbmNlIEFuYWx5c2lzIG9mIFdpbmRvdy1iYXNlZCBQcmVjb21wdXRhdGlvblxuICAgICAqXG4gICAgICogQmFzZSBDYXNlICgyNTYtYml0IHNjYWxhciwgOC1iaXQgd2luZG93KTpcbiAgICAgKiAtIFN0YW5kYXJkIHByZWNvbXB1dGF0aW9uIHJlcXVpcmVzOlxuICAgICAqICAgLSAzMSBhZGRpdGlvbnMgcGVyIHNjYWxhciDDlyAyNTYgc2NhbGFycyA9IDcsOTM2IG9wc1xuICAgICAqICAgLSBQbHVzIDI1NSBzdW1tYXJ5IGFkZGl0aW9ucyA9IDgsMTkxIHRvdGFsIG9wc1xuICAgICAqICAgTm90ZTogU3VtbWFyeSBhZGRpdGlvbnMgY2FuIGJlIG9wdGltaXplZCB2aWEgYWNjdW11bGF0b3JcbiAgICAgKlxuICAgICAqIENodW5rZWQgUHJlY29tcHV0YXRpb24gQW5hbHlzaXM6XG4gICAgICogLSBVc2luZyAzMiBjaHVua3MgcmVxdWlyZXM6XG4gICAgICogICAtIDI1NSBhZGRpdGlvbnMgcGVyIGNodW5rXG4gICAgICogICAtIDI1NiBkb3VibGluZ3NcbiAgICAgKiAgIC0gVG90YWw6ICgyNTUgw5cgMzIpICsgMjU2ID0gOCw0MTYgb3BzXG4gICAgICpcbiAgICAgKiBNZW1vcnkgVXNhZ2UgQ29tcGFyaXNvbjpcbiAgICAgKiBXaW5kb3cgU2l6ZSB8IFN0YW5kYXJkIFBvaW50cyB8IENodW5rZWQgUG9pbnRzXG4gICAgICogLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLS0tfC0tLS0tLS0tLS0tLS0tLVxuICAgICAqICAgICA0LWJpdCAgIHwgICAgIDUyMCAgICAgICAgIHwgICAgICAxNVxuICAgICAqICAgICA4LWJpdCAgIHwgICAgNCwyMjQgICAgICAgIHwgICAgIDI1NVxuICAgICAqICAgIDEwLWJpdCAgIHwgICAxMyw4MjQgICAgICAgIHwgICAxLDAyM1xuICAgICAqICAgIDE2LWJpdCAgIHwgIDU1NywwNTYgICAgICAgIHwgIDY1LDUzNVxuICAgICAqXG4gICAgICogS2V5IEFkdmFudGFnZXM6XG4gICAgICogMS4gRW5hYmxlcyBsYXJnZXIgd2luZG93IHNpemVzIGR1ZSB0byByZWR1Y2VkIG1lbW9yeSBvdmVyaGVhZFxuICAgICAqIDIuIE1vcmUgZWZmaWNpZW50IGZvciBzbWFsbGVyIHNjYWxhciBjb3VudHM6XG4gICAgICogICAgLSAxNiBjaHVua3M6ICgxNiDDlyAyNTUpICsgMjU2ID0gNCwzMzYgb3BzXG4gICAgICogICAgLSB+MnggZmFzdGVyIHRoYW4gc3RhbmRhcmQgOCwxOTEgb3BzXG4gICAgICpcbiAgICAgKiBMaW1pdGF0aW9uczpcbiAgICAgKiAtIE5vdCBzdWl0YWJsZSBmb3IgcGxhaW4gcHJlY29tcHV0ZXMgKHJlcXVpcmVzIDI1NiBjb25zdGFudCBkb3VibGluZ3MpXG4gICAgICogLSBQZXJmb3JtYW5jZSBkZWdyYWRlcyB3aXRoIGxhcmdlciBzY2FsYXIgY291bnRzOlxuICAgICAqICAgLSBPcHRpbWFsIGZvciB+MjU2IHNjYWxhcnNcbiAgICAgKiAgIC0gTGVzcyBlZmZpY2llbnQgZm9yIDQwOTYrIHNjYWxhcnMgKFBpcHBlbmdlciBwcmVmZXJyZWQpXG4gICAgICovXG4gICAgdmFsaWRhdGVXKHdpbmRvd1NpemUsIGZpZWxkTi5CSVRTKTtcbiAgICB2YWxpZGF0ZU1TTVBvaW50cyhwb2ludHMsIGMpO1xuICAgIGNvbnN0IHplcm8gPSBjLlpFUk87XG4gICAgY29uc3QgdGFibGVTaXplID0gMiAqKiB3aW5kb3dTaXplIC0gMTsgLy8gdGFibGUgc2l6ZSAod2l0aG91dCB6ZXJvKVxuICAgIGNvbnN0IGNodW5rcyA9IE1hdGguY2VpbChmaWVsZE4uQklUUyAvIHdpbmRvd1NpemUpOyAvLyBjaHVua3Mgb2YgaXRlbVxuICAgIGNvbnN0IE1BU0sgPSBCaWdJbnQoKDEgPDwgd2luZG93U2l6ZSkgLSAxKTtcbiAgICBjb25zdCB0YWJsZXMgPSBwb2ludHMubWFwKChwKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgYWNjID0gcDsgaSA8IHRhYmxlU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICByZXMucHVzaChhY2MpO1xuICAgICAgICAgICAgYWNjID0gYWNjLmFkZChwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0pO1xuICAgIHJldHVybiAoc2NhbGFycykgPT4ge1xuICAgICAgICB2YWxpZGF0ZU1TTVNjYWxhcnMoc2NhbGFycywgZmllbGROKTtcbiAgICAgICAgaWYgKHNjYWxhcnMubGVuZ3RoID4gcG9pbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXJyYXkgb2Ygc2NhbGFycyBtdXN0IGJlIHNtYWxsZXIgdGhhbiBhcnJheSBvZiBwb2ludHMnKTtcbiAgICAgICAgbGV0IHJlcyA9IHplcm87XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2h1bmtzOyBpKyspIHtcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gZG91YmxlIGlmIGFjY3VtdWxhdG9yIGlzIHN0aWxsIHplcm8uXG4gICAgICAgICAgICBpZiAocmVzICE9PSB6ZXJvKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2luZG93U2l6ZTsgaisrKVxuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuZG91YmxlKCk7XG4gICAgICAgICAgICBjb25zdCBzaGlmdEJ5ID0gQmlnSW50KGNodW5rcyAqIHdpbmRvd1NpemUgLSAoaSArIDEpICogd2luZG93U2l6ZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHNjYWxhcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gc2NhbGFyc1tqXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyID0gTnVtYmVyKChuID4+IHNoaWZ0QnkpICYgTUFTSyk7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gc2tpcCB6ZXJvIHNjYWxhcnMgY2h1bmtzXG4gICAgICAgICAgICAgICAgcmVzID0gcmVzLmFkZCh0YWJsZXNbal1bY3VyciAtIDFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVCYXNpYyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlRmllbGQoY3VydmUuRnApO1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIG46ICdiaWdpbnQnLFxuICAgICAgICBoOiAnYmlnaW50JyxcbiAgICAgICAgR3g6ICdmaWVsZCcsXG4gICAgICAgIEd5OiAnZmllbGQnLFxuICAgIH0sIHtcbiAgICAgICAgbkJpdExlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgLi4ubkxlbmd0aChjdXJ2ZS5uLCBjdXJ2ZS5uQml0TGVuZ3RoKSxcbiAgICAgICAgLi4uY3VydmUsXG4gICAgICAgIC4uLnsgcDogY3VydmUuRnAuT1JERVIgfSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: () => (/* binding */ createHasher),\n/* harmony export */   expand_message_xmd: () => (/* binding */ expand_message_xmd),\n/* harmony export */   expand_message_xof: () => (/* binding */ expand_message_xof),\n/* harmony export */   hash_to_field: () => (/* binding */ hash_to_field),\n/* harmony export */   isogenyMap: () => (/* binding */ isogenyMap)\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    anum(value);\n    anum(length);\n    if (value < 0 || value >= 1 << (8 * length))\n        throw new Error('invalid I2OSP input: ' + value);\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (lenInBytes > 65535 || ell > 255)\n        throw new Error('expand_message_xmd: invalid lenInBytes');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x: x, y: y };\n    };\n}\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Same as encodeToCurve, but without hash\n        mapToCurve(scalars) {\n            if (!Array.isArray(scalars))\n                throw new Error('mapToCurve: expected array of bigints');\n            for (const i of scalars)\n                if (typeof i !== 'bigint')\n                    throw new Error('mapToCurve: expected array of bigints');\n            const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDNEQ7QUFDL0Y7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLGlEQUFNO0FBQ1YsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBVyxDQUFDLHNEQUFXO0FBQ3ZDLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBVztBQUNqQztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQixzREFBVztBQUM3QixhQUFhLHNEQUFXO0FBQ3hCLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0EsZ0NBQWdDLHNEQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxpREFBTTtBQUNWLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sU0FBUyxzREFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2RUFBNkU7QUFDakc7QUFDQTtBQUNPO0FBQ1AsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksbUNBQW1DO0FBQy9DLElBQUksaURBQU07QUFDVjtBQUNBLDJDQUEyQyxzREFBVztBQUN0RDtBQUNBLDBDQUEwQztBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0EsbUJBQW1CLGdEQUFHO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlEQUFpRDtBQUNqRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0NBQWtDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHdDQUF3QztBQUN0RjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWlpbmFkb2kvRGVza3RvcC9naXRodWJQcm9qZWN0L3Rocmlkd2VidHV0b3JpYWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbW9kIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGFieXRlcywgYnl0ZXNUb051bWJlckJFLCBjb25jYXRCeXRlcywgdXRmOFRvQnl0ZXMsIHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBPY3RldCBTdHJlYW0gdG8gSW50ZWdlci4gXCJzcGVjXCIgaW1wbGVtZW50YXRpb24gb2Ygb3MyaXAgaXMgMi41eCBzbG93ZXIgdnMgYnl0ZXNUb051bWJlckJFLlxuY29uc3Qgb3MyaXAgPSBieXRlc1RvTnVtYmVyQkU7XG4vLyBJbnRlZ2VyIHRvIE9jdGV0IFN0cmVhbSAobnVtYmVyVG9CeXRlc0JFKVxuZnVuY3Rpb24gaTJvc3AodmFsdWUsIGxlbmd0aCkge1xuICAgIGFudW0odmFsdWUpO1xuICAgIGFudW0obGVuZ3RoKTtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgSTJPU1AgaW5wdXQ6ICcgKyB2YWx1ZSk7XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBhbnVtKGl0ZW0pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGl0ZW0pKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ251bWJlciBleHBlY3RlZCcpO1xufVxuLyoqXG4gKiBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzLlxuICogW1JGQyA5MzgwIDUuMy4xXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMy4xKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgbGVuSW5CeXRlcywgSCkge1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFieXRlcyhEU1QpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmRfbWVzc2FnZV94bWQ6IGludmFsaWQgbGVuSW5CeXRlcycpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbi8qKlxuICogUHJvZHVjZXMgYSB1bmlmb3JtbHkgcmFuZG9tIGJ5dGUgc3RyaW5nIHVzaW5nIGFuIGV4dGVuZGFibGUtb3V0cHV0IGZ1bmN0aW9uIChYT0YpIEguXG4gKiAxLiBUaGUgY29sbGlzaW9uIHJlc2lzdGFuY2Ugb2YgSCBNVVNUIGJlIGF0IGxlYXN0IGsgYml0cy5cbiAqIDIuIEggTVVTVCBiZSBhbiBYT0YgdGhhdCBoYXMgYmVlbiBwcm92ZWQgaW5kaWZmZXJlbnRpYWJsZSBmcm9tXG4gKiAgICBhIHJhbmRvbSBvcmFjbGUgdW5kZXIgYSByZWFzb25hYmxlIGNyeXB0b2dyYXBoaWMgYXNzdW1wdGlvbi5cbiAqIFtSRkMgOTM4MCA1LjMuMl0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMikuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICAvLyBEU1QgPSBIKCdIMkMtT1ZFUlNJWkUtRFNULScgfHwgYV92ZXJ5X2xvbmdfRFNULCBNYXRoLmNlaWwoKGxlbkluQnl0ZXMgKiBrKSAvIDgpKTtcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSkge1xuICAgICAgICBjb25zdCBka0xlbiA9IE1hdGguY2VpbCgoMiAqIGspIC8gOCk7XG4gICAgICAgIERTVCA9IEguY3JlYXRlKHsgZGtMZW4gfSkudXBkYXRlKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpKS51cGRhdGUoRFNUKS5kaWdlc3QoKTtcbiAgICB9XG4gICAgaWYgKGxlbkluQnl0ZXMgPiA2NTUzNSB8fCBEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGFuZF9tZXNzYWdlX3hvZjogaW52YWxpZCBsZW5JbkJ5dGVzJyk7XG4gICAgcmV0dXJuIChILmNyZWF0ZSh7IGRrTGVuOiBsZW5JbkJ5dGVzIH0pXG4gICAgICAgIC51cGRhdGUobXNnKVxuICAgICAgICAudXBkYXRlKGkyb3NwKGxlbkluQnl0ZXMsIDIpKVxuICAgICAgICAvLyAyLiBEU1RfcHJpbWUgPSBEU1QgfHwgSTJPU1AobGVuKERTVCksIDEpXG4gICAgICAgIC51cGRhdGUoRFNUKVxuICAgICAgICAudXBkYXRlKGkyb3NwKERTVC5sZW5ndGgsIDEpKVxuICAgICAgICAuZGlnZXN0KCkpO1xufVxuLyoqXG4gKiBIYXNoZXMgYXJiaXRyYXJ5LWxlbmd0aCBieXRlIHN0cmluZ3MgdG8gYSBsaXN0IG9mIG9uZSBvciBtb3JlIGVsZW1lbnRzIG9mIGEgZmluaXRlIGZpZWxkIEYuXG4gKiBbUkZDIDkzODAgNS4yXShodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTUuMikuXG4gKiBAcGFyYW0gbXNnIGEgYnl0ZSBzdHJpbmcgY29udGFpbmluZyB0aGUgbWVzc2FnZSB0byBoYXNoXG4gKiBAcGFyYW0gY291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiBGIHRvIG91dHB1dFxuICogQHBhcmFtIG9wdGlvbnMgYHtEU1Q6IHN0cmluZywgcDogYmlnaW50LCBtOiBudW1iZXIsIGs6IG51bWJlciwgZXhwYW5kOiAneG1kJyB8ICd4b2YnLCBoYXNoOiBIfWAsIHNlZSBhYm92ZVxuICogQHJldHVybnMgW3VfMCwgLi4uLCB1Xyhjb3VudCAtIDEpXSwgYSBsaXN0IG9mIGZpZWxkIGVsZW1lbnRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaF90b19maWVsZChtc2csIGNvdW50LCBvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVPYmplY3Qob3B0aW9ucywge1xuICAgICAgICBEU1Q6ICdzdHJpbmdPclVpbnQ4QXJyYXknLFxuICAgICAgICBwOiAnYmlnaW50JyxcbiAgICAgICAgbTogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBrOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IHAsIGssIG0sIGhhc2gsIGV4cGFuZCwgRFNUOiBfRFNUIH0gPSBvcHRpb25zO1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFudW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHR5cGVvZiBfRFNUID09PSAnc3RyaW5nJyA/IHV0ZjhUb0J5dGVzKF9EU1QpIDogX0RTVDtcbiAgICBjb25zdCBsb2cycCA9IHAudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IEwgPSBNYXRoLmNlaWwoKGxvZzJwICsgaykgLyA4KTsgLy8gc2VjdGlvbiA1LjEgb2YgaWV0ZiBkcmFmdCBsaW5rIGFib3ZlXG4gICAgY29uc3QgbGVuX2luX2J5dGVzID0gY291bnQgKiBtICogTDtcbiAgICBsZXQgcHJiOyAvLyBwc2V1ZG9fcmFuZG9tX2J5dGVzXG4gICAgaWYgKGV4cGFuZCA9PT0gJ3htZCcpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG1kKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICd4b2YnKSB7XG4gICAgICAgIHByYiA9IGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuX2luX2J5dGVzLCBrLCBoYXNoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXhwYW5kID09PSAnX2ludGVybmFsX3Bhc3MnKSB7XG4gICAgICAgIC8vIGZvciBpbnRlcm5hbCB0ZXN0cyBvbmx5XG4gICAgICAgIHByYiA9IG1zZztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kIG11c3QgYmUgXCJ4bWRcIiBvciBcInhvZlwiJyk7XG4gICAgfVxuICAgIGNvbnN0IHUgPSBuZXcgQXJyYXkoY291bnQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICBjb25zdCBlID0gbmV3IEFycmF5KG0pO1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG07IGorKykge1xuICAgICAgICAgICAgY29uc3QgZWxtX29mZnNldCA9IEwgKiAoaiArIGkgKiBtKTtcbiAgICAgICAgICAgIGNvbnN0IHR2ID0gcHJiLnN1YmFycmF5KGVsbV9vZmZzZXQsIGVsbV9vZmZzZXQgKyBMKTtcbiAgICAgICAgICAgIGVbal0gPSBtb2Qob3MyaXAodHYpLCBwKTtcbiAgICAgICAgfVxuICAgICAgICB1W2ldID0gZTtcbiAgICB9XG4gICAgcmV0dXJuIHU7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNvZ2VueU1hcChmaWVsZCwgbWFwKSB7XG4gICAgLy8gTWFrZSBzYW1lIG9yZGVyIGFzIGluIHNwZWNcbiAgICBjb25zdCBDT0VGRiA9IG1hcC5tYXAoKGkpID0+IEFycmF5LmZyb20oaSkucmV2ZXJzZSgpKTtcbiAgICByZXR1cm4gKHgsIHkpID0+IHtcbiAgICAgICAgY29uc3QgW3hOdW0sIHhEZW4sIHlOdW0sIHlEZW5dID0gQ09FRkYubWFwKCh2YWwpID0+IHZhbC5yZWR1Y2UoKGFjYywgaSkgPT4gZmllbGQuYWRkKGZpZWxkLm11bChhY2MsIHgpLCBpKSkpO1xuICAgICAgICB4ID0gZmllbGQuZGl2KHhOdW0sIHhEZW4pOyAvLyB4TnVtIC8geERlblxuICAgICAgICB5ID0gZmllbGQubXVsKHksIGZpZWxkLmRpdih5TnVtLCB5RGVuKSk7IC8vIHkgKiAoeU51bSAvIHlEZXYpXG4gICAgICAgIHJldHVybiB7IHg6IHgsIHk6IHkgfTtcbiAgICB9O1xufVxuLyoqIENyZWF0ZXMgaGFzaC10by1jdXJ2ZSBtZXRob2RzIGZyb20gRUMgUG9pbnQgYW5kIG1hcFRvQ3VydmUgZnVuY3Rpb24uICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmLCBEU1Q6IGRlZi5EU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzFdKSk7XG4gICAgICAgICAgICBjb25zdCBQID0gdTAuYWRkKHUxKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gU2FtZSBhcyBlbmNvZGVUb0N1cnZlLCBidXQgd2l0aG91dCBoYXNoXG4gICAgICAgIG1hcFRvQ3VydmUoc2NhbGFycykge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjYWxhcnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZTogZXhwZWN0ZWQgYXJyYXkgb2YgYmlnaW50cycpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBpIG9mIHNjYWxhcnMpXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlOiBleHBlY3RlZCBhcnJheSBvZiBiaWdpbnRzJyk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHNjYWxhcnMpKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC10by1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: () => (/* binding */ Field),\n/* harmony export */   FpDiv: () => (/* binding */ FpDiv),\n/* harmony export */   FpInvertBatch: () => (/* binding */ FpInvertBatch),\n/* harmony export */   FpIsSquare: () => (/* binding */ FpIsSquare),\n/* harmony export */   FpLegendre: () => (/* binding */ FpLegendre),\n/* harmony export */   FpPow: () => (/* binding */ FpPow),\n/* harmony export */   FpSqrt: () => (/* binding */ FpSqrt),\n/* harmony export */   FpSqrtEven: () => (/* binding */ FpSqrtEven),\n/* harmony export */   FpSqrtOdd: () => (/* binding */ FpSqrtOdd),\n/* harmony export */   getFieldBytesLength: () => (/* binding */ getFieldBytesLength),\n/* harmony export */   getMinHashLength: () => (/* binding */ getMinHashLength),\n/* harmony export */   hashToPrivateScalar: () => (/* binding */ hashToPrivateScalar),\n/* harmony export */   invert: () => (/* binding */ invert),\n/* harmony export */   isNegativeLE: () => (/* binding */ isNegativeLE),\n/* harmony export */   mapHashToField: () => (/* binding */ mapHashToField),\n/* harmony export */   mod: () => (/* binding */ mod),\n/* harmony export */   nLength: () => (/* binding */ nLength),\n/* harmony export */   pow: () => (/* binding */ pow),\n/* harmony export */   pow2: () => (/* binding */ pow2),\n/* harmony export */   tonelliShanks: () => (/* binding */ tonelliShanks),\n/* harmony export */   validateField: () => (/* binding */ validateField)\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @todo use field version && remove\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nfunction pow(num, power, modulo) {\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (modulo <= _0n)\n        throw new Error('invalid modulus');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nfunction invert(number, modulo) {\n    if (number === _0n)\n        throw new Error('invert: expected non-zero number');\n    if (modulo <= _0n)\n        throw new Error('invert: expected positive modulus, got ' + modulo);\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n        // Crash instead of infinity loop, we cannot reasonable count until P.\n        if (Z > 1000)\n            throw new Error('Cannot find square root: likely non-prime P');\n    }\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. P ≡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nfunction FpSqrt(P) {\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('invalid exponent, negatives unsupported');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n/**\n * Legendre symbol.\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */\nfunction FpLegendre(order) {\n    const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n    return (f, x) => f.pow(x, legendreConst);\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendre = FpLegendre(f.ORDER);\n    return (x) => {\n        const p = legendre(f, x);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n    let sqrtP; // cached sqrtP\n    const f = Object.freeze({\n        ORDER,\n        isLE,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error('invalid field element: expected bigint, got ' + typeof num);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt ||\n            ((n) => {\n                if (!sqrtP)\n                    sqrtP = FpSqrt(ORDER);\n                return sqrtP(f, n);\n            }),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(\"Field doesn't have isOdd\");\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUN1STtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQSxrQkFBa0IsMkNBQTJDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDLG1DQUFtQztBQUNuQyw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EscUNBQXFDLE9BQU87QUFDNUM7QUFDQTtBQUNBLGlDQUFpQztB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TztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMERBQWUsUUFBUSwwREFBZTtBQUM3RDtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFlLHNCQUFzQiwwREFBZTtBQUN0RTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWlpbmFkb2kvRGVza3RvcC9naXRodWJQcm9qZWN0L3Rocmlkd2VidHV0b3JpYWwvbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBVdGlscyBmb3IgbW9kdWxhciBkaXZpc2lvbiBhbmQgZmluaXRlIGZpZWxkcy5cbiAqIEEgZmluaXRlIGZpZWxkIG92ZXIgMTEgaXMgaW50ZWdlciBudW1iZXIgb3BlcmF0aW9ucyBgbW9kIDExYC5cbiAqIFRoZXJlIGlzIG5vIGRpdmlzaW9uOiBpdCBpcyByZXBsYWNlZCBieSBtb2R1bGFyIG11bHRpcGxpY2F0aXZlIGludmVyc2UuXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGJpdE1hc2ssIGJ5dGVzVG9OdW1iZXJCRSwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0JFLCBudW1iZXJUb0J5dGVzTEUsIHZhbGlkYXRlT2JqZWN0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyKSwgXzNuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzRuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg0KSwgXzVuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg1KSwgXzhuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg4KTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzluID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg5KSwgXzE2biA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMTYpO1xuLy8gQ2FsY3VsYXRlcyBhIG1vZHVsbyBiXG5leHBvcnQgZnVuY3Rpb24gbW9kKGEsIGIpIHtcbiAgICBjb25zdCByZXN1bHQgPSBhICUgYjtcbiAgICByZXR1cm4gcmVzdWx0ID49IF8wbiA/IHJlc3VsdCA6IGIgKyByZXN1bHQ7XG59XG4vKipcbiAqIEVmZmljaWVudGx5IHJhaXNlIG51bSB0byBwb3dlciBhbmQgZG8gbW9kdWxhciBkaXZpc2lvbi5cbiAqIFVuc2FmZSBpbiBzb21lIGNvbnRleHRzOiB1c2VzIGxhZGRlciwgc28gY2FuIGV4cG9zZSBiaWdpbnQgYml0cy5cbiAqIEB0b2RvIHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3cobnVtLCBwb3dlciwgbW9kdWxvKSB7XG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZXhwb25lbnQsIG5lZ2F0aXZlcyB1bnN1cHBvcnRlZCcpO1xuICAgIGlmIChtb2R1bG8gPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbW9kdWx1cycpO1xuICAgIGlmIChtb2R1bG8gPT09IF8xbilcbiAgICAgICAgcmV0dXJuIF8wbjtcbiAgICBsZXQgcmVzID0gXzFuO1xuICAgIHdoaWxlIChwb3dlciA+IF8wbikge1xuICAgICAgICBpZiAocG93ZXIgJiBfMW4pXG4gICAgICAgICAgICByZXMgPSAocmVzICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgbnVtID0gKG51bSAqIG51bSkgJSBtb2R1bG87XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vKiogRG9lcyBgeF4oMl5wb3dlcilgIG1vZCBwLiBgcG93MigzMCwgNClgID09IGAzMF4oMl40KWAgKi9cbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLyoqXG4gKiBJbnZlcnNlcyBudW1iZXIgb3ZlciBtb2R1bG8uXG4gKiBJbXBsZW1lbnRlZCB1c2luZyBbRXVjbGlkZWFuIEdDRF0oaHR0cHM6Ly9icmlsbGlhbnQub3JnL3dpa2kvZXh0ZW5kZWQtZXVjbGlkZWFuLWFsZ29yaXRobS8pLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZXhwZWN0ZWQgbm9uLXplcm8gbnVtYmVyJyk7XG4gICAgaWYgKG1vZHVsbyA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52ZXJ0OiBleHBlY3RlZCBwb3NpdGl2ZSBtb2R1bHVzLCBnb3QgJyArIG1vZHVsbyk7XG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vKipcbiAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcbiAqIFdpbGwgc3RhcnQgYW4gaW5maW5pdGUgbG9vcCBpZiBmaWVsZCBvcmRlciBQIGlzIG5vdCBwcmltZS5cbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBMZWdlbmRyZSBjb25zdGFudDogdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcCksXG4gICAgLy8gd2hpY2ggZGVub3RlcyB0aGUgdmFsdWUgb2YgYV4oKHAtMSkvMikgKG1vZCBwKS5cbiAgICAvLyAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gICAgY29uc3QgbGVnZW5kcmVDID0gKFAgLSBfMW4pIC8gXzJuO1xuICAgIGxldCBRLCBTLCBaO1xuICAgIC8vIFN0ZXAgMTogQnkgZmFjdG9yaW5nIG91dCBwb3dlcnMgb2YgMiBmcm9tIHAgLSAxLFxuICAgIC8vIGZpbmQgcSBhbmQgcyBzdWNoIHRoYXQgcCAtIDEgPSBxKigyXnMpIHdpdGggcSBvZGRcbiAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxuICAgICAgICA7XG4gICAgLy8gU3RlcCAyOiBTZWxlY3QgYSBub24tc3F1YXJlIHogc3VjaCB0aGF0ICh6IHwgcCkg4omhIC0xIGFuZCBzZXQgYyDiiaEgenFcbiAgICBmb3IgKFogPSBfMm47IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuOyBaKyspIHtcbiAgICAgICAgLy8gQ3Jhc2ggaW5zdGVhZCBvZiBpbmZpbml0eSBsb29wLCB3ZSBjYW5ub3QgcmVhc29uYWJsZSBjb3VudCB1bnRpbCBQLlxuICAgICAgICBpZiAoWiA+IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290OiBsaWtlbHkgbm9uLXByaW1lIFAnKTtcbiAgICB9XG4gICAgLy8gRmFzdC1wYXRoXG4gICAgaWYgKFMgPT09IDEpIHtcbiAgICAgICAgY29uc3QgcDFkaXY0ID0gKFAgKyBfMW4pIC8gXzRuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaUZhc3QoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFNsb3ctcGF0aFxuICAgIGNvbnN0IFExZGl2MiA9IChRICsgXzFuKSAvIF8ybjtcbiAgICByZXR1cm4gZnVuY3Rpb24gdG9uZWxsaVNsb3coRnAsIG4pIHtcbiAgICAgICAgLy8gU3RlcCAwOiBDaGVjayB0aGF0IG4gaXMgaW5kZWVkIGEgc3F1YXJlOiAobiB8IHApIHNob3VsZCBub3QgYmUg4omhIC0xXG4gICAgICAgIGlmIChGcC5wb3cobiwgbGVnZW5kcmVDKSA9PT0gRnAubmVnKEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgIGxldCByID0gUztcbiAgICAgICAgLy8gVE9ETzogd2lsbCBmYWlsIGF0IEZwMi9ldGNcbiAgICAgICAgbGV0IGcgPSBGcC5wb3coRnAubXVsKEZwLk9ORSwgWiksIFEpOyAvLyB3aWxsIHVwZGF0ZSBib3RoIHggYW5kIGJcbiAgICAgICAgbGV0IHggPSBGcC5wb3cobiwgUTFkaXYyKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIHNxdWFyZSByb290XG4gICAgICAgIGxldCBiID0gRnAucG93KG4sIFEpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgZnVkZ2UgZmFjdG9yXG4gICAgICAgIHdoaWxlICghRnAuZXFsKGIsIEZwLk9ORSkpIHtcbiAgICAgICAgICAgIGlmIChGcC5lcWwoYiwgRnAuWkVSTykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIEZwLlpFUk87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvbmVsbGklRTIlODAlOTNTaGFua3NfYWxnb3JpdGhtICg0LiBJZiB0ID0gMCwgcmV0dXJuIHIgPSAwKVxuICAgICAgICAgICAgLy8gRmluZCBtIHN1Y2ggYl4oMl5tKT09MVxuICAgICAgICAgICAgbGV0IG0gPSAxO1xuICAgICAgICAgICAgZm9yIChsZXQgdDIgPSBGcC5zcXIoYik7IG0gPCByOyBtKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoRnAuZXFsKHQyLCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0MiA9IEZwLnNxcih0Mik7IC8vIHQyICo9IHQyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOT1RFOiByLW0tMSBjYW4gYmUgYmlnZ2VyIHRoYW4gMzIsIG5lZWQgdG8gY29udmVydCB0byBiaWdpbnQgYmVmb3JlIHNoaWZ0LCBvdGhlcndpc2UgdGhlcmUgd2lsbCBiZSBvdmVyZmxvd1xuICAgICAgICAgICAgY29uc3QgZ2UgPSBGcC5wb3coZywgXzFuIDw8IEJpZ0ludChyIC0gbSAtIDEpKTsgLy8gZ2UgPSAyXihyLW0tMSlcbiAgICAgICAgICAgIGcgPSBGcC5zcXIoZ2UpOyAvLyBnID0gZ2UgKiBnZVxuICAgICAgICAgICAgeCA9IEZwLm11bCh4LCBnZSk7IC8vIHggKj0gZ2VcbiAgICAgICAgICAgIGIgPSBGcC5tdWwoYiwgZyk7IC8vIGIgKj0gZ1xuICAgICAgICAgICAgciA9IG07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfTtcbn1cbi8qKlxuICogU3F1YXJlIHJvb3QgZm9yIGEgZmluaXRlIGZpZWxkLiBJdCB3aWxsIHRyeSB0byBjaGVjayBpZiBvcHRpbWl6YXRpb25zIGFyZSBhcHBsaWNhYmxlIGFuZCBmYWxsIGJhY2sgdG8gNDpcbiAqXG4gKiAxLiBQIOKJoSAzIChtb2QgNClcbiAqIDIuIFAg4omhIDUgKG1vZCA4KVxuICogMy4gUCDiiaEgOSAobW9kIDE2KVxuICogNC4gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gKlxuICogRGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICogRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnQoUCkge1xuICAgIC8vIFAg4omhIDMgKG1vZCA0KVxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XG4gICAgICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxuICAgICAgICAvLyBNZWFucyB3ZSBjYW5ub3QgdXNlIHNxcnQgZm9yIGNvbnN0YW50cyBhdCBhbGwhXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICAvLyBzcXJ0ID0gKHgpID0+IHtcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMiA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYzKSwgeCk7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMyA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZXhwb25lbnQsIG5lZ2F0aXZlcyB1bnN1cHBvcnRlZCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBmLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbi8qKlxuICogTGVnZW5kcmUgc3ltYm9sLlxuICogKiAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKSwgcXVhZHJhdGljIHJlc2lkdWVcbiAqICogKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApLCBxdWFkcmF0aWMgbm9uIHJlc2lkdWVcbiAqICogKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZwTGVnZW5kcmUob3JkZXIpIHtcbiAgICBjb25zdCBsZWdlbmRyZUNvbnN0ID0gKG9yZGVyIC0gXzFuKSAvIF8ybjsgLy8gSW50ZWdlciBhcml0aG1ldGljXG4gICAgcmV0dXJuIChmLCB4KSA9PiBmLnBvdyh4LCBsZWdlbmRyZUNvbnN0KTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlID0gRnBMZWdlbmRyZShmLk9SREVSKTtcbiAgICByZXR1cm4gKHgpID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGxlZ2VuZHJlKGYsIHgpO1xuICAgICAgICByZXR1cm4gZi5lcWwocCwgZi5aRVJPKSB8fCBmLmVxbChwLCBmLk9ORSk7XG4gICAgfTtcbn1cbi8vIENVUlZFLm4gbGVuZ3Roc1xuZXhwb3J0IGZ1bmN0aW9uIG5MZW5ndGgobiwgbkJpdExlbmd0aCkge1xuICAgIC8vIEJpdCBzaXplLCBieXRlIHNpemUgb2YgQ1VSVkUublxuICAgIGNvbnN0IF9uQml0TGVuZ3RoID0gbkJpdExlbmd0aCAhPT0gdW5kZWZpbmVkID8gbkJpdExlbmd0aCA6IG4udG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIGNvbnN0IG5CeXRlTGVuZ3RoID0gTWF0aC5jZWlsKF9uQml0TGVuZ3RoIC8gOCk7XG4gICAgcmV0dXJuIHsgbkJpdExlbmd0aDogX25CaXRMZW5ndGgsIG5CeXRlTGVuZ3RoIH07XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgZmluaXRlIGZpZWxkIG92ZXIgcHJpbWUuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBGcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGEgY2hhbmdlLlxuICogU2VjdXJpdHkgbm90ZTogb3BlcmF0aW9ucyBkb24ndCBjaGVjayAnaXNWYWxpZCcgZm9yIGFsbCBlbGVtZW50cyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyxcbiAqIGl0IGlzIGNhbGxlciByZXNwb25zaWJpbGl0eSB0byBjaGVjayB0aGlzLlxuICogVGhpcyBpcyBsb3ctbGV2ZWwgY29kZSwgcGxlYXNlIG1ha2Ugc3VyZSB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZy5cbiAqIEBwYXJhbSBPUkRFUiBwcmltZSBwb3NpdGl2ZSBiaWdpbnRcbiAqIEBwYXJhbSBiaXRMZW4gaG93IG1hbnkgYml0cyB0aGUgZmllbGQgY29uc3VtZXNcbiAqIEBwYXJhbSBpc0xFIChkZWY6IGZhbHNlKSBpZiBlbmNvZGluZyAvIGRlY29kaW5nIHNob3VsZCBiZSBpbiBsaXR0bGUtZW5kaWFuXG4gKiBAcGFyYW0gcmVkZWYgb3B0aW9uYWwgZmFzdGVyIHJlZGVmaW5pdGlvbnMgb2Ygc3FydCBhbmQgb3RoZXIgbWV0aG9kc1xuICovXG5leHBvcnQgZnVuY3Rpb24gRmllbGQoT1JERVIsIGJpdExlbiwgaXNMRSA9IGZhbHNlLCByZWRlZiA9IHt9KSB7XG4gICAgaWYgKE9SREVSIDw9IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkOiBleHBlY3RlZCBPUkRFUiA+IDAsIGdvdCAnICsgT1JERVIpO1xuICAgIGNvbnN0IHsgbkJpdExlbmd0aDogQklUUywgbkJ5dGVMZW5ndGg6IEJZVEVTIH0gPSBuTGVuZ3RoKE9SREVSLCBiaXRMZW4pO1xuICAgIGlmIChCWVRFUyA+IDIwNDgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmaWVsZDogZXhwZWN0ZWQgT1JERVIgb2YgPD0gMjA0OCBieXRlcycpO1xuICAgIGxldCBzcXJ0UDsgLy8gY2FjaGVkIHNxcnRQXG4gICAgY29uc3QgZiA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBPUkRFUixcbiAgICAgICAgaXNMRSxcbiAgICAgICAgQklUUyxcbiAgICAgICAgQllURVMsXG4gICAgICAgIE1BU0s6IGJpdE1hc2soQklUUyksXG4gICAgICAgIFpFUk86IF8wbixcbiAgICAgICAgT05FOiBfMW4sXG4gICAgICAgIGNyZWF0ZTogKG51bSkgPT4gbW9kKG51bSwgT1JERVIpLFxuICAgICAgICBpc1ZhbGlkOiAobnVtKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZpZWxkIGVsZW1lbnQ6IGV4cGVjdGVkIGJpZ2ludCwgZ290ICcgKyB0eXBlb2YgbnVtKTtcbiAgICAgICAgICAgIHJldHVybiBfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSOyAvLyAwIGlzIHZhbGlkIGVsZW1lbnQsIGJ1dCBpdCdzIG5vdCBpbnZlcnRpYmxlXG4gICAgICAgIH0sXG4gICAgICAgIGlzMDogKG51bSkgPT4gbnVtID09PSBfMG4sXG4gICAgICAgIGlzT2RkOiAobnVtKSA9PiAobnVtICYgXzFuKSA9PT0gXzFuLFxuICAgICAgICBuZWc6IChudW0pID0+IG1vZCgtbnVtLCBPUkRFUiksXG4gICAgICAgIGVxbDogKGxocywgcmhzKSA9PiBsaHMgPT09IHJocyxcbiAgICAgICAgc3FyOiAobnVtKSA9PiBtb2QobnVtICogbnVtLCBPUkRFUiksXG4gICAgICAgIGFkZDogKGxocywgcmhzKSA9PiBtb2QobGhzICsgcmhzLCBPUkRFUiksXG4gICAgICAgIHN1YjogKGxocywgcmhzKSA9PiBtb2QobGhzIC0gcmhzLCBPUkRFUiksXG4gICAgICAgIG11bDogKGxocywgcmhzKSA9PiBtb2QobGhzICogcmhzLCBPUkRFUiksXG4gICAgICAgIHBvdzogKG51bSwgcG93ZXIpID0+IEZwUG93KGYsIG51bSwgcG93ZXIpLFxuICAgICAgICBkaXY6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIGludmVydChyaHMsIE9SREVSKSwgT1JERVIpLFxuICAgICAgICAvLyBTYW1lIGFzIGFib3ZlLCBidXQgZG9lc24ndCBub3JtYWxpemVcbiAgICAgICAgc3FyTjogKG51bSkgPT4gbnVtICogbnVtLFxuICAgICAgICBhZGROOiAobGhzLCByaHMpID0+IGxocyArIHJocyxcbiAgICAgICAgc3ViTjogKGxocywgcmhzKSA9PiBsaHMgLSByaHMsXG4gICAgICAgIG11bE46IChsaHMsIHJocykgPT4gbGhzICogcmhzLFxuICAgICAgICBpbnY6IChudW0pID0+IGludmVydChudW0sIE9SREVSKSxcbiAgICAgICAgc3FydDogcmVkZWYuc3FydCB8fFxuICAgICAgICAgICAgKChuKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzcXJ0UClcbiAgICAgICAgICAgICAgICAgICAgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcXJ0UChmLCBuKTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNvbnN0LXRpbWUgYmlnaW50cyBhbnl3YXksIHNvIHByb2JhYmx5IHdpbGwgYmUgbm90IHZlcnkgdXNlZnVsXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZC5mcm9tQnl0ZXM6IGV4cGVjdGVkICcgKyBCWVRFUyArICcgYnl0ZXMsIGdvdCAnICsgYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRcIik7XG4gICAgY29uc3Qgcm9vdCA9IEZwLnNxcnQoZWxtKTtcbiAgICByZXR1cm4gRnAuaXNPZGQocm9vdCkgPyByb290IDogRnAubmVnKHJvb3QpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydEV2ZW4oRnAsIGVsbSkge1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZFwiKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIFNhbWUgYXMgbWFwS2V5VG9GaWVsZCwgYnV0IGFjY2VwdHMgbGVzcyBieXRlcyAoNDAgaW5zdGVhZCBvZiA0OCBmb3IgMzItYnl0ZSBmaWVsZCkuXG4gKiBXaGljaCBtYWtlcyBpdCBzbGlnaHRseSBtb3JlIGJpYXNlZCwgbGVzcyBzZWN1cmUuXG4gKiBAZGVwcmVjYXRlZCB1c2UgYG1hcEtleVRvRmllbGRgIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAnICsgbWluTGVuICsgJy0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJyArIGhhc2hMZW4pO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRvdGFsIG51bWJlciBvZiBieXRlcyBjb25zdW1lZCBieSB0aGUgZmllbGQgZWxlbWVudC5cbiAqIEZvciBleGFtcGxlLCAzMiBieXRlcyBmb3IgdXN1YWwgMjU2LWJpdCB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIEBwYXJhbSBmaWVsZE9yZGVyIG51bWJlciBvZiBmaWVsZCBlbGVtZW50cywgdXN1YWxseSBDVVJWRS5uXG4gKiBAcmV0dXJucyBieXRlIGxlbmd0aCBvZiBmaWVsZFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBmaWVsZE9yZGVyICE9PSAnYmlnaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZCBvcmRlciBtdXN0IGJlIGJpZ2ludCcpO1xuICAgIGNvbnN0IGJpdExlbmd0aCA9IGZpZWxkT3JkZXIudG9TdHJpbmcoMikubGVuZ3RoO1xuICAgIHJldHVybiBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gOCk7XG59XG4vKipcbiAqIFJldHVybnMgbWluaW1hbCBhbW91bnQgb2YgYnl0ZXMgdGhhdCBjYW4gYmUgc2FmZWx5IHJlZHVjZWRcbiAqIGJ5IGZpZWxkIG9yZGVyLlxuICogU2hvdWxkIGJlIDJeLTEyOCBmb3IgMTI4LWJpdCBjdXJ2ZSBzdWNoIGFzIFAyNTYuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgdGFyZ2V0IGhhc2hcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGNvbnN0IGxlbmd0aCA9IGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgcmV0dXJuIGxlbmd0aCArIE1hdGguY2VpbChsZW5ndGggLyAyKTtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogQ2FuIHRha2UgKG4gKyBuLzIpIG9yIG1vcmUgYnl0ZXMgb2YgdW5pZm9ybSBpbnB1dCBlLmcuIGZyb20gQ1NQUk5HIG9yIEtERlxuICogYW5kIGNvbnZlcnQgdGhlbSBpbnRvIHByaXZhdGUgc2NhbGFyLCB3aXRoIHRoZSBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICogTmVlZHMgYXQgbGVhc3QgNDggYnl0ZXMgb2YgaW5wdXQgZm9yIDMyLWJ5dGUgcHJpdmF0ZSBrZXkuXG4gKiBodHRwczovL3Jlc2VhcmNoLmt1ZGVsc2tpc2VjdXJpdHkuY29tLzIwMjAvMDcvMjgvdGhlLWRlZmluaXRpdmUtZ3VpZGUtdG8tbW9kdWxvLWJpYXMtYW5kLWhvdy10by1hdm9pZC1pdC9cbiAqIEZJUFMgMTg2LTUsIEEuMiBodHRwczovL2NzcmMubmlzdC5nb3YvcHVibGljYXRpb25zL2RldGFpbC9maXBzLzE4Ni81L2ZpbmFsXG4gKiBSRkMgOTM4MCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01XG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gc2VjcDI1NmsxLkNVUlZFLm4pXG4gKiBAcGFyYW0gaXNMRSBpbnRlcnByZXQgaGFzaCBieXRlcyBhcyBMRSBudW1cbiAqIEByZXR1cm5zIHZhbGlkIHByaXZhdGUgc2NhbGFyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBIYXNoVG9GaWVsZChrZXksIGZpZWxkT3JkZXIsIGlzTEUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxlbiA9IGtleS5sZW5ndGg7XG4gICAgY29uc3QgZmllbGRMZW4gPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIGNvbnN0IG1pbkxlbiA9IGdldE1pbkhhc2hMZW5ndGgoZmllbGRPcmRlcik7XG4gICAgLy8gTm8gc21hbGwgbnVtYmVyczogbmVlZCB0byB1bmRlcnN0YW5kIGJpYXMgc3RvcnkuIE5vIGh1Z2UgbnVtYmVyczogZWFzaWVyIHRvIGRldGVjdCBKUyB0aW1pbmdzLlxuICAgIGlmIChsZW4gPCAxNiB8fCBsZW4gPCBtaW5MZW4gfHwgbGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBlY3RlZCAnICsgbWluTGVuICsgJy0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJyArIGxlbik7XG4gICAgY29uc3QgbnVtID0gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShrZXkpIDogYnl0ZXNUb051bWJlckJFKGtleSk7XG4gICAgLy8gYG1vZCh4LCAxMSlgIGNhbiBzb21ldGltZXMgcHJvZHVjZSAwLiBgbW9kKHgsIDEwKSArIDFgIGlzIHRoZSBzYW1lLCBidXQgbm8gMFxuICAgIGNvbnN0IHJlZHVjZWQgPSBtb2QobnVtLCBmaWVsZE9yZGVyIC0gXzFuKSArIF8xbjtcbiAgICByZXR1cm4gaXNMRSA/IG51bWJlclRvQnl0ZXNMRShyZWR1Y2VkLCBmaWVsZExlbikgOiBudW1iZXJUb0J5dGVzQkUocmVkdWNlZCwgZmllbGRMZW4pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: () => (/* binding */ DER),\n/* harmony export */   DERErr: () => (/* binding */ DERErr),\n/* harmony export */   SWUFpSqrtRatio: () => (/* binding */ SWUFpSqrtRatio),\n/* harmony export */   mapToCurveSimpleSWU: () => (/* binding */ mapToCurveSimpleSWU),\n/* harmony export */   weierstrass: () => (/* binding */ weierstrass),\n/* harmony export */   weierstrassPoints: () => (/* binding */ weierstrassPoints)\n/* harmony export */ });\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/**\n * Short Weierstrass curve methods. The formula is: y² = x³ + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\nfunction validateSigVerOpts(opts) {\n    if (opts.lowS !== undefined)\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('lowS', opts.lowS);\n    if (opts.prehash !== undefined)\n        (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('prehash', opts.prehash);\n}\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_0__;\nclass DERErr extends Error {\n    constructor(m = '') {\n        super(m);\n    }\n}\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n        encode: (tag, data) => {\n            const { Err: E } = DER;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length & 1)\n                throw new E('tlv.encode: unpadded data');\n            const dataLen = data.length / 2;\n            const len = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(dataLen);\n            if ((len.length / 2) & 128)\n                throw new E('tlv.encode: long form length too big');\n            // length of length with long form flag\n            const lenLen = dataLen > 127 ? _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded((len.length / 2) | 128) : '';\n            const t = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(tag);\n            return t + lenLen + len + data;\n        },\n        // v - value, l - left bytes (unparsed)\n        decode(tag, data) {\n            const { Err: E } = DER;\n            let pos = 0;\n            if (tag < 0 || tag > 256)\n                throw new E('tlv.encode: wrong tag');\n            if (data.length < 2 || data[pos++] !== tag)\n                throw new E('tlv.decode: wrong tlv');\n            const first = data[pos++];\n            const isLong = !!(first & 128); // First bit of first length byte is flag for short/long form\n            let length = 0;\n            if (!isLong)\n                length = first;\n            else {\n                // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n                const lenLen = first & 127;\n                if (!lenLen)\n                    throw new E('tlv.decode(long): indefinite length not supported');\n                if (lenLen > 4)\n                    throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n                const lengthBytes = data.subarray(pos, pos + lenLen);\n                if (lengthBytes.length !== lenLen)\n                    throw new E('tlv.decode: length bytes not complete');\n                if (lengthBytes[0] === 0)\n                    throw new E('tlv.decode(long): zero leftmost byte');\n                for (const b of lengthBytes)\n                    length = (length << 8) | b;\n                pos += lenLen;\n                if (length < 128)\n                    throw new E('tlv.decode(long): not minimal encoding');\n            }\n            const v = data.subarray(pos, pos + length);\n            if (v.length !== length)\n                throw new E('tlv.decode: wrong value length');\n            return { v, l: data.subarray(pos + length) };\n        },\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n        encode(num) {\n            const { Err: E } = DER;\n            if (num < _0n)\n                throw new E('integer: negative integers are not allowed');\n            let hex = _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToHexUnpadded(num);\n            // Pad with zero byte if negative flag is present\n            if (Number.parseInt(hex[0], 16) & 0b1000)\n                hex = '00' + hex;\n            if (hex.length & 1)\n                throw new E('unexpected DER parsing assertion: unpadded hex');\n            return hex;\n        },\n        decode(data) {\n            const { Err: E } = DER;\n            if (data[0] & 128)\n                throw new E('invalid signature integer: negative');\n            if (data[0] === 0x00 && !(data[1] & 128))\n                throw new E('invalid signature integer: unnecessary leading zero');\n            return b2n(data);\n        },\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E, _int: int, _tlv: tlv } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes(data);\n        const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n        if (seqLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n        const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n        if (sLeftBytes.length)\n            throw new E('invalid signature: left bytes after parsing');\n        return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n        const { _tlv: tlv, _int: int } = DER;\n        const rs = tlv.encode(0x02, int.encode(sig.r));\n        const ss = tlv.encode(0x02, int.encode(sig.s));\n        const seq = rs + ss;\n        return tlv.encode(0x30, seq);\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const Fn = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.Field)(CURVE.n, CURVE.nBitLength);\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange(num, _1n, CURVE.n);\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(key))\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('invalid private key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error('invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key);\n        }\n        if (wrapPrivateKey)\n            num = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(num, N); // disabled by default, enabled for BLS\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('private key', num, _1n, N); // num in range [1..N-1]\n        return num;\n    }\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    // Memoized toAffine / validity check. They are heavy. Points are immutable.\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z) ∋ (x=x/z, y=y/z)\n    const toAffineMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p, iz) => {\n        const { px: x, py: y, pz: z } = p;\n        // Fast-path for normalized points\n        if (Fp.eql(z, Fp.ONE))\n            return { x, y };\n        const is0 = p.is0();\n        // If invZ was 0, we return zero point. However we still want to execute\n        // all operations, so we replace invZ with a random number, 1.\n        if (iz == null)\n            iz = is0 ? Fp.ONE : Fp.inv(z);\n        const ax = Fp.mul(x, iz);\n        const ay = Fp.mul(y, iz);\n        const zz = Fp.mul(z, iz);\n        if (is0)\n            return { x: Fp.ZERO, y: Fp.ZERO };\n        if (!Fp.eql(zz, Fp.ONE))\n            throw new Error('invZ was invalid');\n        return { x: ax, y: ay };\n    });\n    // NOTE: on exception this will crash 'cached' and no value will be set.\n    // Otherwise true will be return\n    const assertValidMemo = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.memoized)((p) => {\n        if (p.is0()) {\n            // (0, 1, 0) aka ZERO is invalid in most contexts.\n            // In BLS, ZERO can be serialized, so we allow it.\n            // (0, 0, 0) is invalid representation of ZERO.\n            if (CURVE.allowInfinityPoint && !Fp.is0(p.py))\n                return;\n            throw new Error('bad point: ZERO');\n        }\n        // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n        const { x, y } = p.toAffine();\n        // Check if x, y are valid field elements\n        if (!Fp.isValid(x) || !Fp.isValid(y))\n            throw new Error('bad point: x or y not FE');\n        const left = Fp.sqr(y); // y²\n        const right = weierstrassEquation(x); // x³ + ax + b\n        if (!Fp.eql(left, right))\n            throw new Error('bad point: equation left != right');\n        if (!p.isTorsionFree())\n            throw new Error('bad point: not in prime-order subgroup');\n        return true;\n    });\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n            Object.freeze(this);\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // Multiscalar Multiplication\n        static msm(points, scalars) {\n            return (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.pippenger)(Point, Fn, points, scalars);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            wnaf.setWindowSize(this, windowSize);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            assertValidMemo(this);\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, n, Point.normalizeZ);\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(sc) {\n            const { endo, n: N } = CURVE;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('scalar', sc, _0n, N);\n            const I = Point.ZERO;\n            if (sc === _0n)\n                return I;\n            if (this.is0() || sc === _1n)\n                return this;\n            // Case a: no endomorphism. Case b: has precomputes.\n            if (!endo || wnaf.hasPrecomputes(this))\n                return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n            // Case c: endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            const { endo, n: N } = CURVE;\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('scalar', scalar, _1n, N);\n            let point, fake; // Fake point is used to const-time mult\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(scalar);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            return toAffineMemo(this, iz);\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_1__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.invert)(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes;\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abool)('isCompressed', isCompressed);\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(tail);\n                if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__.inRange(x, _1n, Fp.ORDER))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                const cl = compressedLen;\n                const ul = uncompressedLen;\n                throw new Error('invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]\n            _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_0__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength)(CURVE.n);\n            return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField)(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // Our custom check \"just in case\"\n            if (bytes.length > 8192)\n                throw new Error('input is too large');\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        _utils_js__WEBPACK_IMPORTED_MODULE_0__.aInRange('num < 2^' + CURVE.nBitLength, num, _0n, ORDER_MASK);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n    // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash);\n        validateSigVerOpts(opts);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_0__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('publicKey', publicKey);\n        const { lowS, prehash, format } = opts;\n        // Verify opts, deduce signature format\n        validateSigVerOpts(opts);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        if (format !== undefined && format !== 'compact' && format !== 'der')\n            throw new Error('format must be compact or der');\n        const isHex = typeof sg === 'string' || _utils_js__WEBPACK_IMPORTED_MODULE_0__.isBytes(sg);\n        const isObj = !isHex &&\n            !format &&\n            typeof sg === 'object' &&\n            sg !== null &&\n            typeof sg.r === 'bigint' &&\n            typeof sg.s === 'bigint';\n        if (!isHex && !isObj)\n            throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n        let _sig = undefined;\n        let P;\n        try {\n            if (isObj)\n                _sig = new Signature(sg.r, sg.s);\n            if (isHex) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    if (format !== 'compact')\n                        _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                }\n                if (!_sig && format !== 'der')\n                    _sig = Signature.fromCompact(sg);\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            return false;\n        }\n        if (!_sig)\n            return false;\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField)(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDNkQ7QUFDdUM7QUFDbkU7QUFDeUI7QUFDMUQ7QUFDQTtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBLFFBQVEsZ0RBQUs7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQSxRQUFRLHdDQUF3QyxFQUFFLHNDQUFFO0FBQzdDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMERBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywwREFBc0I7QUFDakUsc0JBQXNCLDBEQUFzQjtBQUM1QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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aWluYWRvaS9EZXNrdG9wL2dpdGh1YlByb2plY3QvdGhyaWR3ZWJ0dXRvcmlhbC9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBTaG9ydCBXZWllcnN0cmFzcyBjdXJ2ZSBtZXRob2RzLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiLlxuICpcbiAqICMjIyBEZXNpZ24gcmF0aW9uYWxlIGZvciB0eXBlc1xuICpcbiAqICogSW50ZXJhY3Rpb24gYmV0d2VlbiBjbGFzc2VzIGZyb20gZGlmZmVyZW50IGN1cnZlcyBzaG91bGQgZmFpbDpcbiAqICAgYGsyNTYuUG9pbnQuQkFTRS5hZGQocDI1Ni5Qb2ludC5CQVNFKWBcbiAqICogRm9yIHRoaXMgcHVycG9zZSB3ZSB3YW50IHRvIHVzZSBgaW5zdGFuY2VvZmAgb3BlcmF0b3IsIHdoaWNoIGlzIGZhc3QgYW5kIHdvcmtzIGR1cmluZyBydW50aW1lXG4gKiAqIERpZmZlcmVudCBjYWxscyBvZiBgY3VydmUoKWAgd291bGQgcmV0dXJuIGRpZmZlcmVudCBjbGFzc2VzIC1cbiAqICAgYGN1cnZlKHBhcmFtcykgIT09IGN1cnZlKHBhcmFtcylgOiBpZiBzb21lYm9keSBkZWNpZGVkIHRvIG1vbmtleS1wYXRjaCB0aGVpciBjdXJ2ZSxcbiAqICAgaXQgd29uJ3QgYWZmZWN0IG90aGVyc1xuICpcbiAqIFR5cGVTY3JpcHQgY2FuJ3QgaW5mZXIgdHlwZXMgZm9yIGNsYXNzZXMgY3JlYXRlZCBpbnNpZGUgYSBmdW5jdGlvbi4gQ2xhc3NlcyBpcyBvbmUgaW5zdGFuY2VcbiAqIG9mIG5vbWluYXRpdmUgdHlwZXMgaW4gVHlwZVNjcmlwdCBhbmQgaW50ZXJmYWNlcyBvbmx5IGNoZWNrIGZvciBzaGFwZSwgc28gaXQncyBoYXJkIHRvIGNyZWF0ZVxuICogdW5pcXVlIHR5cGUgZm9yIGV2ZXJ5IGZ1bmN0aW9uIGNhbGwuXG4gKlxuICogV2UgY2FuIHVzZSBnZW5lcmljIHR5cGVzIHZpYSBzb21lIHBhcmFtLCBsaWtlIGN1cnZlIG9wdHMsIGJ1dCB0aGF0IHdvdWxkOlxuICogICAgIDEuIEVuYWJsZSBpbnRlcmFjdGlvbiBiZXR3ZWVuIGBjdXJ2ZShwYXJhbXMpYCBhbmQgYGN1cnZlKHBhcmFtcylgIChjdXJ2ZXMgb2Ygc2FtZSBwYXJhbXMpXG4gKiAgICAgd2hpY2ggaXMgaGFyZCB0byBkZWJ1Zy5cbiAqICAgICAyLiBQYXJhbXMgY2FuIGJlIGdlbmVyaWMgYW5kIHdlIGNhbid0IGVuZm9yY2UgdGhlbSB0byBiZSBjb25zdGFudCB2YWx1ZTpcbiAqICAgICBpZiBzb21lYm9keSBjcmVhdGVzIGN1cnZlIGZyb20gbm9uLWNvbnN0YW50IHBhcmFtcyxcbiAqICAgICBpdCB3b3VsZCBiZSBhbGxvd2VkIHRvIGludGVyYWN0IHdpdGggb3RoZXIgY3VydmVzIHdpdGggbm9uLWNvbnN0YW50IHBhcmFtc1xuICpcbiAqIEB0b2RvIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL3JlbGVhc2Utbm90ZXMvdHlwZXNjcmlwdC0yLTcuaHRtbCN1bmlxdWUtc3ltYm9sXG4gKiBAbW9kdWxlXG4gKi9cbi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHBpcHBlbmdlciwgdmFsaWRhdGVCYXNpYywgd05BRiwgfSBmcm9tICcuL2N1cnZlLmpzJztcbmltcG9ydCB7IEZpZWxkLCBnZXRNaW5IYXNoTGVuZ3RoLCBpbnZlcnQsIG1hcEhhc2hUb0ZpZWxkLCBtb2QsIHZhbGlkYXRlRmllbGQsIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgYWJvb2wsIGVuc3VyZUJ5dGVzLCBtZW1vaXplZCB9IGZyb20gJy4vdXRpbHMuanMnO1xuZnVuY3Rpb24gdmFsaWRhdGVTaWdWZXJPcHRzKG9wdHMpIHtcbiAgICBpZiAob3B0cy5sb3dTICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFib29sKCdsb3dTJywgb3B0cy5sb3dTKTtcbiAgICBpZiAob3B0cy5wcmVoYXNoICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGFib29sKCdwcmVoYXNoJywgb3B0cy5wcmVoYXNoKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kb21vcnBoaXNtLCBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgZW5kb21vcnBoaXNtLCBleHBlY3RlZCBiZXRhOiBiaWdpbnQgYW5kIHNwbGl0U2NhbGFyOiBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbmNvbnN0IHsgYnl0ZXNUb051bWJlckJFOiBiMm4sIGhleFRvQnl0ZXM6IGgyYiB9ID0gdXQ7XG5leHBvcnQgY2xhc3MgREVSRXJyIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICBzdXBlcihtKTtcbiAgICB9XG59XG4vKipcbiAqIEFTTi4xIERFUiBlbmNvZGluZyB1dGlsaXRpZXMuIEFTTiBpcyB2ZXJ5IGNvbXBsZXggJiBmcmFnaWxlLiBGb3JtYXQ6XG4gKlxuICogICAgIFsweDMwIChTRVFVRU5DRSksIGJ5dGVsZW5ndGgsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFIsIDB4MDIgKElOVEVHRVIpLCBpbnRMZW5ndGgsIFNdXG4gKlxuICogRG9jczogaHR0cHM6Ly9sZXRzZW5jcnlwdC5vcmcvZG9jcy9hLXdhcm0td2VsY29tZS10by1hc24xLWFuZC1kZXIvLCBodHRwczovL2x1Y2EubnRvcC5vcmcvVGVhY2hpbmcvQXBwdW50aS9hc24xLmh0bWxcbiAqL1xuZXhwb3J0IGNvbnN0IERFUiA9IHtcbiAgICAvLyBhc24uMSBERVIgZW5jb2RpbmcgdXRpbHNcbiAgICBFcnI6IERFUkVycixcbiAgICAvLyBCYXNpYyBidWlsZGluZyBibG9jayBpcyBUTFYgKFRhZy1MZW5ndGgtVmFsdWUpXG4gICAgX3Rsdjoge1xuICAgICAgICBlbmNvZGU6ICh0YWcsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBpZiAodGFnIDwgMCB8fCB0YWcgPiAyNTYpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5lbmNvZGU6IHdyb25nIHRhZycpO1xuICAgICAgICAgICAgaWYgKGRhdGEubGVuZ3RoICYgMSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogdW5wYWRkZWQgZGF0YScpO1xuICAgICAgICAgICAgY29uc3QgZGF0YUxlbiA9IGRhdGEubGVuZ3RoIC8gMjtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IHV0Lm51bWJlclRvSGV4VW5wYWRkZWQoZGF0YUxlbik7XG4gICAgICAgICAgICBpZiAoKGxlbi5sZW5ndGggLyAyKSAmIDEyOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmVuY29kZTogbG9uZyBmb3JtIGxlbmd0aCB0b28gYmlnJyk7XG4gICAgICAgICAgICAvLyBsZW5ndGggb2YgbGVuZ3RoIHdpdGggbG9uZyBmb3JtIGZsYWdcbiAgICAgICAgICAgIGNvbnN0IGxlbkxlbiA9IGRhdGFMZW4gPiAxMjcgPyB1dC5udW1iZXJUb0hleFVucGFkZGVkKChsZW4ubGVuZ3RoIC8gMikgfCAxMjgpIDogJyc7XG4gICAgICAgICAgICBjb25zdCB0ID0gdXQubnVtYmVyVG9IZXhVbnBhZGRlZCh0YWcpO1xuICAgICAgICAgICAgcmV0dXJuIHQgKyBsZW5MZW4gKyBsZW4gKyBkYXRhO1xuICAgICAgICB9LFxuICAgICAgICAvLyB2IC0gdmFsdWUsIGwgLSBsZWZ0IGJ5dGVzICh1bnBhcnNlZClcbiAgICAgICAgZGVjb2RlKHRhZywgZGF0YSkge1xuICAgICAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICAgICAgaWYgKHRhZyA8IDAgfHwgdGFnID4gMjU2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZW5jb2RlOiB3cm9uZyB0YWcnKTtcbiAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVtwb3MrK10gIT09IHRhZylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogd3JvbmcgdGx2Jyk7XG4gICAgICAgICAgICBjb25zdCBmaXJzdCA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgY29uc3QgaXNMb25nID0gISEoZmlyc3QgJiAxMjgpOyAvLyBGaXJzdCBiaXQgb2YgZmlyc3QgbGVuZ3RoIGJ5dGUgaXMgZmxhZyBmb3Igc2hvcnQvbG9uZyBmb3JtXG4gICAgICAgICAgICBsZXQgbGVuZ3RoID0gMDtcbiAgICAgICAgICAgIGlmICghaXNMb25nKVxuICAgICAgICAgICAgICAgIGxlbmd0aCA9IGZpcnN0O1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTG9uZyBmb3JtOiBbbG9uZ0ZsYWcoMWJpdCksIGxlbmd0aExlbmd0aCg3Yml0KSwgbGVuZ3RoIChCRSldXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuTGVuID0gZmlyc3QgJiAxMjc7XG4gICAgICAgICAgICAgICAgaWYgKCFsZW5MZW4pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBpbmRlZmluaXRlIGxlbmd0aCBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxlbkxlbiA+IDQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiBieXRlIGxlbmd0aCBpcyB0b28gYmlnJyk7IC8vIHRoaXMgd2lsbCBvdmVyZmxvdyB1MzIgaW4ganNcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGhCeXRlcyA9IGRhdGEuc3ViYXJyYXkocG9zLCBwb3MgKyBsZW5MZW4pO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGhCeXRlcy5sZW5ndGggIT09IGxlbkxlbilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGU6IGxlbmd0aCBieXRlcyBub3QgY29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoQnl0ZXNbMF0gPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCd0bHYuZGVjb2RlKGxvbmcpOiB6ZXJvIGxlZnRtb3N0IGJ5dGUnKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGIgb2YgbGVuZ3RoQnl0ZXMpXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IChsZW5ndGggPDwgOCkgfCBiO1xuICAgICAgICAgICAgICAgIHBvcyArPSBsZW5MZW47XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA8IDEyOClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3Rsdi5kZWNvZGUobG9uZyk6IG5vdCBtaW5pbWFsIGVuY29kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2ID0gZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIGxlbmd0aCk7XG4gICAgICAgICAgICBpZiAodi5sZW5ndGggIT09IGxlbmd0aClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRSgndGx2LmRlY29kZTogd3JvbmcgdmFsdWUgbGVuZ3RoJyk7XG4gICAgICAgICAgICByZXR1cm4geyB2LCBsOiBkYXRhLnN1YmFycmF5KHBvcyArIGxlbmd0aCkgfTtcbiAgICAgICAgfSxcbiAgICB9LFxuICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgIC8vIHNpbmNlIHdlIGFsd2F5cyB1c2UgcG9zaXRpdmUgaW50ZWdlcnMgaGVyZS4gSXQgbXVzdCBhbHdheXMgYmUgZW1wdHk6XG4gICAgLy8gLSBhZGQgemVybyBieXRlIGlmIGV4aXN0c1xuICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICBfaW50OiB7XG4gICAgICAgIGVuY29kZShudW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgICAgICBpZiAobnVtIDwgXzBuKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnRlZ2VyOiBuZWdhdGl2ZSBpbnRlZ2VycyBhcmUgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGxldCBoZXggPSB1dC5udW1iZXJUb0hleFVucGFkZGVkKG51bSk7XG4gICAgICAgICAgICAvLyBQYWQgd2l0aCB6ZXJvIGJ5dGUgaWYgbmVnYXRpdmUgZmxhZyBpcyBwcmVzZW50XG4gICAgICAgICAgICBpZiAoTnVtYmVyLnBhcnNlSW50KGhleFswXSwgMTYpICYgMGIxMDAwKVxuICAgICAgICAgICAgICAgIGhleCA9ICcwMCcgKyBoZXg7XG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAmIDEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ3VuZXhwZWN0ZWQgREVSIHBhcnNpbmcgYXNzZXJ0aW9uOiB1bnBhZGRlZCBoZXgnKTtcbiAgICAgICAgICAgIHJldHVybiBoZXg7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB7IEVycjogRSB9ID0gREVSO1xuICAgICAgICAgICAgaWYgKGRhdGFbMF0gJiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ2ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IG5lZ2F0aXZlJyk7XG4gICAgICAgICAgICBpZiAoZGF0YVswXSA9PT0gMHgwMCAmJiAhKGRhdGFbMV0gJiAxMjgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyOiB1bm5lY2Vzc2FyeSBsZWFkaW5nIHplcm8nKTtcbiAgICAgICAgICAgIHJldHVybiBiMm4oZGF0YSk7XG4gICAgICAgIH0sXG4gICAgfSxcbiAgICB0b1NpZyhoZXgpIHtcbiAgICAgICAgLy8gcGFyc2UgREVSIHNpZ25hdHVyZVxuICAgICAgICBjb25zdCB7IEVycjogRSwgX2ludDogaW50LCBfdGx2OiB0bHYgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIHV0LmFieXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgeyB2OiBzZXFCeXRlcywgbDogc2VxTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MzAsIGRhdGEpO1xuICAgICAgICBpZiAoc2VxTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIGNvbnN0IHsgdjogckJ5dGVzLCBsOiByTGVmdEJ5dGVzIH0gPSB0bHYuZGVjb2RlKDB4MDIsIHNlcUJ5dGVzKTtcbiAgICAgICAgY29uc3QgeyB2OiBzQnl0ZXMsIGw6IHNMZWZ0Qnl0ZXMgfSA9IHRsdi5kZWNvZGUoMHgwMiwgckxlZnRCeXRlcyk7XG4gICAgICAgIGlmIChzTGVmdEJ5dGVzLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdpbnZhbGlkIHNpZ25hdHVyZTogbGVmdCBieXRlcyBhZnRlciBwYXJzaW5nJyk7XG4gICAgICAgIHJldHVybiB7IHI6IGludC5kZWNvZGUockJ5dGVzKSwgczogaW50LmRlY29kZShzQnl0ZXMpIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICBjb25zdCB7IF90bHY6IHRsdiwgX2ludDogaW50IH0gPSBERVI7XG4gICAgICAgIGNvbnN0IHJzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNzID0gdGx2LmVuY29kZSgweDAyLCBpbnQuZW5jb2RlKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHNlcSA9IHJzICsgc3M7XG4gICAgICAgIHJldHVybiB0bHYuZW5jb2RlKDB4MzAsIHNlcSk7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IEZuID0gRmllbGQoQ1VSVkUubiwgQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgY29uc3QgdG9CeXRlcyA9IENVUlZFLnRvQnl0ZXMgfHxcbiAgICAgICAgKChfYywgcG9pbnQsIF9pc0NvbXByZXNzZWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHV0LmNvbmNhdEJ5dGVzKFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCBGcC50b0J5dGVzKGEueCksIEZwLnRvQnl0ZXMoYS55KSk7XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGZyb21CeXRlcyA9IENVUlZFLmZyb21CeXRlcyB8fFxuICAgICAgICAoKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICAvLyBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyBpZiAoaGVhZCAhPT0gMHgwNCkgdGhyb3cgbmV3IEVycm9yKCdPbmx5IG5vbi1jb21wcmVzc2VkIGVuY29kaW5nIGlzIHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICB9KTtcbiAgICAvKipcbiAgICAgKiB5wrIgPSB4wrMgKyBheCArIGI6IFNob3J0IHdlaWVyc3RyYXNzIGN1cnZlIGZvcm11bGFcbiAgICAgKiBAcmV0dXJucyB5wrJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpIHtcbiAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgY29uc3QgeDIgPSBGcC5zcXIoeCk7IC8vIHggKiB4XG4gICAgICAgIGNvbnN0IHgzID0gRnAubXVsKHgyLCB4KTsgLy8geDIgKiB4XG4gICAgICAgIHJldHVybiBGcC5hZGQoRnAuYWRkKHgzLCBGcC5tdWwoeCwgYSkpLCBiKTsgLy8geDMgKyBhICogeCArIGJcbiAgICB9XG4gICAgLy8gVmFsaWRhdGUgd2hldGhlciB0aGUgcGFzc2VkIGN1cnZlIHBhcmFtcyBhcmUgdmFsaWQuXG4gICAgLy8gV2UgY2hlY2sgaWYgY3VydmUgZXF1YXRpb24gd29ya3MgZm9yIGdlbmVyYXRvciBwb2ludC5cbiAgICAvLyBgYXNzZXJ0VmFsaWRpdHkoKWAgd29uJ3Qgd29yazogYGlzVG9yc2lvbkZyZWUoKWAgaXMgbm90IGF2YWlsYWJsZSBhdCB0aGlzIHBvaW50IGluIGJsczEyLTM4MS5cbiAgICAvLyBQcm9qZWN0aXZlUG9pbnQgY2xhc3MgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldC5cbiAgICBpZiAoIUZwLmVxbChGcC5zcXIoQ1VSVkUuR3kpLCB3ZWllcnN0cmFzc0VxdWF0aW9uKENVUlZFLkd4KSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGdlbmVyYXRvciBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgIC8vIFZhbGlkIGdyb3VwIGVsZW1lbnRzIHJlc2lkZSBpbiByYW5nZSAxLi5uLTFcbiAgICBmdW5jdGlvbiBpc1dpdGhpbkN1cnZlT3JkZXIobnVtKSB7XG4gICAgICAgIHJldHVybiB1dC5pblJhbmdlKG51bSwgXzFuLCBDVVJWRS5uKTtcbiAgICB9XG4gICAgLy8gVmFsaWRhdGVzIGlmIHByaXYga2V5IGlzIHZhbGlkIGFuZCBjb252ZXJ0cyBpdCB0byBiaWdpbnQuXG4gICAgLy8gU3VwcG9ydHMgb3B0aW9ucyBhbGxvd2VkUHJpdmF0ZUtleUxlbmd0aHMgYW5kIHdyYXBQcml2YXRlS2V5LlxuICAgIGZ1bmN0aW9uIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIoa2V5KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzOiBsZW5ndGhzLCBuQnl0ZUxlbmd0aCwgd3JhcFByaXZhdGVLZXksIG46IE4gfSA9IENVUlZFO1xuICAgICAgICBpZiAobGVuZ3RocyAmJiB0eXBlb2Yga2V5ICE9PSAnYmlnaW50Jykge1xuICAgICAgICAgICAgaWYgKHV0LmlzQnl0ZXMoa2V5KSlcbiAgICAgICAgICAgICAgICBrZXkgPSB1dC5ieXRlc1RvSGV4KGtleSk7XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgdG8gaGV4IHN0cmluZywgcGFkLiBFLmcuIFA1MjEgd291bGQgbm9ybSAxMzAtMTMyIGNoYXIgaGV4IHRvIDEzMi1jaGFyIGJ5dGVzXG4gICAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycgfHwgIWxlbmd0aHMuaW5jbHVkZXMoa2V5Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHByaXZhdGUga2V5Jyk7XG4gICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwcml2YXRlIGtleSwgZXhwZWN0ZWQgaGV4IG9yICcgKyBuQnl0ZUxlbmd0aCArICcgYnl0ZXMsIGdvdCAnICsgdHlwZW9mIGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdyYXBQcml2YXRlS2V5KVxuICAgICAgICAgICAgbnVtID0gbW9kKG51bSwgTik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xuICAgICAgICB1dC5hSW5SYW5nZSgncHJpdmF0ZSBrZXknLCBudW0sIF8xbiwgTik7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8vIE1lbW9pemVkIHRvQWZmaW5lIC8gdmFsaWRpdHkgY2hlY2suIFRoZXkgYXJlIGhlYXZ5LiBQb2ludHMgYXJlIGltbXV0YWJsZS5cbiAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgIGNvbnN0IHRvQWZmaW5lTWVtbyA9IG1lbW9pemVkKChwLCBpeikgPT4ge1xuICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHA7XG4gICAgICAgIC8vIEZhc3QtcGF0aCBmb3Igbm9ybWFsaXplZCBwb2ludHNcbiAgICAgICAgaWYgKEZwLmVxbCh6LCBGcC5PTkUpKVxuICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgICAgICBjb25zdCBpczAgPSBwLmlzMCgpO1xuICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgLy8gYWxsIG9wZXJhdGlvbnMsIHNvIHdlIHJlcGxhY2UgaW52WiB3aXRoIGEgcmFuZG9tIG51bWJlciwgMS5cbiAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgY29uc3QgYXggPSBGcC5tdWwoeCwgaXopO1xuICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgfSk7XG4gICAgLy8gTk9URTogb24gZXhjZXB0aW9uIHRoaXMgd2lsbCBjcmFzaCAnY2FjaGVkJyBhbmQgbm8gdmFsdWUgd2lsbCBiZSBzZXQuXG4gICAgLy8gT3RoZXJ3aXNlIHRydWUgd2lsbCBiZSByZXR1cm5cbiAgICBjb25zdCBhc3NlcnRWYWxpZE1lbW8gPSBtZW1vaXplZCgocCkgPT4ge1xuICAgICAgICBpZiAocC5pczAoKSkge1xuICAgICAgICAgICAgLy8gKDAsIDEsIDApIGFrYSBaRVJPIGlzIGludmFsaWQgaW4gbW9zdCBjb250ZXh0cy5cbiAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAvLyAoMCwgMCwgMCkgaXMgaW52YWxpZCByZXByZXNlbnRhdGlvbiBvZiBaRVJPLlxuICAgICAgICAgICAgaWYgKENVUlZFLmFsbG93SW5maW5pdHlQb2ludCAmJiAhRnAuaXMwKHAucHkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSAzcmQtcGFydHkgdGVzdCB2ZWN0b3JzIHJlcXVpcmUgZGlmZmVyZW50IHdvcmRpbmcgYmV0d2VlbiBoZXJlICYgYGZyb21Db21wcmVzc2VkSGV4YFxuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAudG9BZmZpbmUoKTtcbiAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgaWYgKCFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8geMKzICsgYXggKyBiXG4gICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgIGlmICghcC5pc1RvcnNpb25GcmVlKCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvZXMgbm90IHZhbGlkYXRlIGlmIHRoZSBwb2ludCBpcyBvbi1jdXJ2ZS5cbiAgICAgICAgLy8gVXNlIGZyb21IZXggaW5zdGVhZCwgb3IgY2FsbCBhc3NlcnRWYWxpZGl0eSgpIGxhdGVyLlxuICAgICAgICBzdGF0aWMgZnJvbUFmZmluZShwKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIXAgfHwgIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFmZmluZSBwb2ludCcpO1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2plY3RpdmUgcG9pbnQgbm90IGFsbG93ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IChpKSA9PiBGcC5lcWwoaSwgRnAuWkVSTyk7XG4gICAgICAgICAgICAvLyBmcm9tQWZmaW5lKHg6MCwgeTowKSB3b3VsZCBwcm9kdWNlICh4OjAsIHk6MCwgejoxKSwgYnV0IHdlIG5lZWQgKHg6MCwgeToxLCB6OjApXG4gICAgICAgICAgICBpZiAoaXMwKHgpICYmIGlzMCh5KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgRnAuT05FKTtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgeSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvQWZmaW5lKCkueTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgYSBidW5jaCBvZiBQcm9qZWN0aXZlIFBvaW50cyBidXQgZXhlY3V0ZXMgb25seSBvbmVcbiAgICAgICAgICogaW52ZXJzaW9uIG9uIGFsbCBvZiB0aGVtLiBJbnZlcnNpb24gaXMgdmVyeSBzbG93IG9wZXJhdGlvbixcbiAgICAgICAgICogc28gdGhpcyBpbXByb3ZlcyBwZXJmb3JtYW5jZSBtYXNzaXZlbHkuXG4gICAgICAgICAqIE9wdGltaXphdGlvbjogY29udmVydHMgYSBsaXN0IG9mIHByb2plY3RpdmUgcG9pbnRzIHRvIGEgbGlzdCBvZiBpZGVudGljYWwgcG9pbnRzIHdpdGggWj0xLlxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAgKiBAcGFyYW0gaGV4IHNob3J0L2xvbmcgRUNEU0EgaGV4XG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKGZyb21CeXRlcyhlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgpKSk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIGdlbmVyYXRvciBwb2ludCBieSBwcml2YXRlS2V5LlxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50LkJBU0UubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlzY2FsYXIgTXVsdGlwbGljYXRpb25cbiAgICAgICAgc3RhdGljIG1zbShwb2ludHMsIHNjYWxhcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBwaXBwZW5nZXIoUG9pbnQsIEZuLCBwb2ludHMsIHNjYWxhcnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHduYWYuc2V0V2luZG93U2l6ZSh0aGlzLCB3aW5kb3dTaXplKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGFzc2VydFZhbGlkTWVtbyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBuLCBQb2ludC5ub3JtYWxpemVaKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUoc2MpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbywgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgnc2NhbGFyJywgc2MsIF8wbiwgTik7XG4gICAgICAgICAgICBjb25zdCBJID0gUG9pbnQuWkVSTztcbiAgICAgICAgICAgIGlmIChzYyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkgfHwgc2MgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIC8vIENhc2UgYTogbm8gZW5kb21vcnBoaXNtLiBDYXNlIGI6IGhhcyBwcmVjb21wdXRlcy5cbiAgICAgICAgICAgIGlmICghZW5kbyB8fCB3bmFmLmhhc1ByZWNvbXB1dGVzKHRoaXMpKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWRVbnNhZmUodGhpcywgc2MsIFBvaW50Lm5vcm1hbGl6ZVopO1xuICAgICAgICAgICAgLy8gQ2FzZSBjOiBlbmRvbW9ycGhpc21cbiAgICAgICAgICAgIGxldCB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH0gPSBlbmRvLnNwbGl0U2NhbGFyKHNjKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbywgbjogTiB9ID0gQ1VSVkU7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgnc2NhbGFyJywgc2NhbGFyLCBfMW4sIE4pO1xuICAgICAgICAgICAgbGV0IHBvaW50LCBmYWtlOyAvLyBGYWtlIHBvaW50IGlzIHVzZWQgdG8gY29uc3QtdGltZSBtdWx0XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihzY2FsYXIpO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gcDtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSBgemAgZm9yIGJvdGggcG9pbnRzLCBidXQgcmV0dXJuIG9ubHkgcmVhbCBvbmVcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwb2ludCwgZmFrZV0pWzBdO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFZmZpY2llbnRseSBjYWxjdWxhdGUgYGFQICsgYlFgLiBVbnNhZmUsIGNhbiBleHBvc2UgcHJpdmF0ZSBrZXksIGlmIHVzZWQgaW5jb3JyZWN0bHkuXG4gICAgICAgICAqIE5vdCB1c2luZyBTdHJhdXNzLVNoYW1pciB0cmljazogcHJlY29tcHV0YXRpb24gdGFibGVzIGFyZSBmYXN0ZXIuXG4gICAgICAgICAqIFRoZSB0cmljayBjb3VsZCBiZSB1c2VmdWwgaWYgYm90aCBQIGFuZCBRIGFyZSBub3QgRyAobm90IGluIG91ciBjYXNlKS5cbiAgICAgICAgICogQHJldHVybnMgbm9uLXplcm8gYWZmaW5lIHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseUFuZEFkZFVuc2FmZShRLCBhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCBHID0gUG9pbnQuQkFTRTsgLy8gTm8gU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHdlIGhhdmUgMTAlIGZhc3RlciBHIHByZWNvbXB1dGVzXG4gICAgICAgICAgICBjb25zdCBtdWwgPSAoUCwgYSAvLyBTZWxlY3QgZmFzdGVyIG11bHRpcGx5KCkgbWV0aG9kXG4gICAgICAgICAgICApID0+IChhID09PSBfMG4gfHwgYSA9PT0gXzFuIHx8ICFQLmVxdWFscyhHKSA/IFAubXVsdGlwbHlVbnNhZmUoYSkgOiBQLm11bHRpcGx5KGEpKTtcbiAgICAgICAgICAgIGNvbnN0IHN1bSA9IG11bCh0aGlzLCBhKS5hZGQobXVsKFEsIGIpKTtcbiAgICAgICAgICAgIHJldHVybiBzdW0uaXMwKCkgPyB1bmRlZmluZWQgOiBzdW07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29udmVydHMgUHJvamVjdGl2ZSBwb2ludCB0byBhZmZpbmUgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgLy8gKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAgICB0b0FmZmluZShpeikge1xuICAgICAgICAgICAgcmV0dXJuIHRvQWZmaW5lTWVtbyh0aGlzLCBpeik7XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgYWJvb2woJ2lzQ29tcHJlc3NlZCcsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgICAgICByZXR1cm4gdXQuYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIEZwLk9ORSk7XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChGcC5aRVJPLCBGcC5PTkUsIEZwLlpFUk8pO1xuICAgIGNvbnN0IF9iaXRzID0gQ1VSVkUubkJpdExlbmd0aDtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgQ1VSVkUuZW5kbyA/IE1hdGguY2VpbChfYml0cyAvIDIpIDogX2JpdHMpO1xuICAgIC8vIFZhbGlkYXRlIGlmIGdlbmVyYXRvciBwb2ludCBpcyBvbiBjdXJ2ZVxuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICB3ZWllcnN0cmFzc0VxdWF0aW9uLFxuICAgICAgICBpc1dpdGhpbkN1cnZlT3JkZXIsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChvcHRzLCB7XG4gICAgICAgIGhhc2g6ICdoYXNoJyxcbiAgICAgICAgaG1hYzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBiaXRzMmludDogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYml0czJpbnRfbW9kTjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbG93UzogJ2Jvb2xlYW4nLFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgbG93UzogdHJ1ZSwgLi4ub3B0cyB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBzaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBhbmQgRUNEU0Egc2lnbmF0dXJlIG1ldGhvZHMgZm9yIGl0LlxuICogQGV4YW1wbGVcbiAqIGltcG9ydCB7IEZpZWxkIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9hYnN0cmFjdC9tb2R1bGFyJztcbiAqIC8vIEJlZm9yZSB0aGF0LCBkZWZpbmUgQmlnSW50LXM6IGEsIGIsIHAsIG4sIEd4LCBHeVxuICogY29uc3QgY3VydmUgPSB3ZWllcnN0cmFzcyh7IGEsIGIsIEZwOiBGaWVsZChwKSwgbiwgR3gsIEd5LCBoOiAxbiB9KVxuICovXG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gaW52ZXJ0KGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgY29uc3QgeyBQcm9qZWN0aXZlUG9pbnQ6IFBvaW50LCBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLCB3ZWllcnN0cmFzc0VxdWF0aW9uLCBpc1dpdGhpbkN1cnZlT3JkZXIsIH0gPSB3ZWllcnN0cmFzc1BvaW50cyh7XG4gICAgICAgIC4uLkNVUlZFLFxuICAgICAgICB0b0J5dGVzKF9jLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcbiAgICAgICAgICAgIGFib29sKCdpc0NvbXByZXNzZWQnLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIXV0LmluUmFuZ2UoeCwgXzFuLCBGcC5PUkRFUikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbCA9IGNvbXByZXNzZWRMZW47XG4gICAgICAgICAgICAgICAgY29uc3QgdWwgPSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIFBvaW50LCBleHBlY3RlZCBsZW5ndGggb2YgJyArIGNsICsgJywgb3IgdW5jb21wcmVzc2VkICcgKyB1bCArICcsIGdvdCAnICsgbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bSkgPT4gdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoZW5zdXJlQnl0ZXMoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgncicsIHRoaXMuciwgXzFuLCBDVVJWRV9PUkRFUik7IC8vIHIgaW4gWzEuLk5dXG4gICAgICAgICAgICB1dC5hSW5SYW5nZSgncycsIHRoaXMucywgXzFuLCBDVVJWRV9PUkRFUik7IC8vIHMgaW4gWzEuLk5dXG4gICAgICAgIH1cbiAgICAgICAgYWRkUmVjb3ZlcnlCaXQocmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHRoaXMuciwgdGhpcy5zLCByZWNvdmVyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVjb3ZlclB1YmxpY0tleShtc2dIYXNoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIsIHMsIHJlY292ZXJ5OiByZWMgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpKTsgLy8gVHJ1bmNhdGUgaGFzaFxuICAgICAgICAgICAgaWYgKHJlYyA9PSBudWxsIHx8ICFbMCwgMSwgMiwgM10uaW5jbHVkZXMocmVjKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHJhZGogPSByZWMgPT09IDIgfHwgcmVjID09PSAzID8gciArIENVUlZFLm4gOiByO1xuICAgICAgICAgICAgaWYgKHJhZGogPj0gRnAuT1JERVIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCAyIG9yIDMgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4ID0gKHJlYyAmIDEpID09PSAwID8gJzAyJyA6ICcwMyc7XG4gICAgICAgICAgICBjb25zdCBSID0gUG9pbnQuZnJvbUhleChwcmVmaXggKyBudW1Ub05CeXRlU3RyKHJhZGopKTtcbiAgICAgICAgICAgIGNvbnN0IGlyID0gaW52TihyYWRqKTsgLy8gcl4tMVxuICAgICAgICAgICAgY29uc3QgdTEgPSBtb2ROKC1oICogaXIpOyAvLyAtaHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUyID0gbW9kTihzICogaXIpOyAvLyBzcl4tMVxuICAgICAgICAgICAgY29uc3QgUSA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUiwgdTEsIHUyKTsgLy8gKHNyXi0xKVItKGhyXi0xKUcgPSAtKGhyXi0xKUcgKyAoc3JeLTEpXG4gICAgICAgICAgICBpZiAoIVEpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwb2ludCBhdCBpbmZpbmlmeScpOyAvLyB1bnNhZmUgaXMgZmluZTogbm8gcHJpdiBkYXRhIGxlYWtlZFxuICAgICAgICAgICAgUS5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzaG91bGQgYmUgbG93LXMsIHRvIHByZXZlbnQgbWFsbGVhYmlsaXR5LlxuICAgICAgICBoYXNIaWdoUygpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgICAgICBub3JtYWxpemVTKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzSGlnaFMoKSA/IG5ldyBTaWduYXR1cmUodGhpcy5yLCBtb2ROKC10aGlzLnMpLCB0aGlzLnJlY292ZXJ5KSA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gREVSLWVuY29kZWRcbiAgICAgICAgdG9ERVJSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9ERVJIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9ERVJIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gREVSLmhleEZyb21TaWcoeyByOiB0aGlzLnIsIHM6IHRoaXMucyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBwYWRkZWQgYnl0ZXMgb2YgciwgdGhlbiBwYWRkZWQgYnl0ZXMgb2Ygc1xuICAgICAgICB0b0NvbXBhY3RSYXdCeXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5oZXhUb0J5dGVzKHRoaXMudG9Db21wYWN0SGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvQ29tcGFjdEhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBudW1Ub05CeXRlU3RyKHRoaXMucikgKyBudW1Ub05CeXRlU3RyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdXRpbHMgPSB7XG4gICAgICAgIGlzVmFsaWRQcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcjogbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb2R1Y2VzIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSBwcml2YXRlIGtleSBmcm9tIHJhbmRvbSBvZiBzaXplXG4gICAgICAgICAqIChncm91cExlbiArIGNlaWwoZ3JvdXBMZW4gLyAyKSkgd2l0aCBtb2R1bG8gYmlhcyBiZWluZyBuZWdsaWdpYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmFuZG9tUHJpdmF0ZUtleTogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtYXBIYXNoVG9GaWVsZChDVVJWRS5yYW5kb21CeXRlcyhsZW5ndGgpLCBDVVJWRS5uKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgcHJlY29tcHV0ZSB0YWJsZSBmb3IgYW4gYXJiaXRyYXJ5IEVDIHBvaW50LiBNYWtlcyBwb2ludCBcImNhY2hlZFwiLlxuICAgICAgICAgKiBBbGxvd3MgdG8gbWFzc2l2ZWx5IHNwZWVkLXVwIGBwb2ludC5tdWx0aXBseShzY2FsYXIpYC5cbiAgICAgICAgICogQHJldHVybnMgY2FjaGVkIHBvaW50XG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIGNvbnN0IGZhc3QgPSB1dGlscy5wcmVjb21wdXRlKDgsIFByb2plY3RpdmVQb2ludC5mcm9tSGV4KHNvbWVvbmVzUHViS2V5KSk7XG4gICAgICAgICAqIGZhc3QubXVsdGlwbHkocHJpdktleSk7IC8vIG11Y2ggZmFzdGVyIEVDREggbm93XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTsgLy8gMyBpcyBhcmJpdHJhcnksIGp1c3QgbmVlZCBhbnkgbnVtYmVyIGhlcmVcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHB1YmxpYyBrZXkgZm9yIGEgcHJpdmF0ZSBrZXkuIENoZWNrcyBmb3IgdmFsaWRpdHkgb2YgdGhlIHByaXZhdGUga2V5LlxuICAgICAqIEBwYXJhbSBwcml2YXRlS2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBQdWJsaWMga2V5LCBmdWxsIHdoZW4gaXNDb21wcmVzc2VkPWZhbHNlOyBzaG9ydCB3aGVuIGlzQ29tcHJlc3NlZD10cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZhdGVLZXksIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIFBvaW50LmZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUXVpY2sgYW5kIGRpcnR5IGNoZWNrIGZvciBpdGVtIGJlaW5nIHB1YmxpYyBrZXkuIERvZXMgbm90IHZhbGlkYXRlIGhleCwgb3IgYmVpbmcgb24tY3VydmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQcm9iUHViKGl0ZW0pIHtcbiAgICAgICAgY29uc3QgYXJyID0gdXQuaXNCeXRlcyhpdGVtKTtcbiAgICAgICAgY29uc3Qgc3RyID0gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuICAgICAgICBjb25zdCBsZW4gPSAoYXJyIHx8IHN0cikgJiYgaXRlbS5sZW5ndGg7XG4gICAgICAgIGlmIChhcnIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoc3RyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gMiAqIGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSAyICogdW5jb21wcmVzc2VkTGVuO1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRUNESCAoRWxsaXB0aWMgQ3VydmUgRGlmZmllIEhlbGxtYW4pLlxuICAgICAqIENvbXB1dGVzIHNoYXJlZCBwdWJsaWMga2V5IGZyb20gcHJpdmF0ZSBrZXkgYW5kIHB1YmxpYyBrZXkuXG4gICAgICogQ2hlY2tzOiAxKSBwcml2YXRlIGtleSB2YWxpZGl0eSAyKSBzaGFyZWQga2V5IGlzIG9uLWN1cnZlLlxuICAgICAqIERvZXMgTk9UIGhhc2ggdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUEgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gcHVibGljQiBkaWZmZXJlbnQgcHVibGljIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgc2hhcmVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTaGFyZWRTZWNyZXQocHJpdmF0ZUEsIHB1YmxpY0IsIGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgaWYgKGlzUHJvYlB1Yihwcml2YXRlQSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpcnN0IGFyZyBtdXN0IGJlIHByaXZhdGUga2V5Jyk7XG4gICAgICAgIGlmICghaXNQcm9iUHViKHB1YmxpY0IpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzZWNvbmQgYXJnIG11c3QgYmUgcHVibGljIGtleScpO1xuICAgICAgICBjb25zdCBiID0gUG9pbnQuZnJvbUhleChwdWJsaWNCKTsgLy8gY2hlY2sgZm9yIGJlaW5nIG9uLWN1cnZlXG4gICAgICAgIHJldHVybiBiLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUEpKS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8vIFJGQzY5Nzk6IGVuc3VyZSBFQ0RTQSBtc2cgaXMgWCBieXRlcyBhbmQgPCBOLiBSRkMgc3VnZ2VzdHMgb3B0aW9uYWwgdHJ1bmNhdGluZyB2aWEgYml0czJvY3RldHMuXG4gICAgLy8gRklQUyAxODYtNCA0LjYgc3VnZ2VzdHMgdGhlIGxlZnRtb3N0IG1pbihuQml0TGVuLCBvdXRMZW4pIGJpdHMsIHdoaWNoIG1hdGNoZXMgYml0czJpbnQuXG4gICAgLy8gYml0czJpbnQgY2FuIHByb2R1Y2UgcmVzPk4sIHdlIGNhbiBkbyBtb2QocmVzLCBOKSBzaW5jZSB0aGUgYml0TGVuIGlzIHRoZSBzYW1lLlxuICAgIC8vIGludDJvY3RldHMgY2FuJ3QgYmUgdXNlZDsgcGFkcyBzbWFsbCBtc2dzIHdpdGggMDogdW5hY2NlcHRhdGJsZSBmb3IgdHJ1bmMgYXMgcGVyIFJGQyB2ZWN0b3JzXG4gICAgY29uc3QgYml0czJpbnQgPSBDVVJWRS5iaXRzMmludCB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIE91ciBjdXN0b20gY2hlY2sgXCJqdXN0IGluIGNhc2VcIlxuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDgxOTIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBpcyB0b28gbGFyZ2UnKTtcbiAgICAgICAgICAgIC8vIEZvciBjdXJ2ZXMgd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMDogYml0czJvY3RldHMoYml0czJvY3RldHMobSkpICE9PSBiaXRzMm9jdGV0cyhtKVxuICAgICAgICAgICAgLy8gZm9yIHNvbWUgY2FzZXMsIHNpbmNlIGJ5dGVzLmxlbmd0aCAqIDggaXMgbm90IGFjdHVhbCBiaXRMZW5ndGguXG4gICAgICAgICAgICBjb25zdCBudW0gPSB1dC5ieXRlc1RvTnVtYmVyQkUoYnl0ZXMpOyAvLyBjaGVjayBmb3IgPT0gdTggZG9uZSBoZXJlXG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGJ5dGVzLmxlbmd0aCAqIDggLSBDVVJWRS5uQml0TGVuZ3RoOyAvLyB0cnVuY2F0ZSB0byBuQml0TGVuZ3RoIGxlZnRtb3N0IGJpdHNcbiAgICAgICAgICAgIHJldHVybiBkZWx0YSA+IDAgPyBudW0gPj4gQmlnSW50KGRlbHRhKSA6IG51bTtcbiAgICAgICAgfTtcbiAgICBjb25zdCBiaXRzMmludF9tb2ROID0gQ1VSVkUuYml0czJpbnRfbW9kTiB8fFxuICAgICAgICBmdW5jdGlvbiAoYnl0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2ROKGJpdHMyaW50KGJ5dGVzKSk7IC8vIGNhbid0IHVzZSBieXRlc1RvTnVtYmVyQkUgaGVyZVxuICAgICAgICB9O1xuICAgIC8vIE5PVEU6IHBhZHMgb3V0cHV0IHdpdGggemVybyBhcyBwZXIgc3BlY1xuICAgIGNvbnN0IE9SREVSX01BU0sgPSB1dC5iaXRNYXNrKENVUlZFLm5CaXRMZW5ndGgpO1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRvIGJ5dGVzLiBDaGVja3MgaWYgbnVtIGluIGBbMC4uT1JERVJfTUFTSy0xXWAgZS5nLjogYFswLi4yXjI1Ni0xXWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW50Mm9jdGV0cyhudW0pIHtcbiAgICAgICAgdXQuYUluUmFuZ2UoJ251bSA8IDJeJyArIENVUlZFLm5CaXRMZW5ndGgsIG51bSwgXzBuLCBPUkRFUl9NQVNLKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsXG4gICAgLy8gdGhpcyB3aWxsIGJlIGludmFsaWQgYXQgbGVhc3QgZm9yIFA1MjEuIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIHZhbGlkYXRlU2lnVmVyT3B0cyhvcHRzKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ3ByZWhhc2hlZCBtc2dIYXNoJywgaGFzaChtc2dIYXNoKSk7XG4gICAgICAgIC8vIFdlIGNhbid0IGxhdGVyIGNhbGwgYml0czJvY3RldHMsIHNpbmNlIG5lc3RlZCBiaXRzMmludCBpcyBicm9rZW4gZm9yIGN1cnZlc1xuICAgICAgICAvLyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwLiBCZWNhdXNlIG9mIHRoYXQsIHdlIHVud3JhcCBpdCBoZXJlIGFzIGludDJvY3RldHMgY2FsbC5cbiAgICAgICAgLy8gY29uc3QgYml0czJvY3RldHMgPSAoYml0cykgPT4gaW50Mm9jdGV0cyhiaXRzMmludF9tb2ROKGJpdHMpKVxuICAgICAgICBjb25zdCBoMWludCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IGQgPSBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpOyAvLyB2YWxpZGF0ZSBwcml2YXRlIGtleSwgY29udmVydCB0byBiaWdpbnRcbiAgICAgICAgY29uc3Qgc2VlZEFyZ3MgPSBbaW50Mm9jdGV0cyhkKSwgaW50Mm9jdGV0cyhoMWludCldO1xuICAgICAgICAvLyBleHRyYUVudHJvcHkuIFJGQzY5NzkgMy42OiBhZGRpdGlvbmFsIGsnIChvcHRpb25hbCkuXG4gICAgICAgIGlmIChlbnQgIT0gbnVsbCAmJiBlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlKSk7IC8vIGNoZWNrIGZvciBiZWluZyBieXRlc1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoLCBmb3JtYXQgfSA9IG9wdHM7XG4gICAgICAgIC8vIFZlcmlmeSBvcHRzLCBkZWR1Y2Ugc2lnbmF0dXJlIGZvcm1hdFxuICAgICAgICB2YWxpZGF0ZVNpZ1Zlck9wdHMob3B0cyk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IHVuZGVmaW5lZCAmJiBmb3JtYXQgIT09ICdjb21wYWN0JyAmJiBmb3JtYXQgIT09ICdkZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmb3JtYXQgbXVzdCBiZSBjb21wYWN0IG9yIGRlcicpO1xuICAgICAgICBjb25zdCBpc0hleCA9IHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgdXQuaXNCeXRlcyhzZyk7XG4gICAgICAgIGNvbnN0IGlzT2JqID0gIWlzSGV4ICYmXG4gICAgICAgICAgICAhZm9ybWF0ICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICBzZyAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgdHlwZW9mIHNnLnIgPT09ICdiaWdpbnQnICYmXG4gICAgICAgICAgICB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCc7XG4gICAgICAgIGlmICghaXNIZXggJiYgIWlzT2JqKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNpZ25hdHVyZSwgZXhwZWN0ZWQgVWludDhBcnJheSwgaGV4IHN0cmluZyBvciBTaWduYXR1cmUgaW5zdGFuY2UnKTtcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGlzT2JqKVxuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHNnLnIsIHNnLnMpO1xuICAgICAgICAgICAgaWYgKGlzSGV4KSB7XG4gICAgICAgICAgICAgICAgLy8gU2lnbmF0dXJlIGNhbiBiZSByZXByZXNlbnRlZCBpbiAyIHdheXM6IGNvbXBhY3QgKDIqbkJ5dGVMZW5ndGgpICYgREVSICh2YXJpYWJsZS1sZW5ndGgpLlxuICAgICAgICAgICAgICAgIC8vIFNpbmNlIERFUiBjYW4gYWxzbyBiZSAyKm5CeXRlTGVuZ3RoIGJ5dGVzLCB3ZSBjaGVjayBmb3IgaXQgZmlyc3QuXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm1hdCAhPT0gJ2NvbXBhY3QnKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3NpZyA9IFNpZ25hdHVyZS5mcm9tREVSKHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGRlckVycm9yIGluc3RhbmNlb2YgREVSLkVycikpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBkZXJFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFfc2lnICYmIGZvcm1hdCAhPT0gJ2RlcicpXG4gICAgICAgICAgICAgICAgICAgIF9zaWcgPSBTaWduYXR1cmUuZnJvbUNvbXBhY3Qoc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIV9zaWcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChsb3dTICYmIF9zaWcuaGFzSGlnaFMoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2dIYXNoID0gQ1VSVkUuaGFzaChtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgeyByLCBzIH0gPSBfc2lnO1xuICAgICAgICBjb25zdCBoID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTsgLy8gQ2Fubm90IHVzZSBmaWVsZHMgbWV0aG9kcywgc2luY2UgaXQgaXMgZ3JvdXAgZWxlbWVudFxuICAgICAgICBjb25zdCBpcyA9IGludk4ocyk7IC8vIHNeLTFcbiAgICAgICAgY29uc3QgdTEgPSBtb2ROKGggKiBpcyk7IC8vIHUxID0gaHNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgdTIgPSBtb2ROKHIgKiBpcyk7IC8vIHUyID0gcnNeLTEgbW9kIG5cbiAgICAgICAgY29uc3QgUiA9IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUCwgdTEsIHUyKT8udG9BZmZpbmUoKTsgLy8gUiA9IHUx4ouFRyArIHUy4ouFUFxuICAgICAgICBpZiAoIVIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHYgPSBtb2ROKFIueCk7XG4gICAgICAgIHJldHVybiB2ID09PSByO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQsXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgU2lnbmF0dXJlLFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgU2hhbGx1ZSBhbmQgdmFuIGRlIFdvZXN0aWpuZSBtZXRob2QgZm9yIGFueSB3ZWllcnN0cmFzcyBjdXJ2ZS5cbiAqIFRPRE86IGNoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIG1lcmdlIHRoaXMgd2l0aCB1dlJhdGlvIGluIEVkd2FyZHM7IG1vdmUgdG8gbW9kdWxhci5cbiAqIGIgPSBUcnVlIGFuZCB5ID0gc3FydCh1IC8gdikgaWYgKHUgLyB2KSBpcyBzcXVhcmUgaW4gRiwgYW5kXG4gKiBiID0gRmFsc2UgYW5kIHkgPSBzcXJ0KFogKiAodSAvIHYpKSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gRnBcbiAqIEBwYXJhbSBaXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgZnVuY3Rpb24gU1dVRnBTcXJ0UmF0aW8oRnAsIFopIHtcbiAgICAvLyBHZW5lcmljIGltcGxlbWVudGF0aW9uXG4gICAgY29uc3QgcSA9IEZwLk9SREVSO1xuICAgIGxldCBsID0gXzBuO1xuICAgIGZvciAobGV0IG8gPSBxIC0gXzFuOyBvICUgXzJuID09PSBfMG47IG8gLz0gXzJuKVxuICAgICAgICBsICs9IF8xbjtcbiAgICBjb25zdCBjMSA9IGw7IC8vIDEuIGMxLCB0aGUgbGFyZ2VzdCBpbnRlZ2VyIHN1Y2ggdGhhdCAyXmMxIGRpdmlkZXMgcSAtIDEuXG4gICAgLy8gV2UgbmVlZCAybiAqKiBjMSBhbmQgMm4gKiogKGMxLTEpLiBXZSBjYW4ndCB1c2UgKio7IGJ1dCB3ZSBjYW4gdXNlIDw8LlxuICAgIC8vIDJuICoqIGMxID09IDJuIDw8IChjMS0xKVxuICAgIGNvbnN0IF8ybl9wb3dfYzFfMSA9IF8ybiA8PCAoYzEgLSBfMW4gLSBfMW4pO1xuICAgIGNvbnN0IF8ybl9wb3dfYzEgPSBfMm5fcG93X2MxXzEgKiBfMm47XG4gICAgY29uc3QgYzIgPSAocSAtIF8xbikgLyBfMm5fcG93X2MxOyAvLyAyLiBjMiA9IChxIC0gMSkgLyAoMl5jMSkgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzMgPSAoYzIgLSBfMW4pIC8gXzJuOyAvLyAzLiBjMyA9IChjMiAtIDEpIC8gMiAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzQgPSBfMm5fcG93X2MxIC0gXzFuOyAvLyA0LiBjNCA9IDJeYzEgLSAxICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzUgPSBfMm5fcG93X2MxXzE7IC8vIDUuIGM1ID0gMl4oYzEgLSAxKSAgICAgICAgICAgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgY29uc3QgYzYgPSBGcC5wb3coWiwgYzIpOyAvLyA2LiBjNiA9IFpeYzJcbiAgICBjb25zdCBjNyA9IEZwLnBvdyhaLCAoYzIgKyBfMW4pIC8gXzJuKTsgLy8gNy4gYzcgPSBaXigoYzIgKyAxKSAvIDIpXG4gICAgbGV0IHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgIGxldCB0djEgPSBjNjsgLy8gMS4gdHYxID0gYzZcbiAgICAgICAgbGV0IHR2MiA9IEZwLnBvdyh2LCBjNCk7IC8vIDIuIHR2MiA9IHZeYzRcbiAgICAgICAgbGV0IHR2MyA9IEZwLnNxcih0djIpOyAvLyAzLiB0djMgPSB0djJeMlxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCB2KTsgLy8gNC4gdHYzID0gdHYzICogdlxuICAgICAgICBsZXQgdHY1ID0gRnAubXVsKHUsIHR2Myk7IC8vIDUuIHR2NSA9IHUgKiB0djNcbiAgICAgICAgdHY1ID0gRnAucG93KHR2NSwgYzMpOyAvLyA2LiB0djUgPSB0djVeYzNcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NSwgdHYyKTsgLy8gNy4gdHY1ID0gdHY1ICogdHYyXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djUsIHYpOyAvLyA4LiB0djIgPSB0djUgKiB2XG4gICAgICAgIHR2MyA9IEZwLm11bCh0djUsIHUpOyAvLyA5LiB0djMgPSB0djUgKiB1XG4gICAgICAgIGxldCB0djQgPSBGcC5tdWwodHYzLCB0djIpOyAvLyAxMC4gdHY0ID0gdHYzICogdHYyXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djQsIGM1KTsgLy8gMTEuIHR2NSA9IHR2NF5jNVxuICAgICAgICBsZXQgaXNRUiA9IEZwLmVxbCh0djUsIEZwLk9ORSk7IC8vIDEyLiBpc1FSID0gdHY1ID09IDFcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MywgYzcpOyAvLyAxMy4gdHYyID0gdHYzICogYzdcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMTQuIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICB0djMgPSBGcC5jbW92KHR2MiwgdHYzLCBpc1FSKTsgLy8gMTUuIHR2MyA9IENNT1YodHYyLCB0djMsIGlzUVIpXG4gICAgICAgIHR2NCA9IEZwLmNtb3YodHY1LCB0djQsIGlzUVIpOyAvLyAxNi4gdHY0ID0gQ01PVih0djUsIHR2NCwgaXNRUilcbiAgICAgICAgLy8gMTcuIGZvciBpIGluIChjMSwgYzEgLSAxLCAuLi4sIDIpOlxuICAgICAgICBmb3IgKGxldCBpID0gYzE7IGkgPiBfMW47IGktLSkge1xuICAgICAgICAgICAgbGV0IHR2NSA9IGkgLSBfMm47IC8vIDE4LiAgICB0djUgPSBpIC0gMlxuICAgICAgICAgICAgdHY1ID0gXzJuIDw8ICh0djUgLSBfMW4pOyAvLyAxOS4gICAgdHY1ID0gMl50djVcbiAgICAgICAgICAgIGxldCB0dnY1ID0gRnAucG93KHR2NCwgdHY1KTsgLy8gMjAuICAgIHR2NSA9IHR2NF50djVcbiAgICAgICAgICAgIGNvbnN0IGUxID0gRnAuZXFsKHR2djUsIEZwLk9ORSk7IC8vIDIxLiAgICBlMSA9IHR2NSA9PSAxXG4gICAgICAgICAgICB0djIgPSBGcC5tdWwodHYzLCB0djEpOyAvLyAyMi4gICAgdHYyID0gdHYzICogdHYxXG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djEpOyAvLyAyMy4gICAgdHYxID0gdHYxICogdHYxXG4gICAgICAgICAgICB0dnY1ID0gRnAubXVsKHR2NCwgdHYxKTsgLy8gMjQuICAgIHR2NSA9IHR2NCAqIHR2MVxuICAgICAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgZTEpOyAvLyAyNS4gICAgdHYzID0gQ01PVih0djIsIHR2MywgZTEpXG4gICAgICAgICAgICB0djQgPSBGcC5jbW92KHR2djUsIHR2NCwgZTEpOyAvLyAyNi4gICAgdHY0ID0gQ01PVih0djUsIHR2NCwgZTEpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHR2MyB9O1xuICAgIH07XG4gICAgaWYgKEZwLk9SREVSICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gc3FydF9yYXRpb18zbW9kNCh1LCB2KVxuICAgICAgICBjb25zdCBjMSA9IChGcC5PUkRFUiAtIF8zbikgLyBfNG47IC8vIDEuIGMxID0gKHEgLSAzKSAvIDQgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIGNvbnN0IGMyID0gRnAuc3FydChGcC5uZWcoWikpOyAvLyAyLiBjMiA9IHNxcnQoLVopXG4gICAgICAgIHNxcnRSYXRpbyA9ICh1LCB2KSA9PiB7XG4gICAgICAgICAgICBsZXQgdHYxID0gRnAuc3FyKHYpOyAvLyAxLiB0djEgPSB2XjJcbiAgICAgICAgICAgIGNvbnN0IHR2MiA9IEZwLm11bCh1LCB2KTsgLy8gMi4gdHYyID0gdSAqIHZcbiAgICAgICAgICAgIHR2MSA9IEZwLm11bCh0djEsIHR2Mik7IC8vIDMuIHR2MSA9IHR2MSAqIHR2MlxuICAgICAgICAgICAgbGV0IHkxID0gRnAucG93KHR2MSwgYzEpOyAvLyA0LiB5MSA9IHR2MV5jMVxuICAgICAgICAgICAgeTEgPSBGcC5tdWwoeTEsIHR2Mik7IC8vIDUuIHkxID0geTEgKiB0djJcbiAgICAgICAgICAgIGNvbnN0IHkyID0gRnAubXVsKHkxLCBjMik7IC8vIDYuIHkyID0geTEgKiBjMlxuICAgICAgICAgICAgY29uc3QgdHYzID0gRnAubXVsKEZwLnNxcih5MSksIHYpOyAvLyA3LiB0djMgPSB5MV4yOyA4LiB0djMgPSB0djMgKiB2XG4gICAgICAgICAgICBjb25zdCBpc1FSID0gRnAuZXFsKHR2MywgdSk7IC8vIDkuIGlzUVIgPSB0djMgPT0gdVxuICAgICAgICAgICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgaXNRUik7IC8vIDEwLiB5ID0gQ01PVih5MiwgeTEsIGlzUVIpXG4gICAgICAgICAgICByZXR1cm4geyBpc1ZhbGlkOiBpc1FSLCB2YWx1ZTogeSB9OyAvLyAxMS4gcmV0dXJuIChpc1FSLCB5KSBpc1FSID8geSA6IHkqYzJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTm8gY3VydmVzIHVzZXMgdGhhdFxuICAgIC8vIGlmIChGcC5PUkRFUiAlIF84biA9PT0gXzVuKSAvLyBzcXJ0X3JhdGlvXzVtb2Q4XG4gICAgcmV0dXJuIHNxcnRSYXRpbztcbn1cbi8qKlxuICogU2ltcGxpZmllZCBTaGFsbHVlLXZhbiBkZSBXb2VzdGlqbmUtVWxhcyBNZXRob2RcbiAqIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNi42LjJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKEZwKTtcbiAgICBpZiAoIUZwLmlzVmFsaWQob3B0cy5BKSB8fCAhRnAuaXNWYWxpZChvcHRzLkIpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuWikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZVNpbXBsZVNXVTogaW52YWxpZCBvcHRzJyk7XG4gICAgY29uc3Qgc3FydFJhdGlvID0gU1dVRnBTcXJ0UmF0aW8oRnAsIG9wdHMuWik7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGcC5pc09kZCBpcyBub3QgaW1wbGVtZW50ZWQhJyk7XG4gICAgLy8gSW5wdXQ6IHUsIGFuIGVsZW1lbnQgb2YgRi5cbiAgICAvLyBPdXRwdXQ6ICh4LCB5KSwgYSBwb2ludCBvbiBFLlxuICAgIHJldHVybiAodSkgPT4ge1xuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgbGV0IHR2MSwgdHYyLCB0djMsIHR2NCwgdHY1LCB0djYsIHgsIHk7XG4gICAgICAgIHR2MSA9IEZwLnNxcih1KTsgLy8gMS4gIHR2MSA9IHVeMlxuICAgICAgICB0djEgPSBGcC5tdWwodHYxLCBvcHRzLlopOyAvLyAyLiAgdHYxID0gWiAqIHR2MVxuICAgICAgICB0djIgPSBGcC5zcXIodHYxKTsgLy8gMy4gIHR2MiA9IHR2MV4yXG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2MSk7IC8vIDQuICB0djIgPSB0djIgKyB0djFcbiAgICAgICAgdHYzID0gRnAuYWRkKHR2MiwgRnAuT05FKTsgLy8gNS4gIHR2MyA9IHR2MiArIDFcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgb3B0cy5CKTsgLy8gNi4gIHR2MyA9IEIgKiB0djNcbiAgICAgICAgdHY0ID0gRnAuY21vdihvcHRzLlosIEZwLm5lZyh0djIpLCAhRnAuZXFsKHR2MiwgRnAuWkVSTykpOyAvLyA3LiAgdHY0ID0gQ01PVihaLCAtdHYyLCB0djIgIT0gMClcbiAgICAgICAgdHY0ID0gRnAubXVsKHR2NCwgb3B0cy5BKTsgLy8gOC4gIHR2NCA9IEEgKiB0djRcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2Myk7IC8vIDkuICB0djIgPSB0djNeMlxuICAgICAgICB0djYgPSBGcC5zcXIodHY0KTsgLy8gMTAuIHR2NiA9IHR2NF4yXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQSk7IC8vIDExLiB0djUgPSBBICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDEyLiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gMTMuIHR2MiA9IHR2MiAqIHR2M1xuICAgICAgICB0djYgPSBGcC5tdWwodHY2LCB0djQpOyAvLyAxNC4gdHY2ID0gdHY2ICogdHY0XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djYsIG9wdHMuQik7IC8vIDE1LiB0djUgPSBCICogdHY2XG4gICAgICAgIHR2MiA9IEZwLmFkZCh0djIsIHR2NSk7IC8vIDE2LiB0djIgPSB0djIgKyB0djVcbiAgICAgICAgeCA9IEZwLm11bCh0djEsIHR2Myk7IC8vIDE3LiAgIHggPSB0djEgKiB0djNcbiAgICAgICAgY29uc3QgeyBpc1ZhbGlkLCB2YWx1ZSB9ID0gc3FydFJhdGlvKHR2MiwgdHY2KTsgLy8gMTguIChpc19neDFfc3F1YXJlLCB5MSkgPSBzcXJ0X3JhdGlvKHR2MiwgdHY2KVxuICAgICAgICB5ID0gRnAubXVsKHR2MSwgdSk7IC8vIDE5LiAgIHkgPSB0djEgKiB1ICAtPiBaICogdV4zICogeTFcbiAgICAgICAgeSA9IEZwLm11bCh5LCB2YWx1ZSk7IC8vIDIwLiAgIHkgPSB5ICogeTFcbiAgICAgICAgeCA9IEZwLmNtb3YoeCwgdHYzLCBpc1ZhbGlkKTsgLy8gMjEuICAgeCA9IENNT1YoeCwgdHYzLCBpc19neDFfc3F1YXJlKVxuICAgICAgICB5ID0gRnAuY21vdih5LCB2YWx1ZSwgaXNWYWxpZCk7IC8vIDIyLiAgIHkgPSBDTU9WKHksIHkxLCBpc19neDFfc3F1YXJlKVxuICAgICAgICBjb25zdCBlMSA9IEZwLmlzT2RkKHUpID09PSBGcC5pc09kZCh5KTsgLy8gMjMuICBlMSA9IHNnbjAodSkgPT0gc2duMCh5KVxuICAgICAgICB5ID0gRnAuY21vdihGcC5uZWcoeSksIHksIGUxKTsgLy8gMjQuICAgeSA9IENNT1YoLXksIHksIGUxKVxuICAgICAgICB4ID0gRnAuZGl2KHgsIHR2NCk7IC8vIDI1LiAgIHggPSB4IC8gdHY0XG4gICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2VpZXJzdHJhc3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: () => (/* binding */ encodeToCurve),\n/* harmony export */   hashToCurve: () => (/* binding */ hashToCurve),\n/* harmony export */   schnorr: () => (/* binding */ schnorr),\n/* harmony export */   secp256k1: () => (/* binding */ secp256k1)\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fpk1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n/**\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\n *\n * @example\n * import { secp256k1 } from '@noble/curves/secp256k1';\n *\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n */\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7),\n    Fp: Fpk1, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    endo: {\n        // Endomorphism, see above\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.aInRange)('x', x, _1n, secp256k1P); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\nconst num = _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(r, _1n, secp256k1P))\n            return false;\n        const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.inRange)(s, _1n, secp256k1N))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n */\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fpk1, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fpk1.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\n/** secp256k1 hash-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\n/** secp256k1 encode-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUNJO0FBQ0Q7QUFDc0I7QUFDZDtBQUM0RDtBQUNyRDtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwyREFBSyxxQ0FBcUMsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MsMENBQTBDLEtBQUssY0FBYztBQUM3RDtBQUNBO0FBQ08sa0JBQWtCLDZEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0EscUJBQXFCLHlEQUFHO0FBQ3hCLHFCQUFxQix5REFBRztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDLEVBQUUsd0RBQU07QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDREQUFNO0FBQzNCLGVBQWUsK0RBQVc7QUFDMUI7QUFDQTtBQUNBLFdBQVcsNERBQU0sQ0FBQywrREFBVztBQUM3QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUVBQWU7QUFDdkMsb0JBQW9CLHlEQUFHO0FBQ3ZCLG9CQUFvQix5REFBRztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCxzQ0FBc0MsYUFBYTtBQUNuRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDREQUFRLDJCQUEyQjtBQUN2QztBQUNBLHdDQUF3QztBQUN4Qyx3QkFBd0I7QUFDeEI7QUFDQSxzQkFBc0I7QUFDdEIsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQWU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxnRUFBVztBQUMvRCxjQUFjLCtEQUFXO0FBQ3pCLFlBQVksdUJBQXVCLG1DQUFtQztBQUN0RSxjQUFjLCtEQUFXLDBCQUEwQjtBQUNuRCwrREFBK0Q7QUFDL0Qsd0RBQXdEO0FBQ3hELGdDQUFnQztBQUNoQztBQUNBLG1EQUFtRDtBQUNuRCxZQUFZLHVCQUF1QiwyQkFBMkI7QUFDOUQsb0NBQW9DO0FBQ3BDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQVc7QUFDM0IsY0FBYywrREFBVztBQUN6QixnQkFBZ0IsK0RBQVc7QUFDM0I7QUFDQSxvQ0FBb0Msd0JBQXdCO0FBQzVELDRDQUE0QywyQkFBMkI7QUFDdkUsYUFBYSwyREFBTztBQUNwQjtBQUNBLDZDQUE2Qyw0QkFBNEI7QUFDekUsYUFBYSwyREFBTztBQUNwQjtBQUNBLDhEQUE4RDtBQUM5RCwyQ0FBMkM7QUFDM0M7QUFDQSwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVc7QUFDWCxLQUFLO0FBQ0wsQ0FBQztBQUNELHNDQUFzQyxzRUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2RUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyx3RUFBWTtBQUMvQyxZQUFZLE9BQU87QUFDbkI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBTTtBQUNoQixDQUFDO0FBQ0Q7QUFDTztBQUNQO0FBQ087QUFDUCIsInNvdXJjZXMiOlsiL1VzZXJzL21paW5hZG9pL0Rlc2t0b3AvZ2l0aHViUHJvamVjdC90aHJpZHdlYnR1dG9yaWFsL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBOSVNUIHNlY3AyNTZrMS4gU2VlIFtwZGZdKGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzItdjIucGRmKS5cbiAqXG4gKiBTZWVtcyB0byBiZSByaWdpZCAobm90IGJhY2tkb29yZWQpXG4gKiBbYXMgcGVyIGRpc2N1c3Npb25dKGh0dHBzOi8vYml0Y29pbnRhbGsub3JnL2luZGV4LnBocD90b3BpYz0yODk3OTUubXNnMzE4Mzk3NSNtc2czMTgzOTc1KS5cbiAqXG4gKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuICogRW5kb21vcnBoaXNtIHVzZXMgMnggbGVzcyBSQU0sIHNwZWVkcyB1cCBwcmVjb21wdXRhdGlvbiBieSAyeCBhbmQgRUNESCAvIGtleSByZWNvdmVyeSBieSAyMCUuXG4gKiBGb3IgcHJlY29tcHV0ZWQgd05BRiBpdCB0cmFkZXMgb2ZmIDEvMiBpbml0IHRpbWUgJiAxLzMgcmFtIGZvciAyMCUgcGVyZiBoaXQuXG4gKiBbU2VlIGV4cGxhbmF0aW9uXShodHRwczovL2dpc3QuZ2l0aHViLmNvbS9wYXVsbWlsbHIvZWI2NzA4MDY3OTNlODRkZjYyOGE3YzQzNGE4NzMwNjYpLlxuICogQG1vZHVsZVxuICovXG4vKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tICcuL19zaG9ydHdfdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBpc29nZW55TWFwIH0gZnJvbSAnLi9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzJztcbmltcG9ydCB7IEZpZWxkLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYUluUmFuZ2UsIGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBpblJhbmdlLCBudW1iZXJUb0J5dGVzQkUsIH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG5pbXBvcnQgeyBtYXBUb0N1cnZlU2ltcGxlU1dVIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcbmNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHkpICUgUDsgLy8geF43XG4gICAgY29uc3QgYjYgPSAocG93MihiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAocG93MihiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKHBvdzIoYjksIF8ybiwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9IChwb3cyKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAocG93MihiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKHBvdzIoYjQ0LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAocG93MihiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9IChwb3cyKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9IChwb3cyKGIyMjAsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKHBvdzIoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9IChwb3cyKHQxLCBfNm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCByb290ID0gcG93Mih0MiwgXzJuLCBQKTtcbiAgICBpZiAoIUZwazEuZXFsKEZwazEuc3FyKHJvb3QpLCB5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgRnBrMSA9IEZpZWxkKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG4vKipcbiAqIHNlY3AyNTZrMSBzaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBhbmQgRUNEU0Egc2lnbmF0dXJlcyBvdmVyIGl0LlxuICpcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG4gKlxuICogY29uc3QgcHJpdiA9IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gKiBjb25zdCBwdWIgPSBzZWNwMjU2azEuZ2V0UHVibGljS2V5KHByaXYpO1xuICogY29uc3QgbXNnID0gbmV3IFVpbnQ4QXJyYXkoMzIpLmZpbGwoMSk7IC8vIG1lc3NhZ2UgaGFzaCAobm90IG1lc3NhZ2UpIGluIGVjZHNhXG4gKiBjb25zdCBzaWcgPSBzZWNwMjU2azEuc2lnbihtc2csIHByaXYpOyAvLyBge3ByZWhhc2g6IHRydWV9YCBvcHRpb24gaXMgYXZhaWxhYmxlXG4gKiBjb25zdCBpc1ZhbGlkID0gc2VjcDI1NmsxLnZlcmlmeShzaWcsIG1zZywgcHViKSA9PT0gdHJ1ZTtcbiAqL1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMSA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBCaWdJbnQoMCksIC8vIGVxdWF0aW9uIHBhcmFtczogYSwgYlxuICAgIGI6IEJpZ0ludCg3KSxcbiAgICBGcDogRnBrMSwgLy8gRmllbGQncyBwcmltZTogMm4qKjI1Nm4gLSAybioqMzJuIC0gMm4qKjluIC0gMm4qKjhuIC0gMm4qKjduIC0gMm4qKjZuIC0gMm4qKjRuIC0gMW5cbiAgICBuOiBzZWNwMjU2azFOLCAvLyBDdXJ2ZSBvcmRlciwgdG90YWwgY291bnQgb2YgdmFsaWQgcG9pbnRzIGluIHRoZSBmaWVsZFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLCAvLyBDb2ZhY3RvclxuICAgIGxvd1M6IHRydWUsIC8vIEFsbG93IG9ubHkgbG93LVMgc2lnbmF0dXJlcyBieSBkZWZhdWx0IGluIHNpZ24oKSBhbmQgdmVyaWZ5KClcbiAgICBlbmRvOiB7XG4gICAgICAgIC8vIEVuZG9tb3JwaGlzbSwgc2VlIGFib3ZlXG4gICAgICAgIGJldGE6IEJpZ0ludCgnMHg3YWU5NmEyYjY1N2MwNzEwNmU2NDQ3OWVhYzM0MzRlOTljZjA0OTc1MTJmNTg5OTVjMTM5NmMyODcxOTUwMWVlJyksXG4gICAgICAgIHNwbGl0U2NhbGFyOiAoaykgPT4ge1xuICAgICAgICAgICAgY29uc3QgbiA9IHNlY3AyNTZrMU47XG4gICAgICAgICAgICBjb25zdCBhMSA9IEJpZ0ludCgnMHgzMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScpO1xuICAgICAgICAgICAgY29uc3QgYjEgPSAtXzFuICogQmlnSW50KCcweGU0NDM3ZWQ2MDEwZTg4Mjg2ZjU0N2ZhOTBhYmZlNGMzJyk7XG4gICAgICAgICAgICBjb25zdCBhMiA9IEJpZ0ludCgnMHgxMTRjYTUwZjdhOGUyZjNmNjU3YzExMDhkOWQ0NGNmZDgnKTtcbiAgICAgICAgICAgIGNvbnN0IGIyID0gYTE7XG4gICAgICAgICAgICBjb25zdCBQT1dfMl8xMjggPSBCaWdJbnQoJzB4MTAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyk7IC8vICgybioqMTI4bikudG9TdHJpbmcoMTYpXG4gICAgICAgICAgICBjb25zdCBjMSA9IGRpdk5lYXJlc3QoYjIgKiBrLCBuKTtcbiAgICAgICAgICAgIGNvbnN0IGMyID0gZGl2TmVhcmVzdCgtYjEgKiBrLCBuKTtcbiAgICAgICAgICAgIGxldCBrMSA9IG1vZChrIC0gYzEgKiBhMSAtIGMyICogYTIsIG4pO1xuICAgICAgICAgICAgbGV0IGsyID0gbW9kKC1jMSAqIGIxIC0gYzIgKiBiMiwgbik7XG4gICAgICAgICAgICBjb25zdCBrMW5lZyA9IGsxID4gUE9XXzJfMTI4O1xuICAgICAgICAgICAgY29uc3QgazJuZWcgPSBrMiA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMSA9IG4gLSBrMTtcbiAgICAgICAgICAgIGlmIChrMm5lZylcbiAgICAgICAgICAgICAgICBrMiA9IG4gLSBrMjtcbiAgICAgICAgICAgIGlmIChrMSA+IFBPV18yXzEyOCB8fCBrMiA+IFBPV18yXzEyOCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3BsaXRTY2FsYXI6IEVuZG9tb3JwaGlzbSBmYWlsZWQsIGs9JyArIGspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgazFuZWcsIGsxLCBrMm5lZywgazIgfTtcbiAgICAgICAgfSxcbiAgICB9LFxufSwgc2hhMjU2KTtcbi8vIFNjaG5vcnIgc2lnbmF0dXJlcyBhcmUgc3VwZXJpb3IgdG8gRUNEU0EgZnJvbSBhYm92ZS4gQmVsb3cgaXMgU2Nobm9yci1zcGVjaWZpYyBCSVAwMzQwIGNvZGUuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYml0Y29pbi9iaXBzL2Jsb2IvbWFzdGVyL2JpcC0wMzQwLm1lZGlhd2lraVxuY29uc3QgXzBuID0gQmlnSW50KDApO1xuLyoqIEFuIG9iamVjdCBtYXBwaW5nIHRhZ3MgdG8gdGhlaXIgdGFnZ2VkIGhhc2ggcHJlZml4IG9mIFtTSEEyNTYodGFnKSB8IFNIQTI1Nih0YWcpXSAqL1xuY29uc3QgVEFHR0VEX0hBU0hfUFJFRklYRVMgPSB7fTtcbmZ1bmN0aW9uIHRhZ2dlZEhhc2godGFnLCAuLi5tZXNzYWdlcykge1xuICAgIGxldCB0YWdQID0gVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXTtcbiAgICBpZiAodGFnUCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRhZ0ggPSBzaGEyNTYoVWludDhBcnJheS5mcm9tKHRhZywgKGMpID0+IGMuY2hhckNvZGVBdCgwKSkpO1xuICAgICAgICB0YWdQID0gY29uY2F0Qnl0ZXModGFnSCwgdGFnSCk7XG4gICAgICAgIFRBR0dFRF9IQVNIX1BSRUZJWEVTW3RhZ10gPSB0YWdQO1xuICAgIH1cbiAgICByZXR1cm4gc2hhMjU2KGNvbmNhdEJ5dGVzKHRhZ1AsIC4uLm1lc3NhZ2VzKSk7XG59XG4vLyBFQ0RTQSBjb21wYWN0IHBvaW50cyBhcmUgMzMtYnl0ZS4gU2Nobm9yciBpcyAzMjogd2Ugc3RyaXAgZmlyc3QgYnl0ZSAweDAyIG9yIDB4MDNcbmNvbnN0IHBvaW50VG9CeXRlcyA9IChwb2ludCkgPT4gcG9pbnQudG9SYXdCeXRlcyh0cnVlKS5zbGljZSgxKTtcbmNvbnN0IG51bVRvMzJiID0gKG4pID0+IG51bWJlclRvQnl0ZXNCRShuLCAzMik7XG5jb25zdCBtb2RQID0gKHgpID0+IG1vZCh4LCBzZWNwMjU2azFQKTtcbmNvbnN0IG1vZE4gPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMU4pO1xuY29uc3QgUG9pbnQgPSBzZWNwMjU2azEuUHJvamVjdGl2ZVBvaW50O1xuY29uc3QgR211bEFkZCA9IChRLCBhLCBiKSA9PiBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpO1xuLy8gQ2FsY3VsYXRlIHBvaW50LCBzY2FsYXIgYW5kIGJ5dGVzXG5mdW5jdGlvbiBzY2hub3JyR2V0RXh0UHViS2V5KHByaXYpIHtcbiAgICBsZXQgZF8gPSBzZWNwMjU2azEudXRpbHMubm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2KTsgLy8gc2FtZSBtZXRob2QgZXhlY3V0ZWQgaW4gZnJvbVByaXZhdGVLZXlcbiAgICBsZXQgcCA9IFBvaW50LmZyb21Qcml2YXRlS2V5KGRfKTsgLy8gUCA9IGQn4ouFRzsgMCA8IGQnIDwgbiBjaGVjayBpcyBkb25lIGluc2lkZVxuICAgIGNvbnN0IHNjYWxhciA9IHAuaGFzRXZlblkoKSA/IGRfIDogbW9kTigtZF8pO1xuICAgIHJldHVybiB7IHNjYWxhcjogc2NhbGFyLCBieXRlczogcG9pbnRUb0J5dGVzKHApIH07XG59XG4vKipcbiAqIGxpZnRfeCBmcm9tIEJJUDM0MC4gQ29udmVydCAzMi1ieXRlIHggY29vcmRpbmF0ZSB0byBlbGxpcHRpYyBjdXJ2ZSBwb2ludC5cbiAqIEByZXR1cm5zIHZhbGlkIHBvaW50IGNoZWNrZWQgZm9yIGJlaW5nIG9uLWN1cnZlXG4gKi9cbmZ1bmN0aW9uIGxpZnRfeCh4KSB7XG4gICAgYUluUmFuZ2UoJ3gnLCB4LCBfMW4sIHNlY3AyNTZrMVApOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuY29uc3QgbnVtID0gYnl0ZXNUb051bWJlckJFO1xuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4obnVtKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gbnVtKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKG51bShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChudW0ocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gbnVtKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghaW5SYW5nZShyLCBfMW4sIHNlY3AyNTZrMVApKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBzID0gbnVtKHNpZy5zdWJhcnJheSgzMiwgNjQpKTsgLy8gTGV0IHMgPSBpbnQoc2lnWzMyOjY0XSk7IGZhaWwgaWYgcyDiiaUgbi5cbiAgICAgICAgaWYgKCFpblJhbmdlKHMsIF8xbiwgc2VjcDI1NmsxTikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UobnVtVG8zMmIociksIHBvaW50VG9CeXRlcyhQKSwgbSk7IC8vIGludChjaGFsbGVuZ2UoYnl0ZXMocil8fGJ5dGVzKFApfHxtKSklblxuICAgICAgICBjb25zdCBSID0gR211bEFkZChQLCBzLCBtb2ROKC1lKSk7IC8vIFIgPSBz4ouFRyAtIGXii4VQXG4gICAgICAgIGlmICghUiB8fCAhUi5oYXNFdmVuWSgpIHx8IFIudG9BZmZpbmUoKS54ICE9PSByKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyAtZVAgPT0gKG4tZSlQXG4gICAgICAgIHJldHVybiB0cnVlOyAvLyBGYWlsIGlmIGlzX2luZmluaXRlKFIpIC8gbm90IGhhc19ldmVuX3koUikgLyB4KFIpIOKJoCByLlxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogU2Nobm9yciBzaWduYXR1cmVzIG92ZXIgc2VjcDI1NmsxLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBzY2hub3JyIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuICogY29uc3QgcHJpdiA9IHNjaG5vcnIudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogY29uc3QgcHViID0gc2Nobm9yci5nZXRQdWJsaWNLZXkocHJpdik7XG4gKiBjb25zdCBtc2cgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoJ2hlbGxvJyk7XG4gKiBjb25zdCBzaWcgPSBzY2hub3JyLnNpZ24obXNnLCBwcml2KTtcbiAqIGNvbnN0IGlzVmFsaWQgPSBzY2hub3JyLnZlcmlmeShzaWcsIG1zZywgcHViKTtcbiAqL1xuZXhwb3J0IGNvbnN0IHNjaG5vcnIgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+ICh7XG4gICAgZ2V0UHVibGljS2V5OiBzY2hub3JyR2V0UHVibGljS2V5LFxuICAgIHNpZ246IHNjaG5vcnJTaWduLFxuICAgIHZlcmlmeTogc2Nobm9yclZlcmlmeSxcbiAgICB1dGlsczoge1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiBzZWNwMjU2azEudXRpbHMucmFuZG9tUHJpdmF0ZUtleSxcbiAgICAgICAgbGlmdF94LFxuICAgICAgICBwb2ludFRvQnl0ZXMsXG4gICAgICAgIG51bWJlclRvQnl0ZXNCRSxcbiAgICAgICAgYnl0ZXNUb051bWJlckJFLFxuICAgICAgICB0YWdnZWRIYXNoLFxuICAgICAgICBtb2QsXG4gICAgfSxcbn0pKSgpO1xuY29uc3QgaXNvTWFwID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBpc29nZW55TWFwKEZwazEsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnBrMSwge1xuICAgIEE6IEJpZ0ludCgnMHgzZjg3MzFhYmRkNjYxYWRjYTA4YTU1NThmMGY1ZDI3MmU5NTNkMzYzY2I2ZjBlNWQ0MDU0NDdjMDFhNDQ0NTMzJyksXG4gICAgQjogQmlnSW50KCcxNzcxJyksXG4gICAgWjogRnBrMS5jcmVhdGUoQmlnSW50KCctMTEnKSksXG59KSkoKTtcbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQsIChzY2FsYXJzKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBtYXBTV1UoRnBrMS5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG59LCB7XG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgIHA6IEZwazEuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGEyNTYsXG59KSkoKTtcbi8qKiBzZWNwMjU2azEgaGFzaC10by1jdXJ2ZSBmcm9tIFtSRkMgOTM4MF0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODApLiAqL1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG4vKiogc2VjcDI1NmsxIGVuY29kZS10by1jdXJ2ZSBmcm9tIFtSRkMgOTM4MF0oaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODApLiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5lbmNvZGVUb0N1cnZlKSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VjcDI1NmsxLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: () => (/* binding */ HMAC),\n/* harmony export */   hmac: () => (/* binding */ hmac)\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/hashes/esm/utils.js\");\n/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\n\n\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.ahash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.aexists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.abytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNzRDtBQUNYO0FBQ3BDLG1CQUFtQiwyQ0FBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaURBQUs7QUFDYixvQkFBb0Isa0RBQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxtREFBTztBQUNmLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxnQkFBZ0IseURBQXlEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21paW5hZG9pL0Rlc2t0b3AvZ2l0aHViUHJvamVjdC90aHJpZHdlYnR1dG9yaWFsL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAbW9kdWxlXG4gKi9cbmltcG9ydCB7IGFieXRlcywgYWV4aXN0cywgYWhhc2ggfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIEhNQUMgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBfa2V5KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgYWhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYWV4aXN0cyh0aGlzKTtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUoYnVmKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFleGlzdHModGhpcyk7XG4gICAgICAgIGFieXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqIEBleGFtcGxlXG4gKiBpbXBvcnQgeyBobWFjIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9obWFjJztcbiAqIGltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMic7XG4gKiBjb25zdCBtYWMxID0gaG1hYyhzaGEyNTYsICdrZXknLCAnbWVzc2FnZScpO1xuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js":
/*!*************************************************!*\
  !*** ./node_modules/ox/_esm/core/AccessList.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidStorageKeySizeError: () => (/* binding */ InvalidStorageKeySizeError),\n/* harmony export */   fromTupleList: () => (/* binding */ fromTupleList),\n/* harmony export */   toTupleList: () => (/* binding */ toTupleList)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n\n\n\n\n/**\n * Converts a list of Access List tuples into a object-formatted list.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.fromTupleList([\n *   [\n *     '0x0000000000000000000000000000000000000000',\n *     [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n *     ],\n *   ],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0x0000000000000000000000000000000000000000',\n * // @log:     storageKeys: [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param accessList - List of tuples.\n * @returns Access list.\n */\nfunction fromTupleList(accessList) {\n    const list = [];\n    for (let i = 0; i < accessList.length; i++) {\n        const [address, storageKeys] = accessList[i];\n        if (address)\n            _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, { strict: false });\n        list.push({\n            address: address,\n            storageKeys: storageKeys.map((key) => _Hash_js__WEBPACK_IMPORTED_MODULE_1__.validate(key) ? key : _Hex_js__WEBPACK_IMPORTED_MODULE_2__.trimLeft(key)),\n        });\n    }\n    return list;\n}\n/**\n * Converts a structured Access List into a list of tuples.\n *\n * @example\n * ```ts twoslash\n * import { AccessList } from 'ox'\n *\n * const accessList = AccessList.toTupleList([\n *   {\n *     address: '0x0000000000000000000000000000000000000000',\n *     storageKeys: [\n *       '0x0000000000000000000000000000000000000000000000000000000000000001',\n *       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe'],\n *   },\n * ])\n * // @log: [\n * // @log:   [\n * // @log:     '0x0000000000000000000000000000000000000000',\n * // @log:     [\n * // @log:       '0x0000000000000000000000000000000000000000000000000000000000000001',\n * // @log:       '0x60fdd29ff912ce880cd3edaf9f932dc61d3dae823ea77e0323f94adb9f6a72fe',\n * // @log:     ],\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param accessList - Access list.\n * @returns List of tuples.\n */\nfunction toTupleList(accessList) {\n    if (!accessList || accessList.length === 0)\n        return [];\n    const tuple = [];\n    for (const { address, storageKeys } of accessList) {\n        for (let j = 0; j < storageKeys.length; j++)\n            if (_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(storageKeys[j]) !== 32)\n                throw new InvalidStorageKeySizeError({\n                    storageKey: storageKeys[j],\n                });\n        if (address)\n            _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, { strict: false });\n        tuple.push([address, storageKeys]);\n    }\n    return tuple;\n}\n/** Thrown when the size of a storage key is invalid. */\nclass InvalidStorageKeySizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError {\n    constructor({ storageKey }) {\n        super(`Size for storage key \"${storageKey}\" is invalid. Expected 32 bytes. Got ${_Hex_js__WEBPACK_IMPORTED_MODULE_2__.size(storageKey)} bytes.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'AccessList.InvalidStorageKeySizeError'\n        });\n    }\n}\n//# sourceMappingURL=AccessList.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQWNjZXNzTGlzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXdDO0FBQ0Y7QUFDSjtBQUNGO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0EsWUFBWSwrQ0FBYyxZQUFZLGVBQWU7QUFDckQ7QUFDQTtBQUNBLGtEQUFrRCw4Q0FBYSxjQUFjLDZDQUFZO0FBQ3pGLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4Qyx3QkFBd0Isd0JBQXdCO0FBQ2hELGdCQUFnQix5Q0FBUTtBQUN4QjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsWUFBWSwrQ0FBYyxZQUFZLGVBQWU7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QyxpREFBZ0I7QUFDaEUsa0JBQWtCLFlBQVk7QUFDOUIsdUNBQXVDLFdBQVcsdUNBQXVDLHlDQUFRLGNBQWM7QUFDL0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWluYWRvaS9EZXNrdG9wL2dpdGh1YlByb2plY3QvdGhyaWR3ZWJ0dXRvcmlhbC9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL0FjY2Vzc0xpc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG4vKipcbiAqIENvbnZlcnRzIGEgbGlzdCBvZiBBY2Nlc3MgTGlzdCB0dXBsZXMgaW50byBhIG9iamVjdC1mb3JtYXR0ZWQgbGlzdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFjY2Vzc0xpc3QgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhY2Nlc3NMaXN0ID0gQWNjZXNzTGlzdC5mcm9tVHVwbGVMaXN0KFtcbiAqICAgW1xuICogICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICAgIFtcbiAqICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLFxuICogICAgICAgJzB4NjBmZGQyOWZmOTEyY2U4ODBjZDNlZGFmOWY5MzJkYzYxZDNkYWU4MjNlYTc3ZTAzMjNmOTRhZGI5ZjZhNzJmZScsXG4gKiAgICAgXSxcbiAqICAgXSxcbiAqIF0pXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgICBzdG9yYWdlS2V5czogW1xuICogLy8gQGxvZzogICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAvLyBAbG9nOiAgICAgICAnMHg2MGZkZDI5ZmY5MTJjZTg4MGNkM2VkYWY5ZjkzMmRjNjFkM2RhZTgyM2VhNzdlMDMyM2Y5NGFkYjlmNmE3MmZlJyxcbiAqIC8vIEBsb2c6ICAgICBdLFxuICogLy8gQGxvZzogICB9LFxuICogLy8gQGxvZzogXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFjY2Vzc0xpc3QgLSBMaXN0IG9mIHR1cGxlcy5cbiAqIEByZXR1cm5zIEFjY2VzcyBsaXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVR1cGxlTGlzdChhY2Nlc3NMaXN0KSB7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWNjZXNzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBbYWRkcmVzcywgc3RvcmFnZUtleXNdID0gYWNjZXNzTGlzdFtpXTtcbiAgICAgICAgaWYgKGFkZHJlc3MpXG4gICAgICAgICAgICBBZGRyZXNzLmFzc2VydChhZGRyZXNzLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgICAgIGxpc3QucHVzaCh7XG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgc3RvcmFnZUtleXM6IHN0b3JhZ2VLZXlzLm1hcCgoa2V5KSA9PiBIYXNoLnZhbGlkYXRlKGtleSkgPyBrZXkgOiBIZXgudHJpbUxlZnQoa2V5KSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cbi8qKlxuICogQ29udmVydHMgYSBzdHJ1Y3R1cmVkIEFjY2VzcyBMaXN0IGludG8gYSBsaXN0IG9mIHR1cGxlcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEFjY2Vzc0xpc3QgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhY2Nlc3NMaXN0ID0gQWNjZXNzTGlzdC50b1R1cGxlTGlzdChbXG4gKiAgIHtcbiAqICAgICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgICBzdG9yYWdlS2V5czogW1xuICogICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAgICAgICAnMHg2MGZkZDI5ZmY5MTJjZTg4MGNkM2VkYWY5ZjkzMmRjNjFkM2RhZTgyM2VhNzdlMDMyM2Y5NGFkYjlmNmE3MmZlJ10sXG4gKiAgIH0sXG4gKiBdKVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICBbXG4gKiAvLyBAbG9nOiAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgICAgW1xuICogLy8gQGxvZzogICAgICAgJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMScsXG4gKiAvLyBAbG9nOiAgICAgICAnMHg2MGZkZDI5ZmY5MTJjZTg4MGNkM2VkYWY5ZjkzMmRjNjFkM2RhZTgyM2VhNzdlMDMyM2Y5NGFkYjlmNmE3MmZlJyxcbiAqIC8vIEBsb2c6ICAgICBdLFxuICogLy8gQGxvZzogICBdLFxuICogLy8gQGxvZzogXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGFjY2Vzc0xpc3QgLSBBY2Nlc3MgbGlzdC5cbiAqIEByZXR1cm5zIExpc3Qgb2YgdHVwbGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZUxpc3QoYWNjZXNzTGlzdCkge1xuICAgIGlmICghYWNjZXNzTGlzdCB8fCBhY2Nlc3NMaXN0Lmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIGNvbnN0IHR1cGxlID0gW107XG4gICAgZm9yIChjb25zdCB7IGFkZHJlc3MsIHN0b3JhZ2VLZXlzIH0gb2YgYWNjZXNzTGlzdCkge1xuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0b3JhZ2VLZXlzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgaWYgKEhleC5zaXplKHN0b3JhZ2VLZXlzW2pdKSAhPT0gMzIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZUtleTogc3RvcmFnZUtleXNbal0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIGlmIChhZGRyZXNzKVxuICAgICAgICAgICAgQWRkcmVzcy5hc3NlcnQoYWRkcmVzcywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgICAgICB0dXBsZS5wdXNoKFthZGRyZXNzLCBzdG9yYWdlS2V5c10pO1xuICAgIH1cbiAgICByZXR1cm4gdHVwbGU7XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpemUgb2YgYSBzdG9yYWdlIGtleSBpcyBpbnZhbGlkLiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBzdG9yYWdlS2V5IH0pIHtcbiAgICAgICAgc3VwZXIoYFNpemUgZm9yIHN0b3JhZ2Uga2V5IFwiJHtzdG9yYWdlS2V5fVwiIGlzIGludmFsaWQuIEV4cGVjdGVkIDMyIGJ5dGVzLiBHb3QgJHtIZXguc2l6ZShzdG9yYWdlS2V5KX0gYnl0ZXMuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdBY2Nlc3NMaXN0LkludmFsaWRTdG9yYWdlS2V5U2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BY2Nlc3NMaXN0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Authorization.js":
/*!****************************************************!*\
  !*** ./node_modules/ox/_esm/core/Authorization.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromRpcList: () => (/* binding */ fromRpcList),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   fromTupleList: () => (/* binding */ fromTupleList),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toRpcList: () => (/* binding */ toRpcList),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   toTupleList: () => (/* binding */ toTupleList)\n/* harmony export */ });\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n\n\n\n\n/**\n * Converts an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization object into a typed {@link ox#Authorization.Authorization}.\n *\n * @example\n * An Authorization can be instantiated from an [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * A {@link ox#Signature.Signature} can be attached with the `signature` option. The example below demonstrates signing\n * an Authorization with {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   chainId: 1,\n *   nonce: 40n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorization_signed = Authorization.from(authorization, { signature }) // [!code focus]\n * ```\n *\n * @param authorization - An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple in object format.\n * @param options - Authorization options.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nfunction from(authorization, options = {}) {\n    if (typeof authorization.chainId === 'string')\n        return fromRpc(authorization);\n    return { ...authorization, ...options.signature };\n}\n/**\n * Converts an {@link ox#Authorization.Rpc} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param authorization - The RPC-formatted Authorization.\n * @returns A signed {@link ox#Authorization.Authorization}.\n */\nfunction fromRpc(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return {\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature,\n    };\n}\n/**\n * Converts an {@link ox#Authorization.ListRpc} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: '0x1',\n *   nonce: '0x1',\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * }])\n * ```\n *\n * @param authorizationList - The RPC-formatted Authorization list.\n * @returns A signed {@link ox#Authorization.List}.\n */\nfunction fromRpcList(authorizationList) {\n    return authorizationList.map(fromRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Tuple} to an {@link ox#Authorization.Authorization}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3'\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log: }\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.fromTuple([\n *   '0x1',\n *   '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n *   '0x3',\n *   '0x1',\n *   '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90',\n *   '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064',\n * ])\n * // @log: {\n * // @log:   address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:   chainId: 1,\n * // @log:   nonce: 3n\n * // @log:   r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:   s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @param tuple - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n * @returns The {@link ox#Authorization.Authorization}.\n */\nfunction fromTuple(tuple) {\n    const [chainId, address, nonce, yParity, r, s] = tuple;\n    const signature = yParity && r && s ? _Signature_js__WEBPACK_IMPORTED_MODULE_0__.fromTuple([yParity, r, s]) : undefined;\n    return from({\n        address,\n        chainId: Number(chainId),\n        nonce: BigInt(nonce),\n        ...signature,\n    });\n}\n/**\n * Converts an {@link ox#Authorization.TupleList} to an {@link ox#Authorization.List}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @example\n * It is also possible to append a Signature tuple to the end of an Authorization tuple.\n *\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorizationList = Authorization.fromTupleList([\n *   ['0x1', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x3', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n *   ['0x3', '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c', '0x14', '0x1', '0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90', '0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'],\n * ])\n * // @log: [\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 1,\n * // @log:     nonce: 3n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log:   {\n * // @log:     address: '0xbe95c3f554e9fc85ec51be69a3d807a0d55bcf2c',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:     r: BigInt('0x68a020a209d3d56c46f38cc50a33f704f4a9a10a59377f8dd762ac66910e9b90'),\n * // @log:     s: BigInt('0x7e865ad05c4035ab5792787d4a0297a43617ae897930a6fe4d822b8faea52064'),\n * // @log:     yParity: 0,\n * // @log:   },\n * // @log: ]\n * ```\n *\n * @param tupleList - The [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n * @returns An {@link ox#Authorization.List}.\n */\nfunction fromTupleList(tupleList) {\n    const list = [];\n    for (const tuple of tupleList)\n        list.push(fromTuple(tuple));\n    return list;\n}\n/**\n * Computes the sign payload for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * The example below demonstrates computing the sign payload for an {@link ox#Authorization.Authorization}. This payload\n * can then be passed to signing functions like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Authorization, Secp256k1 } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const payload = Authorization.getSignPayload(authorization) // [!code focus]\n *\n * const signature = Secp256k1.sign({\n *   payload,\n *   privateKey: '0x...',\n * })\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The sign payload.\n */\nfunction getSignPayload(authorization) {\n    return hash(authorization);\n}\n/**\n * Computes the hash for an {@link ox#Authorization.Authorization} in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702): `keccak256('0x05' || rlp([chain_id, address, nonce]))`.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const hash = Authorization.hash(authorization) // [!code focus]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns The hash.\n */\nfunction hash(authorization) {\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_1__.keccak256(_Hex_js__WEBPACK_IMPORTED_MODULE_2__.concat('0x05', _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toTuple(authorization))));\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpc({\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * })\n * ```\n *\n * @param authorization - An Authorization.\n * @returns An RPC-formatted Authorization.\n */\nfunction toRpc(authorization) {\n    const { address, chainId, nonce, ...signature } = authorization;\n    return {\n        address,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId),\n        nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce),\n        ..._Signature_js__WEBPACK_IMPORTED_MODULE_0__.toRpc(signature),\n    };\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.ListRpc}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.toRpcList([{\n *   address: '0x0000000000000000000000000000000000000000',\n *   chainId: 1,\n *   nonce: 1n,\n *   r: 44944627813007772897391531230081695102703289123332187696115181104739239197517n,\n *   s: 36528503505192438307355164441104001310566505351980369085208178712678799181120n,\n *   yParity: 0,\n * }])\n * ```\n *\n * @param authorizationList - An Authorization List.\n * @returns An RPC-formatted Authorization List.\n */\nfunction toRpcList(authorizationList) {\n    return authorizationList.map(toRpc);\n}\n/**\n * Converts an {@link ox#Authorization.Authorization} to an {@link ox#Authorization.Tuple}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n *\n * const tuple = Authorization.toTuple(authorization) // [!code focus]\n * // @log: [\n * // @log:   address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:   chainId: 1,\n * // @log:   nonce: 69n,\n * // @log: ]\n * ```\n *\n * @param authorization - The {@link ox#Authorization.Authorization}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple.\n */\nfunction toTuple(authorization) {\n    const { address, chainId, nonce } = authorization;\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_0__.extract(authorization);\n    return [\n        chainId ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(chainId) : '0x',\n        address,\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_2__.fromNumber(nonce) : '0x',\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_0__.toTuple(signature) : []),\n    ];\n}\n/**\n * Converts an {@link ox#Authorization.List} to an {@link ox#Authorization.TupleList}.\n *\n * @example\n * ```ts twoslash\n * import { Authorization } from 'ox'\n *\n * const authorization_1 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 1,\n *   nonce: 69n,\n * })\n * const authorization_2 = Authorization.from({\n *   address: '0x1234567890abcdef1234567890abcdef12345678',\n *   chainId: 3,\n *   nonce: 20n,\n * })\n *\n * const tuple = Authorization.toTupleList([authorization_1, authorization_2]) // [!code focus]\n * // @log: [\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 1,\n * // @log:     nonce: 69n,\n * // @log:   ],\n * // @log:   [\n * // @log:     address: '0x1234567890abcdef1234567890abcdef12345678',\n * // @log:     chainId: 3,\n * // @log:     nonce: 20n,\n * // @log:   ],\n * // @log: ]\n * ```\n *\n * @param list - An {@link ox#Authorization.List}.\n * @returns An [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Authorization tuple list.\n */\nfunction toTupleList(list) {\n    if (!list || list.length === 0)\n        return [];\n    const tupleList = [];\n    for (const authorization of list)\n        tupleList.push(toTuple(authorization));\n    return tupleList;\n}\n//# sourceMappingURL=Authorization.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQXV0aG9yaXphdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0M7QUFDRjtBQUNBO0FBQ1k7QUFDNUM7QUFDQSxzR0FBc0cscUNBQXFDO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLDhCQUE4QjtBQUNwQywwQkFBMEIsbUNBQW1DO0FBQzdEO0FBQ0E7QUFDQSxZQUFZLDJCQUEyQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0Esb0VBQW9FLFdBQVc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIscUNBQXFDO0FBQ3REO0FBQ08seUNBQXlDO0FBQ2hEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEIsT0FBTyxxQ0FBcUM7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscUNBQXFDO0FBQzNEO0FBQ087QUFDUCxZQUFZLDBCQUEwQjtBQUN0QyxzQkFBc0Isa0RBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDLE9BQU8sNEJBQTRCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDRCQUE0QjtBQUNs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QUNPO0FBQ1AsWUFBWSwwQkFBMEI7QUFDdEMsc0JBQXNCLGtEQUFpQjtBQUN2QztBQUNBLGtCQUFrQiwrQ0FBYztBQUNoQztBQUNBLGdCQUFnQiwrQ0FBYztBQUM5Qix3QkFBd0Isa0RBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkIsT0FBTyxpQ0FBaUM7QUFDckY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0QkFBNEI7QUFDakQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21paW5hZG9pL0Rlc2t0b3AvZ2l0aHViUHJvamVjdC90aHJpZHdlYnR1dG9yaWFsL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvQXV0aG9yaXphdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgUmxwIGZyb20gJy4vUmxwLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZSBmcm9tICcuL1NpZ25hdHVyZS5qcyc7XG4vKipcbiAqIENvbnZlcnRzIGFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIG9iamVjdCBpbnRvIGEgdHlwZWQge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIEFuIEF1dGhvcml6YXRpb24gY2FuIGJlIGluc3RhbnRpYXRlZCBmcm9tIGFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlIGluIG9iamVjdCBmb3JtYXQuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IGNhbiBiZSBhdHRhY2hlZCB3aXRoIHRoZSBgc2lnbmF0dXJlYCBvcHRpb24uIFRoZSBleGFtcGxlIGJlbG93IGRlbW9uc3RyYXRlcyBzaWduaW5nXG4gKiBhbiBBdXRob3JpemF0aW9uIHdpdGgge0BsaW5rIG94I1NlY3AyNTZrMS4oc2lnbjpmdW5jdGlvbil9LlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uLCBTZWNwMjU2azEgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA0MG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogQXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbl9zaWduZWQgPSBBdXRob3JpemF0aW9uLmZyb20oYXV0aG9yaXphdGlvbiwgeyBzaWduYXR1cmUgfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBBbiBbRUlQLTc3MDJdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMikgQXV0aG9yaXphdGlvbiB0dXBsZSBpbiBvYmplY3QgZm9ybWF0LlxuICogQHBhcmFtIG9wdGlvbnMgLSBBdXRob3JpemF0aW9uIG9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKGF1dGhvcml6YXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2YgYXV0aG9yaXphdGlvbi5jaGFpbklkID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIGZyb21ScGMoYXV0aG9yaXphdGlvbik7XG4gICAgcmV0dXJuIHsgLi4uYXV0aG9yaXphdGlvbiwgLi4ub3B0aW9ucy5zaWduYXR1cmUgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uUnBjfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tUnBjKHtcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6ICcweDEnLFxuICogICBub25jZTogJzB4MScsXG4gKiAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgeVBhcml0eTogJzB4MCcsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGF1dGhvcml6YXRpb24gLSBUaGUgUlBDLWZvcm1hdHRlZCBBdXRob3JpemF0aW9uLlxuICogQHJldHVybnMgQSBzaWduZWQge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tUnBjKGF1dGhvcml6YXRpb24pIHtcbiAgICBjb25zdCB7IGFkZHJlc3MsIGNoYWluSWQsIG5vbmNlIH0gPSBhdXRob3JpemF0aW9uO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KGF1dGhvcml6YXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2U6IEJpZ0ludChub25jZSksXG4gICAgICAgIC4uLnNpZ25hdHVyZSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0UnBjfSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IEF1dGhvcml6YXRpb24uZnJvbVJwY0xpc3QoW3tcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6ICcweDEnLFxuICogICBub25jZTogJzB4MScsXG4gKiAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgeVBhcml0eTogJzB4MCcsXG4gKiB9XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uTGlzdCAtIFRoZSBSUEMtZm9ybWF0dGVkIEF1dGhvcml6YXRpb24gbGlzdC5cbiAqIEByZXR1cm5zIEEgc2lnbmVkIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwY0xpc3QoYXV0aG9yaXphdGlvbkxpc3QpIHtcbiAgICByZXR1cm4gYXV0aG9yaXphdGlvbkxpc3QubWFwKGZyb21ScGMpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5UdXBsZX0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbVR1cGxlKFtcbiAqICAgJzB4MScsXG4gKiAgICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLFxuICogICAnMHgzJ1xuICogXSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiAzblxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqIEl0IGlzIGFsc28gcG9zc2libGUgdG8gYXBwZW5kIGEgU2lnbmF0dXJlIHR1cGxlIHRvIHRoZSBlbmQgb2YgYW4gQXV0aG9yaXphdGlvbiB0dXBsZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZShbXG4gKiAgICcweDEnLFxuICogICAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqICAgJzB4MycsXG4gKiAgICcweDEnLFxuICogICAnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJyxcbiAqICAgJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcsXG4gKiBdKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDNuXG4gKiAvLyBAbG9nOiAgIHI6IEJpZ0ludCgnMHg2OGEwMjBhMjA5ZDNkNTZjNDZmMzhjYzUwYTMzZjcwNGY0YTlhMTBhNTkzNzdmOGRkNzYyYWM2NjkxMGU5YjkwJyksXG4gKiAvLyBAbG9nOiAgIHM6IEJpZ0ludCgnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0JyksXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHVwbGUgLSBUaGUgW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUuXG4gKiBAcmV0dXJucyBUaGUge0BsaW5rIG94I0F1dGhvcml6YXRpb24uQXV0aG9yaXphdGlvbn0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGUodHVwbGUpIHtcbiAgICBjb25zdCBbY2hhaW5JZCwgYWRkcmVzcywgbm9uY2UsIHlQYXJpdHksIHIsIHNdID0gdHVwbGU7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0geVBhcml0eSAmJiByICYmIHMgPyBTaWduYXR1cmUuZnJvbVR1cGxlKFt5UGFyaXR5LCByLCBzXSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGZyb20oe1xuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIG5vbmNlOiBCaWdJbnQobm9uY2UpLFxuICAgICAgICAuLi5zaWduYXR1cmUsXG4gICAgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlTGlzdH0gdG8gYW4ge0BsaW5rIG94I0F1dGhvcml6YXRpb24uTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZUxpc3QoW1xuICogICBbJzB4MScsICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLCAnMHgzJ10sXG4gKiAgIFsnMHgzJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDE0J10sXG4gKiBdKVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICB7XG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogM24sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byBhcHBlbmQgYSBTaWduYXR1cmUgdHVwbGUgdG8gdGhlIGVuZCBvZiBhbiBBdXRob3JpemF0aW9uIHR1cGxlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZUxpc3QoW1xuICogICBbJzB4MScsICcweGJlOTVjM2Y1NTRlOWZjODVlYzUxYmU2OWEzZDgwN2EwZDU1YmNmMmMnLCAnMHgzJywgJzB4MScsICcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnLCAnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0J10sXG4gKiAgIFsnMHgzJywgJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsICcweDE0JywgJzB4MScsICcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnLCAnMHg3ZTg2NWFkMDVjNDAzNWFiNTc5Mjc4N2Q0YTAyOTdhNDM2MTdhZTg5NzkzMGE2ZmU0ZDgyMmI4ZmFlYTUyMDY0J10sXG4gKiBdKVxuICogLy8gQGxvZzogW1xuICogLy8gQGxvZzogICB7XG4gKiAvLyBAbG9nOiAgICAgYWRkcmVzczogJzB4YmU5NWMzZjU1NGU5ZmM4NWVjNTFiZTY5YTNkODA3YTBkNTViY2YyYycsXG4gKiAvLyBAbG9nOiAgICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgICBub25jZTogM24sXG4gKiAvLyBAbG9nOiAgICAgcjogQmlnSW50KCcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnKSxcbiAqIC8vIEBsb2c6ICAgICBzOiBCaWdJbnQoJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcpLFxuICogLy8gQGxvZzogICAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiAgIHtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHhiZTk1YzNmNTU0ZTlmYzg1ZWM1MWJlNjlhM2Q4MDdhMGQ1NWJjZjJjJyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgICAgcjogQmlnSW50KCcweDY4YTAyMGEyMDlkM2Q1NmM0NmYzOGNjNTBhMzNmNzA0ZjRhOWExMGE1OTM3N2Y4ZGQ3NjJhYzY2OTEwZTliOTAnKSxcbiAqIC8vIEBsb2c6ICAgICBzOiBCaWdJbnQoJzB4N2U4NjVhZDA1YzQwMzVhYjU3OTI3ODdkNGEwMjk3YTQzNjE3YWU4OTc5MzBhNmZlNGQ4MjJiOGZhZWE1MjA2NCcpLFxuICogLy8gQGxvZzogICAgIHlQYXJpdHk6IDAsXG4gKiAvLyBAbG9nOiAgIH0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHVwbGVMaXN0IC0gVGhlIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlIGxpc3QuXG4gKiBAcmV0dXJucyBBbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21UdXBsZUxpc3QodHVwbGVMaXN0KSB7XG4gICAgY29uc3QgbGlzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgdHVwbGUgb2YgdHVwbGVMaXN0KVxuICAgICAgICBsaXN0LnB1c2goZnJvbVR1cGxlKHR1cGxlKSk7XG4gICAgcmV0dXJuIGxpc3Q7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBzaWduIHBheWxvYWQgZm9yIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IGluIFtFSVAtNzcwMiBmb3JtYXRdKGh0dHBzOi8vZWlwcy5ldGhlcmV1bS5vcmcvRUlQUy9laXAtNzcwMik6IGBrZWNjYWsyNTYoJzB4MDUnIHx8IHJscChbY2hhaW5faWQsIGFkZHJlc3MsIG5vbmNlXSkpYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGNvbXB1dGluZyB0aGUgc2lnbiBwYXlsb2FkIGZvciBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS4gVGhpcyBwYXlsb2FkXG4gKiBjYW4gdGhlbiBiZSBwYXNzZWQgdG8gc2lnbmluZyBmdW5jdGlvbnMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24sIFNlY3AyNTZrMSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGF1dGhvcml6YXRpb24gPSBBdXRob3JpemF0aW9uLmZyb20oe1xuICogICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDY5bixcbiAqIH0pXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IEF1dGhvcml6YXRpb24uZ2V0U2lnblBheWxvYWQoYXV0aG9yaXphdGlvbikgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZCxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIFRoZSBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSB7XG4gICAgcmV0dXJuIGhhc2goYXV0aG9yaXphdGlvbik7XG59XG4vKipcbiAqIENvbXB1dGVzIHRoZSBoYXNoIGZvciBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufSBpbiBbRUlQLTc3MDIgZm9ybWF0XShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpOiBga2VjY2FrMjU2KCcweDA1JyB8fCBybHAoW2NoYWluX2lkLCBhZGRyZXNzLCBub25jZV0pKWAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3ODkwYWJjZGVmMTIzNDU2NzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogNjluLFxuICogfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gQXV0aG9yaXphdGlvbi5oYXNoKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uIC0gVGhlIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259LlxuICogQHJldHVybnMgVGhlIGhhc2guXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGF1dGhvcml6YXRpb24pIHtcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoSGV4LmNvbmNhdCgnMHgwNScsIFJscC5mcm9tSGV4KHRvVHVwbGUoYXV0aG9yaXphdGlvbikpKSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlJwY30uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24udG9ScGMoe1xuICogICBhZGRyZXNzOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDFuLFxuICogICByOiA0NDk0NDYyNzgxMzAwNzc3Mjg5NzM5MTUzMTIzMDA4MTY5NTEwMjcwMzI4OTEyMzMzMjE4NzY5NjExNTE4MTEwNDczOTIzOTE5NzUxN24sXG4gKiAgIHM6IDM2NTI4NTAzNTA1MTkyNDM4MzA3MzU1MTY0NDQxMTA0MDAxMzEwNTY2NTA1MzUxOTgwMzY5MDg1MjA4MTc4NzEyNjc4Nzk5MTgxMTIwbixcbiAqICAgeVBhcml0eTogMCxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIEFuIEF1dGhvcml6YXRpb24uXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIEF1dGhvcml6YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSwgLi4uc2lnbmF0dXJlIH0gPSBhdXRob3JpemF0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZHJlc3MsXG4gICAgICAgIGNoYWluSWQ6IEhleC5mcm9tTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICBub25jZTogSGV4LmZyb21OdW1iZXIobm9uY2UpLFxuICAgICAgICAuLi5TaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSxcbiAgICB9O1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0fSB0byBhbiB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5MaXN0UnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi50b1JwY0xpc3QoW3tcbiAqICAgYWRkcmVzczogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAxbixcbiAqICAgcjogNDQ5NDQ2Mjc4MTMwMDc3NzI4OTczOTE1MzEyMzAwODE2OTUxMDI3MDMyODkxMjMzMzIxODc2OTYxMTUxODExMDQ3MzkyMzkxOTc1MTduLFxuICogICBzOiAzNjUyODUwMzUwNTE5MjQzODMwNzM1NTE2NDQ0MTEwNDAwMTMxMDU2NjUwNTM1MTk4MDM2OTA4NTIwODE3ODcxMjY3ODc5OTE4MTEyMG4sXG4gKiAgIHlQYXJpdHk6IDAsXG4gKiB9XSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBhdXRob3JpemF0aW9uTGlzdCAtIEFuIEF1dGhvcml6YXRpb24gTGlzdC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgQXV0aG9yaXphdGlvbiBMaXN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGNMaXN0KGF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgcmV0dXJuIGF1dGhvcml6YXRpb25MaXN0Lm1hcCh0b1JwYyk7XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkF1dGhvcml6YXRpb259IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvbi50b1R1cGxlKGF1dGhvcml6YXRpb24pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IFtcbiAqIC8vIEBsb2c6ICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYXV0aG9yaXphdGlvbiAtIFRoZSB7QGxpbmsgb3gjQXV0aG9yaXphdGlvbi5BdXRob3JpemF0aW9ufS5cbiAqIEByZXR1cm5zIEFuIFtFSVAtNzcwMl0oaHR0cHM6Ly9laXBzLmV0aGVyZXVtLm9yZy9FSVBTL2VpcC03NzAyKSBBdXRob3JpemF0aW9uIHR1cGxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZShhdXRob3JpemF0aW9uKSB7XG4gICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkLCBub25jZSB9ID0gYXV0aG9yaXphdGlvbjtcbiAgICBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZXh0cmFjdChhdXRob3JpemF0aW9uKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBjaGFpbklkID8gSGV4LmZyb21OdW1iZXIoY2hhaW5JZCkgOiAnMHgnLFxuICAgICAgICBhZGRyZXNzLFxuICAgICAgICBub25jZSA/IEhleC5mcm9tTnVtYmVyKG5vbmNlKSA6ICcweCcsXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9UdXBsZShzaWduYXR1cmUpIDogW10pLFxuICAgIF07XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9IHRvIGFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLlR1cGxlTGlzdH0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBBdXRob3JpemF0aW9uIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbl8xID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiA2OW4sXG4gKiB9KVxuICogY29uc3QgYXV0aG9yaXphdGlvbl8yID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4MTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4OTBhYmNkZWYxMjM0NTY3OCcsXG4gKiAgIGNoYWluSWQ6IDMsXG4gKiAgIG5vbmNlOiAyMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHR1cGxlID0gQXV0aG9yaXphdGlvbi50b1R1cGxlTGlzdChbYXV0aG9yaXphdGlvbl8xLCBhdXRob3JpemF0aW9uXzJdKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiBbXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiA2OW4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiAgIFtcbiAqIC8vIEBsb2c6ICAgICBhZGRyZXNzOiAnMHgxMjM0NTY3ODkwYWJjZGVmMTIzNDU2Nzg5MGFiY2RlZjEyMzQ1Njc4JyxcbiAqIC8vIEBsb2c6ICAgICBjaGFpbklkOiAzLFxuICogLy8gQGxvZzogICAgIG5vbmNlOiAyMG4sXG4gKiAvLyBAbG9nOiAgIF0sXG4gKiAvLyBAbG9nOiBdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gbGlzdCAtIEFuIHtAbGluayBveCNBdXRob3JpemF0aW9uLkxpc3R9LlxuICogQHJldHVybnMgQW4gW0VJUC03NzAyXShodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTc3MDIpIEF1dGhvcml6YXRpb24gdHVwbGUgbGlzdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvVHVwbGVMaXN0KGxpc3QpIHtcbiAgICBpZiAoIWxpc3QgfHwgbGlzdC5sZW5ndGggPT09IDApXG4gICAgICAgIHJldHVybiBbXTtcbiAgICBjb25zdCB0dXBsZUxpc3QgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGF1dGhvcml6YXRpb24gb2YgbGlzdClcbiAgICAgICAgdHVwbGVMaXN0LnB1c2godG9UdXBsZShhdXRob3JpemF0aW9uKSk7XG4gICAgcmV0dXJuIHR1cGxlTGlzdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dGhvcml6YXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Authorization.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js":
/*!******************************************!*\
  !*** ./node_modules/ox/_esm/core/Rlp.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   decodeRlpCursor: () => (/* binding */ decodeRlpCursor),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   readLength: () => (/* binding */ readLength),\n/* harmony export */   readList: () => (/* binding */ readList),\n/* harmony export */   to: () => (/* binding */ to),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toHex: () => (/* binding */ toHex)\n/* harmony export */ });\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Bytes.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal/cursor.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/internal/cursor.js\");\n\n\n\n\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Bytes.Bytes} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toBytes('0x8b68656c6c6f20776f726c64')\n * // Uint8Array([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Bytes.Bytes} value.\n */\nfunction toBytes(value) {\n    return to(value, 'Bytes');\n}\n/**\n * Decodes a Recursive-Length Prefix (RLP) value into a {@link ox#Hex.Hex} value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n * Rlp.toHex('0x8b68656c6c6f20776f726c64')\n * // 0x68656c6c6f20776f726c64\n * ```\n *\n * @param value - The value to decode.\n * @returns The decoded {@link ox#Hex.Hex} value.\n */\nfunction toHex(value) {\n    return to(value, 'Hex');\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\n/** @internal */\nfunction to(value, to) {\n    const to_ = to ?? (typeof value === 'string' ? 'Hex' : 'Bytes');\n    const bytes = (() => {\n        if (typeof value === 'string') {\n            if (value.length > 3 && value.length % 2 !== 0)\n                throw new _Hex_js__WEBPACK_IMPORTED_MODULE_0__.InvalidLengthError(value);\n            return _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(value);\n        }\n        return value;\n    })();\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(bytes, {\n        recursiveReadLimit: Number.POSITIVE_INFINITY,\n    });\n    const result = decodeRlpCursor(cursor, to_);\n    return result;\n}\n/** @internal */\n/** @internal */\nfunction decodeRlpCursor(cursor, to = 'Hex') {\n    if (cursor.bytes.length === 0)\n        return (to === 'Hex' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes) : cursor.bytes);\n    const prefix = cursor.readByte();\n    if (prefix < 0x80)\n        cursor.decrementPosition(1);\n    // bytes\n    if (prefix < 0xc0) {\n        const length = readLength(cursor, prefix, 0x80);\n        const bytes = cursor.readBytes(length);\n        return (to === 'Hex' ? _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(bytes) : bytes);\n    }\n    // list\n    const length = readLength(cursor, prefix, 0xc0);\n    return readList(cursor, length, to);\n}\n/** @internal */\nfunction readLength(cursor, prefix, offset) {\n    if (offset === 0x80 && prefix < 0x80)\n        return 1;\n    if (prefix <= offset + 55)\n        return prefix - offset;\n    if (prefix === offset + 55 + 1)\n        return cursor.readUint8();\n    if (prefix === offset + 55 + 2)\n        return cursor.readUint16();\n    if (prefix === offset + 55 + 3)\n        return cursor.readUint24();\n    if (prefix === offset + 55 + 4)\n        return cursor.readUint32();\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError('Invalid RLP prefix');\n}\n/** @internal */\nfunction readList(cursor, length, to) {\n    const position = cursor.position;\n    const value = [];\n    while (cursor.position - position < length)\n        value.push(decodeRlpCursor(cursor, to));\n    return value;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.from('0x68656c6c6f20776f726c64', { as: 'Hex' })\n * // @log: 0x8b68656c6c6f20776f726c64\n *\n * Rlp.from(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]), { as: 'Bytes' })\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param value - The {@link ox#Bytes.Bytes} or {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction from(value, options) {\n    const { as } = options;\n    const encodable = getEncodable(value);\n    const cursor = _internal_cursor_js__WEBPACK_IMPORTED_MODULE_2__.create(new Uint8Array(encodable.length));\n    encodable.encode(cursor);\n    if (as === 'Hex')\n        return _Hex_js__WEBPACK_IMPORTED_MODULE_0__.fromBytes(cursor.bytes);\n    return cursor.bytes;\n}\n/**\n * Encodes a {@link ox#Bytes.Bytes} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Bytes, Rlp } from 'ox'\n *\n * Rlp.fromBytes(Bytes.from([139, 104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100]))\n * // @log: Uint8Array([104, 101, 108, 108, 111,  32, 119, 111, 114, 108, 100])\n * ```\n *\n * @param bytes - The {@link ox#Bytes.Bytes} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction fromBytes(bytes, options = {}) {\n    const { as = 'Bytes' } = options;\n    return from(bytes, { as });\n}\n/**\n * Encodes a {@link ox#Hex.Hex} value into a Recursive-Length Prefix (RLP) value.\n *\n * @example\n * ```ts twoslash\n * import { Rlp } from 'ox'\n *\n * Rlp.fromHex('0x68656c6c6f20776f726c64')\n * // @log: 0x8b68656c6c6f20776f726c64\n * ```\n *\n * @param hex - The {@link ox#Hex.Hex} value to encode.\n * @param options - Options.\n * @returns The RLP value.\n */\nfunction fromHex(hex, options = {}) {\n    const { as = 'Hex' } = options;\n    return from(hex, { as });\n}\n/////////////////////////////////////////////////////////////////////////////////\n// Internal\n/////////////////////////////////////////////////////////////////////////////////\nfunction getEncodable(bytes) {\n    if (Array.isArray(bytes))\n        return getEncodableList(bytes.map((x) => getEncodable(x)));\n    return getEncodableBytes(bytes);\n}\nfunction getEncodableList(list) {\n    const bodyLength = list.reduce((acc, x) => acc + x.length, 0);\n    const sizeOfBodyLength = getSizeOfLength(bodyLength);\n    const length = (() => {\n        if (bodyLength <= 55)\n            return 1 + bodyLength;\n        return 1 + sizeOfBodyLength + bodyLength;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bodyLength <= 55) {\n                cursor.pushByte(0xc0 + bodyLength);\n            }\n            else {\n                cursor.pushByte(0xc0 + 55 + sizeOfBodyLength);\n                if (sizeOfBodyLength === 1)\n                    cursor.pushUint8(bodyLength);\n                else if (sizeOfBodyLength === 2)\n                    cursor.pushUint16(bodyLength);\n                else if (sizeOfBodyLength === 3)\n                    cursor.pushUint24(bodyLength);\n                else\n                    cursor.pushUint32(bodyLength);\n            }\n            for (const { encode } of list) {\n                encode(cursor);\n            }\n        },\n    };\n}\nfunction getEncodableBytes(bytesOrHex) {\n    const bytes = typeof bytesOrHex === 'string' ? _Bytes_js__WEBPACK_IMPORTED_MODULE_1__.fromHex(bytesOrHex) : bytesOrHex;\n    const sizeOfBytesLength = getSizeOfLength(bytes.length);\n    const length = (() => {\n        if (bytes.length === 1 && bytes[0] < 0x80)\n            return 1;\n        if (bytes.length <= 55)\n            return 1 + bytes.length;\n        return 1 + sizeOfBytesLength + bytes.length;\n    })();\n    return {\n        length,\n        encode(cursor) {\n            if (bytes.length === 1 && bytes[0] < 0x80) {\n                cursor.pushBytes(bytes);\n            }\n            else if (bytes.length <= 55) {\n                cursor.pushByte(0x80 + bytes.length);\n                cursor.pushBytes(bytes);\n            }\n            else {\n                cursor.pushByte(0x80 + 55 + sizeOfBytesLength);\n                if (sizeOfBytesLength === 1)\n                    cursor.pushUint8(bytes.length);\n                else if (sizeOfBytesLength === 2)\n                    cursor.pushUint16(bytes.length);\n                else if (sizeOfBytesLength === 3)\n                    cursor.pushUint24(bytes.length);\n                else\n                    cursor.pushUint32(bytes.length);\n                cursor.pushBytes(bytes);\n            }\n        },\n    };\n}\nfunction getSizeOfLength(length) {\n    if (length < 2 ** 8)\n        return 1;\n    if (length < 2 ** 16)\n        return 2;\n    if (length < 2 ** 24)\n        return 3;\n    if (length < 2 ** 32)\n        return 4;\n    throw new _Errors_js__WEBPACK_IMPORTED_MODULE_3__.BaseError('Length is too large.');\n}\n//# sourceMappingURL=Rlp.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUmxwLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0M7QUFDRTtBQUNOO0FBQ2U7QUFDL0M7QUFDQSx5REFBeUQsc0JBQXNCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EseURBQXlELGtCQUFrQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE1BQU07QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixrQkFBa0I7QUFDM0M7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdURBQXNCO0FBQ2hELG1CQUFtQiw4Q0FBYTtBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMLG1CQUFtQix1REFBYTtBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLCtCQUErQiw4Q0FBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw4Q0FBYTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaURBQWdCO0FBQzlCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0IsSUFBSSxrQkFBa0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBLHdGQUF3RixhQUFhO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0IsSUFBSSxrQkFBa0I7QUFDbkU7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLEtBQUs7QUFDakI7QUFDQSxtQkFBbUIsdURBQWE7QUFDaEM7QUFDQTtBQUNBLGVBQWUsOENBQWE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNPLHNDQUFzQztBQUM3QyxZQUFZLGVBQWU7QUFDM0IseUJBQXlCLElBQUk7QUFDN0I7QUFDQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtCQUFrQjtBQUN2QztBQUNBO0FBQ0E7QUFDTyxrQ0FBa0M7QUFDekMsWUFBWSxhQUFhO0FBQ3pCLHVCQUF1QixJQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCw4Q0FBYTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpREFBZ0I7QUFDOUI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21paW5hZG9pL0Rlc2t0b3AvZ2l0aHViUHJvamVjdC90aHJpZHdlYnR1dG9yaWFsL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvUmxwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBDdXJzb3IgZnJvbSAnLi9pbnRlcm5hbC9jdXJzb3IuanMnO1xuLyoqXG4gKiBEZWNvZGVzIGEgUmVjdXJzaXZlLUxlbmd0aCBQcmVmaXggKFJMUCkgdmFsdWUgaW50byBhIHtAbGluayBveCNCeXRlcy5CeXRlc30gdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBSbHAgfSBmcm9tICdveCdcbiAqIFJscC50b0J5dGVzKCcweDhiNjg2NTZjNmM2ZjIwNzc2ZjcyNmM2NCcpXG4gKiAvLyBVaW50OEFycmF5KFsxMzksIDEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB2YWx1ZSB0byBkZWNvZGUuXG4gKiBAcmV0dXJucyBUaGUgZGVjb2RlZCB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9CeXRlcyh2YWx1ZSkge1xuICAgIHJldHVybiB0byh2YWx1ZSwgJ0J5dGVzJyk7XG59XG4vKipcbiAqIERlY29kZXMgYSBSZWN1cnNpdmUtTGVuZ3RoIFByZWZpeCAoUkxQKSB2YWx1ZSBpbnRvIGEge0BsaW5rIG94I0hleC5IZXh9IHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUmxwIH0gZnJvbSAnb3gnXG4gKiBSbHAudG9IZXgoJzB4OGI2ODY1NmM2YzZmMjA3NzZmNzI2YzY0JylcbiAqIC8vIDB4Njg2NTZjNmM2ZjIwNzc2ZjcyNmM2NFxuICogYGBgXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gVGhlIHZhbHVlIHRvIGRlY29kZS5cbiAqIEByZXR1cm5zIFRoZSBkZWNvZGVkIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvKHZhbHVlLCAnSGV4Jyk7XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEludGVybmFsXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiB0byh2YWx1ZSwgdG8pIHtcbiAgICBjb25zdCB0b18gPSB0byA/PyAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/ICdIZXgnIDogJ0J5dGVzJyk7XG4gICAgY29uc3QgYnl0ZXMgPSAoKCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDMgJiYgdmFsdWUubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSGV4LkludmFsaWRMZW5ndGhFcnJvcih2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gQnl0ZXMuZnJvbUhleCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0pKCk7XG4gICAgY29uc3QgY3Vyc29yID0gQ3Vyc29yLmNyZWF0ZShieXRlcywge1xuICAgICAgICByZWN1cnNpdmVSZWFkTGltaXQ6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSBkZWNvZGVSbHBDdXJzb3IoY3Vyc29yLCB0b18pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlUmxwQ3Vyc29yKGN1cnNvciwgdG8gPSAnSGV4Jykge1xuICAgIGlmIChjdXJzb3IuYnl0ZXMubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gKHRvID09PSAnSGV4JyA/IEhleC5mcm9tQnl0ZXMoY3Vyc29yLmJ5dGVzKSA6IGN1cnNvci5ieXRlcyk7XG4gICAgY29uc3QgcHJlZml4ID0gY3Vyc29yLnJlYWRCeXRlKCk7XG4gICAgaWYgKHByZWZpeCA8IDB4ODApXG4gICAgICAgIGN1cnNvci5kZWNyZW1lbnRQb3NpdGlvbigxKTtcbiAgICAvLyBieXRlc1xuICAgIGlmIChwcmVmaXggPCAweGMwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRMZW5ndGgoY3Vyc29yLCBwcmVmaXgsIDB4ODApO1xuICAgICAgICBjb25zdCBieXRlcyA9IGN1cnNvci5yZWFkQnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuICh0byA9PT0gJ0hleCcgPyBIZXguZnJvbUJ5dGVzKGJ5dGVzKSA6IGJ5dGVzKTtcbiAgICB9XG4gICAgLy8gbGlzdFxuICAgIGNvbnN0IGxlbmd0aCA9IHJlYWRMZW5ndGgoY3Vyc29yLCBwcmVmaXgsIDB4YzApO1xuICAgIHJldHVybiByZWFkTGlzdChjdXJzb3IsIGxlbmd0aCwgdG8pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRMZW5ndGgoY3Vyc29yLCBwcmVmaXgsIG9mZnNldCkge1xuICAgIGlmIChvZmZzZXQgPT09IDB4ODAgJiYgcHJlZml4IDwgMHg4MClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKHByZWZpeCA8PSBvZmZzZXQgKyA1NSlcbiAgICAgICAgcmV0dXJuIHByZWZpeCAtIG9mZnNldDtcbiAgICBpZiAocHJlZml4ID09PSBvZmZzZXQgKyA1NSArIDEpXG4gICAgICAgIHJldHVybiBjdXJzb3IucmVhZFVpbnQ4KCk7XG4gICAgaWYgKHByZWZpeCA9PT0gb2Zmc2V0ICsgNTUgKyAyKVxuICAgICAgICByZXR1cm4gY3Vyc29yLnJlYWRVaW50MTYoKTtcbiAgICBpZiAocHJlZml4ID09PSBvZmZzZXQgKyA1NSArIDMpXG4gICAgICAgIHJldHVybiBjdXJzb3IucmVhZFVpbnQyNCgpO1xuICAgIGlmIChwcmVmaXggPT09IG9mZnNldCArIDU1ICsgNClcbiAgICAgICAgcmV0dXJuIGN1cnNvci5yZWFkVWludDMyKCk7XG4gICAgdGhyb3cgbmV3IEVycm9ycy5CYXNlRXJyb3IoJ0ludmFsaWQgUkxQIHByZWZpeCcpO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRMaXN0KGN1cnNvciwgbGVuZ3RoLCB0bykge1xuICAgIGNvbnN0IHBvc2l0aW9uID0gY3Vyc29yLnBvc2l0aW9uO1xuICAgIGNvbnN0IHZhbHVlID0gW107XG4gICAgd2hpbGUgKGN1cnNvci5wb3NpdGlvbiAtIHBvc2l0aW9uIDwgbGVuZ3RoKVxuICAgICAgICB2YWx1ZS5wdXNoKGRlY29kZVJscEN1cnNvcihjdXJzb3IsIHRvKSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBvciB7QGxpbmsgb3gjSGV4LkhleH0gdmFsdWUgaW50byBhIFJlY3Vyc2l2ZS1MZW5ndGggUHJlZml4IChSTFApIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgQnl0ZXMsIFJscCB9IGZyb20gJ294J1xuICpcbiAqIFJscC5mcm9tKCcweDY4NjU2YzZjNmYyMDc3NmY3MjZjNjQnLCB7IGFzOiAnSGV4JyB9KVxuICogLy8gQGxvZzogMHg4YjY4NjU2YzZjNmYyMDc3NmY3MjZjNjRcbiAqXG4gKiBSbHAuZnJvbShCeXRlcy5mcm9tKFsxMzksIDEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSksIHsgYXM6ICdCeXRlcycgfSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkoWzEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9IG9yIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgUkxQIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgYXMgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW5jb2RhYmxlID0gZ2V0RW5jb2RhYmxlKHZhbHVlKTtcbiAgICBjb25zdCBjdXJzb3IgPSBDdXJzb3IuY3JlYXRlKG5ldyBVaW50OEFycmF5KGVuY29kYWJsZS5sZW5ndGgpKTtcbiAgICBlbmNvZGFibGUuZW5jb2RlKGN1cnNvcik7XG4gICAgaWYgKGFzID09PSAnSGV4JylcbiAgICAgICAgcmV0dXJuIEhleC5mcm9tQnl0ZXMoY3Vyc29yLmJ5dGVzKTtcbiAgICByZXR1cm4gY3Vyc29yLmJ5dGVzO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSBpbnRvIGEgUmVjdXJzaXZlLUxlbmd0aCBQcmVmaXggKFJMUCkgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBCeXRlcywgUmxwIH0gZnJvbSAnb3gnXG4gKlxuICogUmxwLmZyb21CeXRlcyhCeXRlcy5mcm9tKFsxMzksIDEwNCwgMTAxLCAxMDgsIDEwOCwgMTExLCAgMzIsIDExOSwgMTExLCAxMTQsIDEwOCwgMTAwXSkpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5KFsxMDQsIDEwMSwgMTA4LCAxMDgsIDExMSwgIDMyLCAxMTksIDExMSwgMTE0LCAxMDgsIDEwMF0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gYnl0ZXMgLSBUaGUge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgUkxQIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUJ5dGVzKGJ5dGVzLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzID0gJ0J5dGVzJyB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gZnJvbShieXRlcywgeyBhcyB9KTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSBpbnRvIGEgUmVjdXJzaXZlLUxlbmd0aCBQcmVmaXggKFJMUCkgdmFsdWUuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBSbHAgfSBmcm9tICdveCdcbiAqXG4gKiBSbHAuZnJvbUhleCgnMHg2ODY1NmM2YzZmMjA3NzZmNzI2YzY0JylcbiAqIC8vIEBsb2c6IDB4OGI2ODY1NmM2YzZmMjA3NzZmNzI2YzY0XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaGV4IC0gVGhlIHtAbGluayBveCNIZXguSGV4fSB2YWx1ZSB0byBlbmNvZGUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgUkxQIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUhleChoZXgsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgYXMgPSAnSGV4JyB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gZnJvbShoZXgsIHsgYXMgfSk7XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEludGVybmFsXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGdldEVuY29kYWJsZShieXRlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGJ5dGVzKSlcbiAgICAgICAgcmV0dXJuIGdldEVuY29kYWJsZUxpc3QoYnl0ZXMubWFwKCh4KSA9PiBnZXRFbmNvZGFibGUoeCkpKTtcbiAgICByZXR1cm4gZ2V0RW5jb2RhYmxlQnl0ZXMoYnl0ZXMpO1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RhYmxlTGlzdChsaXN0KSB7XG4gICAgY29uc3QgYm9keUxlbmd0aCA9IGxpc3QucmVkdWNlKChhY2MsIHgpID0+IGFjYyArIHgubGVuZ3RoLCAwKTtcbiAgICBjb25zdCBzaXplT2ZCb2R5TGVuZ3RoID0gZ2V0U2l6ZU9mTGVuZ3RoKGJvZHlMZW5ndGgpO1xuICAgIGNvbnN0IGxlbmd0aCA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChib2R5TGVuZ3RoIDw9IDU1KVxuICAgICAgICAgICAgcmV0dXJuIDEgKyBib2R5TGVuZ3RoO1xuICAgICAgICByZXR1cm4gMSArIHNpemVPZkJvZHlMZW5ndGggKyBib2R5TGVuZ3RoO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBlbmNvZGUoY3Vyc29yKSB7XG4gICAgICAgICAgICBpZiAoYm9keUxlbmd0aCA8PSA1NSkge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZSgweGMwICsgYm9keUxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJzb3IucHVzaEJ5dGUoMHhjMCArIDU1ICsgc2l6ZU9mQm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgaWYgKHNpemVPZkJvZHlMZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDgoYm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MTYoYm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZU9mQm9keUxlbmd0aCA9PT0gMylcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MjQoYm9keUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IucHVzaFVpbnQzMihib2R5TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBlbmNvZGUgfSBvZiBsaXN0KSB7XG4gICAgICAgICAgICAgICAgZW5jb2RlKGN1cnNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEVuY29kYWJsZUJ5dGVzKGJ5dGVzT3JIZXgpIHtcbiAgICBjb25zdCBieXRlcyA9IHR5cGVvZiBieXRlc09ySGV4ID09PSAnc3RyaW5nJyA/IEJ5dGVzLmZyb21IZXgoYnl0ZXNPckhleCkgOiBieXRlc09ySGV4O1xuICAgIGNvbnN0IHNpemVPZkJ5dGVzTGVuZ3RoID0gZ2V0U2l6ZU9mTGVuZ3RoKGJ5dGVzLmxlbmd0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gKCgpID0+IHtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gMSAmJiBieXRlc1swXSA8IDB4ODApXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA8PSA1NSlcbiAgICAgICAgICAgIHJldHVybiAxICsgYnl0ZXMubGVuZ3RoO1xuICAgICAgICByZXR1cm4gMSArIHNpemVPZkJ5dGVzTGVuZ3RoICsgYnl0ZXMubGVuZ3RoO1xuICAgIH0pKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBlbmNvZGUoY3Vyc29yKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoID09PSAxICYmIGJ5dGVzWzBdIDwgMHg4MCkge1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZXMoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoIDw9IDU1KSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDB4ODAgKyBieXRlcy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoQnl0ZXMoYnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlKDB4ODAgKyA1NSArIHNpemVPZkJ5dGVzTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6ZU9mQnl0ZXNMZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDgoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMilcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MTYoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzaXplT2ZCeXRlc0xlbmd0aCA9PT0gMylcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hVaW50MjQoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5wdXNoVWludDMyKGJ5dGVzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnB1c2hCeXRlcyhieXRlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFNpemVPZkxlbmd0aChsZW5ndGgpIHtcbiAgICBpZiAobGVuZ3RoIDwgMiAqKiA4KVxuICAgICAgICByZXR1cm4gMTtcbiAgICBpZiAobGVuZ3RoIDwgMiAqKiAxNilcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgaWYgKGxlbmd0aCA8IDIgKiogMjQpXG4gICAgICAgIHJldHVybiAzO1xuICAgIGlmIChsZW5ndGggPCAyICoqIDMyKVxuICAgICAgICByZXR1cm4gNDtcbiAgICB0aHJvdyBuZXcgRXJyb3JzLkJhc2VFcnJvcignTGVuZ3RoIGlzIHRvbyBsYXJnZS4nKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJscC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js":
/*!************************************************!*\
  !*** ./node_modules/ox/_esm/core/Signature.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidRError: () => (/* binding */ InvalidRError),\n/* harmony export */   InvalidSError: () => (/* binding */ InvalidSError),\n/* harmony export */   InvalidSerializedSizeError: () => (/* binding */ InvalidSerializedSizeError),\n/* harmony export */   InvalidVError: () => (/* binding */ InvalidVError),\n/* harmony export */   InvalidYParityError: () => (/* binding */ InvalidYParityError),\n/* harmony export */   MissingPropertiesError: () => (/* binding */ MissingPropertiesError),\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   extract: () => (/* binding */ extract),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromBytes: () => (/* binding */ fromBytes),\n/* harmony export */   fromDerBytes: () => (/* binding */ fromDerBytes),\n/* harmony export */   fromDerHex: () => (/* binding */ fromDerHex),\n/* harmony export */   fromHex: () => (/* binding */ fromHex),\n/* harmony export */   fromLegacy: () => (/* binding */ fromLegacy),\n/* harmony export */   fromRpc: () => (/* binding */ fromRpc),\n/* harmony export */   fromTuple: () => (/* binding */ fromTuple),\n/* harmony export */   toBytes: () => (/* binding */ toBytes),\n/* harmony export */   toDerBytes: () => (/* binding */ toDerBytes),\n/* harmony export */   toDerHex: () => (/* binding */ toDerHex),\n/* harmony export */   toHex: () => (/* binding */ toHex),\n/* harmony export */   toLegacy: () => (/* binding */ toLegacy),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   toTuple: () => (/* binding */ toTuple),\n/* harmony export */   vToYParity: () => (/* binding */ vToYParity),\n/* harmony export */   validate: () => (/* binding */ validate),\n/* harmony export */   yParityToV: () => (/* binding */ yParityToV)\n/* harmony export */ });\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n/* harmony import */ var _Bytes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Bytes.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Bytes.js\");\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Json_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Json.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Json.js\");\n/* harmony import */ var _Solidity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Solidity.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Solidity.js\");\n\n\n\n\n\n\n/**\n * Asserts that a Signature is valid.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.assert({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @error: InvalidSignatureRError:\n * // @error: Value `-549...n` is an invalid r value.\n * // @error: r must be a positive integer less than 2^256.\n * ```\n *\n * @param signature - The signature object to assert.\n */\nfunction assert(signature, options = {}) {\n    const { recovered } = options;\n    if (typeof signature.r === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (typeof signature.s === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (recovered && typeof signature.yParity === 'undefined')\n        throw new MissingPropertiesError({ signature });\n    if (signature.r < 0n || signature.r > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256)\n        throw new InvalidRError({ value: signature.r });\n    if (signature.s < 0n || signature.s > _Solidity_js__WEBPACK_IMPORTED_MODULE_0__.maxUint256)\n        throw new InvalidSError({ value: signature.s });\n    if (typeof signature.yParity === 'number' &&\n        signature.yParity !== 0 &&\n        signature.yParity !== 1)\n        throw new InvalidYParityError({ value: signature.yParity });\n}\n/**\n * Deserializes a {@link ox#Bytes.Bytes} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.fromBytes(new Uint8Array([128, 3, 131, ...]))\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param signature - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nfunction fromBytes(signature) {\n    return fromHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Deserializes a {@link ox#Hex.Hex} signature into a structured {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.fromHex('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c')\n * // @log: { r: 5231...n, s: 3522...n, yParity: 0 }\n * ```\n *\n * @param serialized - The serialized signature.\n * @returns The deserialized {@link ox#Signature.Signature}.\n */\nfunction fromHex(signature) {\n    if (signature.length !== 130 && signature.length !== 132)\n        throw new InvalidSerializedSizeError({ signature });\n    const r = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 0, 32));\n    const s = BigInt(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.slice(signature, 32, 64));\n    const yParity = (() => {\n        const yParity = Number(`0x${signature.slice(130)}`);\n        if (Number.isNaN(yParity))\n            return undefined;\n        try {\n            return vToYParity(yParity);\n        }\n        catch {\n            throw new InvalidYParityError({ value: yParity });\n        }\n    })();\n    if (typeof yParity === 'undefined')\n        return {\n            r,\n            s,\n        };\n    return {\n        r,\n        s,\n        yParity,\n    };\n}\n/**\n * Extracts a {@link ox#Signature.Signature} from an arbitrary object that may include signature properties.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * Signature.extract({\n *   baz: 'barry',\n *   foo: 'bar',\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n *   zebra: 'stripes',\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @param value - The arbitrary object to extract the signature from.\n * @returns The extracted {@link ox#Signature.Signature}.\n */\nfunction extract(value) {\n    if (typeof value.r === 'undefined')\n        return undefined;\n    if (typeof value.s === 'undefined')\n        return undefined;\n    return from(value);\n}\n/**\n * Instantiates a typed {@link ox#Signature.Signature} object from a {@link ox#Signature.Signature}, {@link ox#Signature.Legacy}, {@link ox#Bytes.Bytes}, or {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from('0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db801')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @example\n * ### From Legacy\n *\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * Signature.from({\n *   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n *   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n *   v: 27,\n * })\n * // @log: {\n * // @log:   r: 47323457007453657207889730243826965761922296599680473886588287015755652701072n,\n * // @log:   s: 57228803202727131502949358313456071280488184270258293674242124340113824882788n,\n * // @log:   yParity: 0\n * // @log: }\n * ```\n *\n * @param signature - The signature value to instantiate.\n * @returns The instantiated {@link ox#Signature.Signature}.\n */\nfunction from(signature) {\n    const signature_ = (() => {\n        if (typeof signature === 'string')\n            return fromHex(signature);\n        if (signature instanceof Uint8Array)\n            return fromBytes(signature);\n        if (typeof signature.r === 'string')\n            return fromRpc(signature);\n        if (signature.v)\n            return fromLegacy(signature);\n        return {\n            r: signature.r,\n            s: signature.s,\n            ...(typeof signature.yParity !== 'undefined'\n                ? { yParity: signature.yParity }\n                : {}),\n        };\n    })();\n    assert(signature_);\n    return signature_;\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerBytes(new Uint8Array([132, 51, 23, ...]))\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromDerBytes(signature) {\n    return fromDerHex(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromBytes(signature));\n}\n/**\n * Converts a DER-encoded signature to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromDerHex('0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8')\n * // @log: {\n * // @log:   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n * // @log:   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * // @log: }\n * ```\n *\n * @param signature - The DER-encoded signature to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromDerHex(signature) {\n    const { r, s } = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature.fromDER(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature).slice(2));\n    return { r, s };\n}\n/**\n * Converts a {@link ox#Signature.Legacy} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.fromLegacy({ r: 1n, s: 2n, v: 28 })\n * // @log: { r: 1n, s: 2n, yParity: 1 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Legacy} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nfunction fromLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        yParity: vToYParity(signature.v),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Rpc} into a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromRpc({\n *   r: '0x635dc2033e60185bb36709c29c75d64ea51dfbd91c32ef4be198e4ceb169fb4d',\n *   s: '0x50c2667ac4c771072746acfdcf1f1483336dcca8bd2df47cd83175dbe60f0540',\n *   yParity: '0x0',\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Rpc} to convert.\n * @returns The converted {@link ox#Signature.Signature}.\n */\nfunction fromRpc(signature) {\n    const yParity = (() => {\n        const v = signature.v ? Number(signature.v) : undefined;\n        let yParity = signature.yParity ? Number(signature.yParity) : undefined;\n        if (typeof v === 'number' && typeof yParity !== 'number')\n            yParity = vToYParity(v);\n        if (typeof yParity !== 'number')\n            throw new InvalidYParityError({ value: signature.yParity });\n        return yParity;\n    })();\n    return {\n        r: BigInt(signature.r),\n        s: BigInt(signature.s),\n        yParity,\n    };\n}\n/**\n * Converts a {@link ox#Signature.Tuple} to a {@link ox#Signature.Signature}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.fromTuple(['0x01', '0x7b', '0x1c8'])\n * // @log: {\n * // @log:   r: 123n,\n * // @log:   s: 456n,\n * // @log:   yParity: 1,\n * // @log: }\n * ```\n *\n * @param tuple - The {@link ox#Signature.Tuple} to convert.\n * @returns The {@link ox#Signature.Signature}.\n */\nfunction fromTuple(tuple) {\n    const [yParity, r, s] = tuple;\n    return from({\n        r: r === '0x' ? 0n : BigInt(r),\n        s: s === '0x' ? 0n : BigInt(s),\n        yParity: yParity === '0x' ? 0 : Number(yParity),\n    });\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Bytes.Bytes}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toBytes({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: Uint8Array [102, 16, 10, ...]\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nfunction toBytes(signature) {\n    return _Bytes_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(toHex(signature));\n}\n/**\n * Serializes a {@link ox#Signature.Signature} to {@link ox#Hex.Hex}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toHex({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * // @log: '0x6e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf4a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db81c'\n * ```\n *\n * @param signature - The signature to serialize.\n * @returns The serialized signature.\n */\nfunction toHex(signature) {\n    assert(signature);\n    const r = signature.r;\n    const s = signature.s;\n    const signature_ = _Hex_js__WEBPACK_IMPORTED_MODULE_1__.concat(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, { size: 32 }), _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, { size: 32 }), \n    // If the signature is recovered, add the recovery byte to the signature.\n    typeof signature.yParity === 'number'\n        ? _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(yParityToV(signature.yParity), { size: 1 })\n        : '0x');\n    return signature_;\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerBytes(signature)\n * // @log: Uint8Array [132, 51, 23, ...]\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nfunction toDerBytes(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return sig.toDERRawBytes();\n}\n/**\n * Converts a {@link ox#Signature.Signature} to DER-encoded format.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.from({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n * })\n *\n * const signature_der = Signature.toDerHex(signature)\n * // @log: '0x304402206e100a352ec6ad1b70802290e18aeed190704973570f3b8ed42cb9808e2ea6bf02204a90a229a244495b41890987806fcbd2d5d23fc0dbe5f5256c2613c039d76db8'\n * ```\n *\n * @param signature - The signature to convert.\n * @returns The DER-encoded signature.\n */\nfunction toDerHex(signature) {\n    const sig = new _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_2__.secp256k1.Signature(signature.r, signature.s);\n    return `0x${sig.toDERHex()}`;\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Legacy}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const legacy = Signature.toLegacy({ r: 1n, s: 2n, yParity: 1 })\n * // @log: { r: 1n, s: 2n, v: 28 }\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Legacy}.\n */\nfunction toLegacy(signature) {\n    return {\n        r: signature.r,\n        s: signature.s,\n        v: yParityToV(signature.yParity),\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} into a {@link ox#Signature.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signature = Signature.toRpc({\n *   r: 49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1\n * })\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The converted {@link ox#Signature.Rpc}.\n */\nfunction toRpc(signature) {\n    const { r, s, yParity } = signature;\n    return {\n        r: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r, { size: 32 }),\n        s: _Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s, { size: 32 }),\n        yParity: yParity === 0 ? '0x0' : '0x1',\n    };\n}\n/**\n * Converts a {@link ox#Signature.Signature} to a serialized {@link ox#Signature.Tuple} to be used for signatures in Transaction Envelopes, EIP-7702 Authorization Lists, etc.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const signatureTuple = Signature.toTuple({\n *   r: 123n,\n *   s: 456n,\n *   yParity: 1,\n * })\n * // @log: [yParity: '0x01', r: '0x7b', s: '0x1c8']\n * ```\n *\n * @param signature - The {@link ox#Signature.Signature} to convert.\n * @returns The {@link ox#Signature.Tuple}.\n */\nfunction toTuple(signature) {\n    const { r, s, yParity } = signature;\n    return [\n        yParity ? '0x01' : '0x',\n        r === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(r)),\n        s === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_1__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.fromNumber(s)),\n    ];\n}\n/**\n * Validates a Signature. Returns `true` if the signature is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const valid = Signature.validate({\n *   r: -49782753348462494199823712700004552394425719014458918871452329774910450607807n,\n *   s: 33726695977844476214676913201140481102225469284307016937915595756355928419768n,\n *   yParity: 1,\n * })\n * // @log: false\n * ```\n *\n * @param signature - The signature object to assert.\n */\nfunction validate(signature, options = {}) {\n    try {\n        assert(signature, options);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const yParity = Signature.vToYParity(28)\n * // @log: 1\n * ```\n *\n * @param v - The ECDSA `v` value to convert.\n * @returns The `yParity` value.\n */\nfunction vToYParity(v) {\n    if (v === 0 || v === 27)\n        return 0;\n    if (v === 1 || v === 28)\n        return 1;\n    if (v >= 35)\n        return v % 2 === 0 ? 1 : 0;\n    throw new InvalidVError({ value: v });\n}\n/**\n * Converts a ECDSA `v` value to a `yParity` value.\n *\n * @example\n * ```ts twoslash\n * import { Signature } from 'ox'\n *\n * const v = Signature.yParityToV(1)\n * // @log: 28\n * ```\n *\n * @param yParity - The ECDSA `yParity` value to convert.\n * @returns The `v` value.\n */\nfunction yParityToV(yParity) {\n    if (yParity === 0)\n        return 27;\n    if (yParity === 1)\n        return 28;\n    throw new InvalidYParityError({ value: yParity });\n}\n/** Thrown when the serialized signature is of an invalid size. */\nclass InvalidSerializedSizeError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }) {\n        super(`Value \\`${signature}\\` is an invalid signature size.`, {\n            metaMessages: [\n                'Expected: 64 bytes or 65 bytes.',\n                `Received ${_Hex_js__WEBPACK_IMPORTED_MODULE_1__.size(_Hex_js__WEBPACK_IMPORTED_MODULE_1__.from(signature))} bytes.`,\n            ],\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSerializedSizeError'\n        });\n    }\n}\n/** Thrown when the signature is missing either an `r`, `s`, or `yParity` property. */\nclass MissingPropertiesError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ signature }) {\n        super(`Signature \\`${_Json_js__WEBPACK_IMPORTED_MODULE_5__.stringify(signature)}\\` is missing either an \\`r\\`, \\`s\\`, or \\`yParity\\` property.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.MissingPropertiesError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `r` value. */\nclass InvalidRError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid r value. r must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidRError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `s` value. */\nclass InvalidSError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid s value. s must be a positive integer less than 2^256.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidSError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `yParity` value. */\nclass InvalidYParityError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid y-parity value. Y-parity must be 0 or 1.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidYParityError'\n        });\n    }\n}\n/** Thrown when the signature has an invalid `v` value. */\nclass InvalidVError extends _Errors_js__WEBPACK_IMPORTED_MODULE_4__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is an invalid v value. v must be 27, 28 or >=35.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Signature.InvalidVError'\n        });\n    }\n}\n//# sourceMappingURL=Signature.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU2lnbmF0dXJlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ2hCO0FBQ0U7QUFDTjtBQUNFO0FBQ1E7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sdUNBQXVDO0FBQzlDLFlBQVksWUFBWTtBQUN4QjtBQUNBLDJDQUEyQyxXQUFXO0FBQ3REO0FBQ0EsMkNBQTJDLFdBQVc7QUFDdEQ7QUFDQSwyQ0FBMkMsV0FBVztBQUN0RCwwQ0FBMEMsb0RBQW1CO0FBQzdELGtDQUFrQyxvQkFBb0I7QUFDdEQsMENBQTBDLG9EQUFtQjtBQUM3RCxrQ0FBa0Msb0JBQW9CO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QywwQkFBMEI7QUFDbEU7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0IsNkJBQTZCLDZCQUE2QjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDTztBQUNQLG1CQUFtQiw4Q0FBYTtBQUNoQztBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQiw2QkFBNkIsNkJBQTZCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDTztBQUNQO0FBQ0EsK0NBQStDLFdBQVc7QUFDMUQscUJBQXFCLDBDQUFTO0FBQzlCLHFCQUFxQiwwQ0FBUztBQUM5QjtBQUNBLG9DQUFvQyxxQkFBcUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw4QkFBOEIsZUFBZSw2QkFBNkIsR0FBRywwQkFBMEIsR0FBRyxxQkFBcUIsTUFBTSxpQkFBaUI7QUFDL0s7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNkJBQTZCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDTztBQUNQLHNCQUFzQiw4Q0FBYTtBQUNuQztBQUNBO0FBQ0EsMENBQTBDLDZCQUE2QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNPO0FBQ1AsWUFBWSxPQUFPLEVBQUUsOERBQVMsbUJBQW1CLHlDQUFRO0FBQ3pELGFBQWE7QUFDYjtBQUNBO0FBQ0EsZUFBZSwyQkFBMkIsUUFBUSw2QkFBNkI7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0EseUNBQXlDLHFCQUFxQjtBQUM5RCxjQUFjO0FBQ2Q7QUFDQTtBQUNBLDJCQUEyQiwyQkFBMkI7QUFDdEQsMkJBQTJCLDZCQUE2QjtBQUN4RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QixRQUFRLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkJBQTJCLHdCQUF3QjtBQUNuRCwyQkFBMkIsNkJBQTZCO0FBQ3hEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMEJBQTBCO0FBQ3RFO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEIsTUFBTSw2QkFBNkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQsaUJBQWlCLDZCQUE2QjtBQUM5QztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUJBQWlCLDhCQUE4QixJQUFJLHFCQUFxQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsOENBQWE7QUFDeEI7QUFDQTtBQUNBLGlCQUFpQiw4QkFBOEIsSUFBSSxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMkNBQVUsQ0FBQywrQ0FBYyxNQUFNLFVBQVUsR0FBRywrQ0FBYyxNQUFNLFVBQVU7QUFDakc7QUFDQTtBQUNBLFVBQVUsK0NBQWMsa0NBQWtDLFNBQVM7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDhCQUE4QjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0JBQW9CLDhEQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxvQkFBb0IsOERBQVM7QUFDN0IsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBLGVBQWUsOEJBQThCLFFBQVEsMEJBQTBCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBLHVDQUF1QywwQkFBMEI7QUFDakUsY0FBYztBQUNkO0FBQ0E7QUFDQSwyQkFBMkIsOEJBQThCO0FBQ3pELDJCQUEyQiwwQkFBMEI7QUFDckQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEIsUUFBUSx1QkFBdUI7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQsMkJBQTJCLHVCQUF1QjtBQUNsRDtBQUNPO0FBQ1AsWUFBWSxnQkFBZ0I7QUFDNUI7QUFDQSxXQUFXLCtDQUFjLE1BQU0sVUFBVTtBQUN6QyxXQUFXLCtDQUFjLE1BQU0sVUFBVTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCLGlCQUFpQiwwQkFBMEI7QUFDeEY7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhCQUE4QjtBQUN6RCxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ087QUFDUCxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBO0FBQ0EsMEJBQTBCLDZDQUFZLENBQUMsK0NBQWM7QUFDckQsMEJBQTBCLDZDQUFZLENBQUMsK0NBQWM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08seUNBQXlDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxZQUFZO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksWUFBWTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxnQkFBZ0I7QUFDcEQ7QUFDQTtBQUNPLHlDQUF5QyxpREFBZ0I7QUFDaEUsa0JBQWtCLFdBQVc7QUFDN0IseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBLDRCQUE0Qix5Q0FBUSxDQUFDLHlDQUFRLGNBQWM7QUFDM0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyxxQ0FBcUMsaURBQWdCO0FBQzVELGtCQUFrQixXQUFXO0FBQzdCLDZCQUE2QiwrQ0FBYyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLGlEQUFnQjtBQUNuRCxrQkFBa0IsT0FBTztBQUN6Qix5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixpREFBZ0I7QUFDbkQsa0JBQWtCLE9BQU87QUFDekIseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTyxrQ0FBa0MsaURBQWdCO0FBQ3pELGtCQUFrQixPQUFPO0FBQ3pCLHlCQUF5QixNQUFNO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sNEJBQTRCLGlEQUFnQjtBQUNuRCxrQkFBa0IsT0FBTztBQUN6Qix5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21paW5hZG9pL0Rlc2t0b3AvZ2l0aHViUHJvamVjdC90aHJpZHdlYnR1dG9yaWFsL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvU2lnbmF0dXJlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHNlY3AyNTZrMSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvc2VjcDI1NmsxJztcbmltcG9ydCAqIGFzIEJ5dGVzIGZyb20gJy4vQnl0ZXMuanMnO1xuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBKc29uIGZyb20gJy4vSnNvbi5qcyc7XG5pbXBvcnQgKiBhcyBTb2xpZGl0eSBmcm9tICcuL1NvbGlkaXR5LmpzJztcbi8qKlxuICogQXNzZXJ0cyB0aGF0IGEgU2lnbmF0dXJlIGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmFzc2VydCh7XG4gKiAgIHI6IC00OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEludmFsaWRTaWduYXR1cmVSRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFZhbHVlIGAtNTQ5Li4ubmAgaXMgYW4gaW52YWxpZCByIHZhbHVlLlxuICogLy8gQGVycm9yOiByIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGxlc3MgdGhhbiAyXjI1Ni5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIG9iamVjdCB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoc2lnbmF0dXJlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHJlY292ZXJlZCB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHNpZ25hdHVyZS5yID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IoeyBzaWduYXR1cmUgfSk7XG4gICAgaWYgKHR5cGVvZiBzaWduYXR1cmUucyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBNaXNzaW5nUHJvcGVydGllc0Vycm9yKHsgc2lnbmF0dXJlIH0pO1xuICAgIGlmIChyZWNvdmVyZWQgJiYgdHlwZW9mIHNpZ25hdHVyZS55UGFyaXR5ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IoeyBzaWduYXR1cmUgfSk7XG4gICAgaWYgKHNpZ25hdHVyZS5yIDwgMG4gfHwgc2lnbmF0dXJlLnIgPiBTb2xpZGl0eS5tYXhVaW50MjU2KVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUuciB9KTtcbiAgICBpZiAoc2lnbmF0dXJlLnMgPCAwbiB8fCBzaWduYXR1cmUucyA+IFNvbGlkaXR5Lm1heFVpbnQyNTYpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkU0Vycm9yKHsgdmFsdWU6IHNpZ25hdHVyZS5zIH0pO1xuICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnlQYXJpdHkgPT09ICdudW1iZXInICYmXG4gICAgICAgIHNpZ25hdHVyZS55UGFyaXR5ICE9PSAwICYmXG4gICAgICAgIHNpZ25hdHVyZS55UGFyaXR5ICE9PSAxKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFlQYXJpdHlFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUueVBhcml0eSB9KTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I0J5dGVzLkJ5dGVzfSBzaWduYXR1cmUgaW50byBhIHN0cnVjdHVyZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5KFsxMjgsIDMsIDEzMSwgLi4uXSkpXG4gKiAvLyBAbG9nOiB7IHI6IDUyMzEuLi5uLCBzOiAzNTIyLi4ubiwgeVBhcml0eTogMCB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlIGRlc2VyaWFsaXplZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGZyb21IZXgoSGV4LmZyb21CeXRlcyhzaWduYXR1cmUpKTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I0hleC5IZXh9IHNpZ25hdHVyZSBpbnRvIGEgc3RydWN0dXJlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbUhleCgnMHg2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiODFjJylcbiAqIC8vIEBsb2c6IHsgcjogNTIzMS4uLm4sIHM6IDM1MjIuLi5uLCB5UGFyaXR5OiAwIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZXJpYWxpemVkIC0gVGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlLlxuICogQHJldHVybnMgVGhlIGRlc2VyaWFsaXplZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSGV4KHNpZ25hdHVyZSkge1xuICAgIGlmIChzaWduYXR1cmUubGVuZ3RoICE9PSAxMzAgJiYgc2lnbmF0dXJlLmxlbmd0aCAhPT0gMTMyKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNlcmlhbGl6ZWRTaXplRXJyb3IoeyBzaWduYXR1cmUgfSk7XG4gICAgY29uc3QgciA9IEJpZ0ludChIZXguc2xpY2Uoc2lnbmF0dXJlLCAwLCAzMikpO1xuICAgIGNvbnN0IHMgPSBCaWdJbnQoSGV4LnNsaWNlKHNpZ25hdHVyZSwgMzIsIDY0KSk7XG4gICAgY29uc3QgeVBhcml0eSA9ICgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHlQYXJpdHkgPSBOdW1iZXIoYDB4JHtzaWduYXR1cmUuc2xpY2UoMTMwKX1gKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTih5UGFyaXR5KSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdlRvWVBhcml0eSh5UGFyaXR5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFlQYXJpdHlFcnJvcih7IHZhbHVlOiB5UGFyaXR5IH0pO1xuICAgICAgICB9XG4gICAgfSkoKTtcbiAgICBpZiAodHlwZW9mIHlQYXJpdHkgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcixcbiAgICAgICAgICAgIHMsXG4gICAgICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcixcbiAgICAgICAgcyxcbiAgICAgICAgeVBhcml0eSxcbiAgICB9O1xufVxuLyoqXG4gKiBFeHRyYWN0cyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSBmcm9tIGFuIGFyYml0cmFyeSBvYmplY3QgdGhhdCBtYXkgaW5jbHVkZSBzaWduYXR1cmUgcHJvcGVydGllcy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmV4dHJhY3Qoe1xuICogICBiYXo6ICdiYXJyeScsXG4gKiAgIGZvbzogJ2JhcicsXG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxLFxuICogICB6ZWJyYTogJ3N0cmlwZXMnLFxuICogfSlcbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogLy8gQGxvZzogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDFcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBhcmJpdHJhcnkgb2JqZWN0IHRvIGV4dHJhY3QgdGhlIHNpZ25hdHVyZSBmcm9tLlxuICogQHJldHVybnMgVGhlIGV4dHJhY3RlZCB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZS5yID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHZhbHVlLnMgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIHJldHVybiBmcm9tKHZhbHVlKTtcbn1cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgdHlwZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IG9iamVjdCBmcm9tIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LCB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0sIHtAbGluayBveCNCeXRlcy5CeXRlc30sIG9yIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIFNpZ25hdHVyZS5mcm9tKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiB9KVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAvLyBAbG9nOiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMVxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogU2lnbmF0dXJlLmZyb20oJzB4NmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgwMScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAxLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIExlZ2FjeVxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBTaWduYXR1cmUuZnJvbSh7XG4gKiAgIHI6IDQ3MzIzNDU3MDA3NDUzNjU3MjA3ODg5NzMwMjQzODI2OTY1NzYxOTIyMjk2NTk5NjgwNDczODg2NTg4Mjg3MDE1NzU1NjUyNzAxMDcybixcbiAqICAgczogNTcyMjg4MDMyMDI3MjcxMzE1MDI5NDkzNTgzMTM0NTYwNzEyODA0ODgxODQyNzAyNTgyOTM2NzQyNDIxMjQzNDAxMTM4MjQ4ODI3ODhuLFxuICogICB2OiAyNyxcbiAqIH0pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ3MzIzNDU3MDA3NDUzNjU3MjA3ODg5NzMwMjQzODI2OTY1NzYxOTIyMjk2NTk5NjgwNDczODg2NTg4Mjg3MDE1NzU1NjUyNzAxMDcybixcbiAqIC8vIEBsb2c6ICAgczogNTcyMjg4MDMyMDI3MjcxMzE1MDI5NDkzNTgzMTM0NTYwNzEyODA0ODgxODQyNzAyNTgyOTM2NzQyNDIxMjQzNDAxMTM4MjQ4ODI3ODhuLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB2YWx1ZSB0byBpbnN0YW50aWF0ZS5cbiAqIEByZXR1cm5zIFRoZSBpbnN0YW50aWF0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWduYXR1cmVfID0gKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21IZXgoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpXG4gICAgICAgICAgICByZXR1cm4gZnJvbUJ5dGVzKHNpZ25hdHVyZSk7XG4gICAgICAgIGlmICh0eXBlb2Ygc2lnbmF0dXJlLnIgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGZyb21ScGMoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZS52KVxuICAgICAgICAgICAgcmV0dXJuIGZyb21MZWdhY3koc2lnbmF0dXJlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHNpZ25hdHVyZS5yLFxuICAgICAgICAgICAgczogc2lnbmF0dXJlLnMsXG4gICAgICAgICAgICAuLi4odHlwZW9mIHNpZ25hdHVyZS55UGFyaXR5ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8geyB5UGFyaXR5OiBzaWduYXR1cmUueVBhcml0eSB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH07XG4gICAgfSkoKTtcbiAgICBhc3NlcnQoc2lnbmF0dXJlXyk7XG4gICAgcmV0dXJuIHNpZ25hdHVyZV87XG59XG4vKipcbiAqIENvbnZlcnRzIGEgREVSLWVuY29kZWQgc2lnbmF0dXJlIHRvIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbURlckJ5dGVzKG5ldyBVaW50OEFycmF5KFsxMzIsIDUxLCAyMywgLi4uXSkpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBERVItZW5jb2RlZCBzaWduYXR1cmUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRGVyQnl0ZXMoc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGZyb21EZXJIZXgoSGV4LmZyb21CeXRlcyhzaWduYXR1cmUpKTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBERVItZW5jb2RlZCBzaWduYXR1cmUgdG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbURlckhleCgnMHgzMDQ0MDIyMDZlMTAwYTM1MmVjNmFkMWI3MDgwMjI5MGUxOGFlZWQxOTA3MDQ5NzM1NzBmM2I4ZWQ0MmNiOTgwOGUyZWE2YmYwMjIwNGE5MGEyMjlhMjQ0NDk1YjQxODkwOTg3ODA2ZmNiZDJkNWQyM2ZjMGRiZTVmNTI1NmMyNjEzYzAzOWQ3NmRiOCcpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqIC8vIEBsb2c6ICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBERVItZW5jb2RlZCBzaWduYXR1cmUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tRGVySGV4KHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHsgciwgcyB9ID0gc2VjcDI1NmsxLlNpZ25hdHVyZS5mcm9tREVSKEhleC5mcm9tKHNpZ25hdHVyZSkuc2xpY2UoMikpO1xuICAgIHJldHVybiB7IHIsIHMgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0gaW50byBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGxlZ2FjeSA9IFNpZ25hdHVyZS5mcm9tTGVnYWN5KHsgcjogMW4sIHM6IDJuLCB2OiAyOCB9KVxuICogLy8gQGxvZzogeyByOiAxbiwgczogMm4sIHlQYXJpdHk6IDEgfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLkxlZ2FjeX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUxlZ2FjeShzaWduYXR1cmUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBzaWduYXR1cmUucixcbiAgICAgICAgczogc2lnbmF0dXJlLnMsXG4gICAgICAgIHlQYXJpdHk6IHZUb1lQYXJpdHkoc2lnbmF0dXJlLnYpLFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5ScGN9IGludG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbVJwYyh7XG4gKiAgIHI6ICcweDYzNWRjMjAzM2U2MDE4NWJiMzY3MDljMjljNzVkNjRlYTUxZGZiZDkxYzMyZWY0YmUxOThlNGNlYjE2OWZiNGQnLFxuICogICBzOiAnMHg1MGMyNjY3YWM0Yzc3MTA3Mjc0NmFjZmRjZjFmMTQ4MzMzNmRjY2E4YmQyZGY0N2NkODMxNzVkYmU2MGYwNTQwJyxcbiAqICAgeVBhcml0eTogJzB4MCcsXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlJwY30gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbVJwYyhzaWduYXR1cmUpIHtcbiAgICBjb25zdCB5UGFyaXR5ID0gKCgpID0+IHtcbiAgICAgICAgY29uc3QgdiA9IHNpZ25hdHVyZS52ID8gTnVtYmVyKHNpZ25hdHVyZS52KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IHlQYXJpdHkgPSBzaWduYXR1cmUueVBhcml0eSA/IE51bWJlcihzaWduYXR1cmUueVBhcml0eSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHlQYXJpdHkgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgeVBhcml0eSA9IHZUb1lQYXJpdHkodik7XG4gICAgICAgIGlmICh0eXBlb2YgeVBhcml0eSAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFlQYXJpdHlFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUueVBhcml0eSB9KTtcbiAgICAgICAgcmV0dXJuIHlQYXJpdHk7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByOiBCaWdJbnQoc2lnbmF0dXJlLnIpLFxuICAgICAgICBzOiBCaWdJbnQoc2lnbmF0dXJlLnMpLFxuICAgICAgICB5UGFyaXR5LFxuICAgIH07XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5UdXBsZX0gdG8gYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTaWduYXR1cmUuZnJvbVR1cGxlKFsnMHgwMScsICcweDdiJywgJzB4MWM4J10pXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHI6IDEyM24sXG4gKiAvLyBAbG9nOiAgIHM6IDQ1Nm4sXG4gKiAvLyBAbG9nOiAgIHlQYXJpdHk6IDEsXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdHVwbGUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5UdXBsZX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tVHVwbGUodHVwbGUpIHtcbiAgICBjb25zdCBbeVBhcml0eSwgciwgc10gPSB0dXBsZTtcbiAgICByZXR1cm4gZnJvbSh7XG4gICAgICAgIHI6IHIgPT09ICcweCcgPyAwbiA6IEJpZ0ludChyKSxcbiAgICAgICAgczogcyA9PT0gJzB4JyA/IDBuIDogQmlnSW50KHMpLFxuICAgICAgICB5UGFyaXR5OiB5UGFyaXR5ID09PSAnMHgnID8gMCA6IE51bWJlcih5UGFyaXR5KSxcbiAgICB9KTtcbn1cbi8qKlxuICogU2VyaWFsaXplcyBhIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byB7QGxpbmsgb3gjQnl0ZXMuQnl0ZXN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLnRvQnl0ZXMoe1xuICogICByOiA0OTc4Mjc1MzM0ODQ2MjQ5NDE5OTgyMzcxMjcwMDAwNDU1MjM5NDQyNTcxOTAxNDQ1ODkxODg3MTQ1MjMyOTc3NDkxMDQ1MDYwNzgwN24sXG4gKiAgIHM6IDMzNzI2Njk1OTc3ODQ0NDc2MjE0Njc2OTEzMjAxMTQwNDgxMTAyMjI1NDY5Mjg0MzA3MDE2OTM3OTE1NTk1NzU2MzU1OTI4NDE5NzY4bixcbiAqICAgeVBhcml0eTogMVxuICogfSlcbiAqIC8vIEBsb2c6IFVpbnQ4QXJyYXkgWzEwMiwgMTYsIDEwLCAuLi5dXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB0byBzZXJpYWxpemUuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKHNpZ25hdHVyZSkge1xuICAgIHJldHVybiBCeXRlcy5mcm9tSGV4KHRvSGV4KHNpZ25hdHVyZSkpO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIHtAbGluayBveCNIZXguSGV4fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS50b0hleCh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxXG4gKiB9KVxuICogLy8gQGxvZzogJzB4NmUxMDBhMzUyZWM2YWQxYjcwODAyMjkwZTE4YWVlZDE5MDcwNDk3MzU3MGYzYjhlZDQyY2I5ODA4ZTJlYTZiZjRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgxYydcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIHRvIHNlcmlhbGl6ZS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvSGV4KHNpZ25hdHVyZSkge1xuICAgIGFzc2VydChzaWduYXR1cmUpO1xuICAgIGNvbnN0IHIgPSBzaWduYXR1cmUucjtcbiAgICBjb25zdCBzID0gc2lnbmF0dXJlLnM7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9IEhleC5jb25jYXQoSGV4LmZyb21OdW1iZXIociwgeyBzaXplOiAzMiB9KSwgSGV4LmZyb21OdW1iZXIocywgeyBzaXplOiAzMiB9KSwgXG4gICAgLy8gSWYgdGhlIHNpZ25hdHVyZSBpcyByZWNvdmVyZWQsIGFkZCB0aGUgcmVjb3ZlcnkgYnl0ZSB0byB0aGUgc2lnbmF0dXJlLlxuICAgIHR5cGVvZiBzaWduYXR1cmUueVBhcml0eSA9PT0gJ251bWJlcidcbiAgICAgICAgPyBIZXguZnJvbU51bWJlcih5UGFyaXR5VG9WKHNpZ25hdHVyZS55UGFyaXR5KSwgeyBzaXplOiAxIH0pXG4gICAgICAgIDogJzB4Jyk7XG4gICAgcmV0dXJuIHNpZ25hdHVyZV87XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIERFUi1lbmNvZGVkIGZvcm1hdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZV9kZXIgPSBTaWduYXR1cmUudG9EZXJCeXRlcyhzaWduYXR1cmUpXG4gKiAvLyBAbG9nOiBVaW50OEFycmF5IFsxMzIsIDUxLCAyMywgLi4uXVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSBzaWduYXR1cmUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBERVItZW5jb2RlZCBzaWduYXR1cmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RlckJ5dGVzKHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHNpZyA9IG5ldyBzZWNwMjU2azEuU2lnbmF0dXJlKHNpZ25hdHVyZS5yLCBzaWduYXR1cmUucyk7XG4gICAgcmV0dXJuIHNpZy50b0RFUlJhd0J5dGVzKCk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIERFUi1lbmNvZGVkIGZvcm1hdC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5mcm9tKHtcbiAqICAgcjogNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZV9kZXIgPSBTaWduYXR1cmUudG9EZXJIZXgoc2lnbmF0dXJlKVxuICogLy8gQGxvZzogJzB4MzA0NDAyMjA2ZTEwMGEzNTJlYzZhZDFiNzA4MDIyOTBlMThhZWVkMTkwNzA0OTczNTcwZjNiOGVkNDJjYjk4MDhlMmVhNmJmMDIyMDRhOTBhMjI5YTI0NDQ5NWI0MTg5MDk4NzgwNmZjYmQyZDVkMjNmYzBkYmU1ZjUyNTZjMjYxM2MwMzlkNzZkYjgnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHNpZ25hdHVyZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIERFUi1lbmNvZGVkIHNpZ25hdHVyZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRGVySGV4KHNpZ25hdHVyZSkge1xuICAgIGNvbnN0IHNpZyA9IG5ldyBzZWNwMjU2azEuU2lnbmF0dXJlKHNpZ25hdHVyZS5yLCBzaWduYXR1cmUucyk7XG4gICAgcmV0dXJuIGAweCR7c2lnLnRvREVSSGV4KCl9YDtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gaW50byBhIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGxlZ2FjeSA9IFNpZ25hdHVyZS50b0xlZ2FjeSh7IHI6IDFuLCBzOiAybiwgeVBhcml0eTogMSB9KVxuICogLy8gQGxvZzogeyByOiAxbiwgczogMm4sIHY6IDI4IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUge0BsaW5rIG94I1NpZ25hdHVyZS5TaWduYXR1cmV9IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgY29udmVydGVkIHtAbGluayBveCNTaWduYXR1cmUuTGVnYWN5fS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTGVnYWN5KHNpZ25hdHVyZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHI6IHNpZ25hdHVyZS5yLFxuICAgICAgICBzOiBzaWduYXR1cmUucyxcbiAgICAgICAgdjogeVBhcml0eVRvVihzaWduYXR1cmUueVBhcml0eSksXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gaW50byBhIHtAbGluayBveCNTaWduYXR1cmUuUnBjfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS50b1JwYyh7XG4gKiAgIHI6IDQ5NzgyNzUzMzQ4NDYyNDk0MTk5ODIzNzEyNzAwMDA0NTUyMzk0NDI1NzE5MDE0NDU4OTE4ODcxNDUyMzI5Nzc0OTEwNDUwNjA3ODA3bixcbiAqICAgczogMzM3MjY2OTU5Nzc4NDQ0NzYyMTQ2NzY5MTMyMDExNDA0ODExMDIyMjU0NjkyODQzMDcwMTY5Mzc5MTU1OTU3NTYzNTU5Mjg0MTk3NjhuLFxuICogICB5UGFyaXR5OiAxXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNpZ25hdHVyZSAtIFRoZSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gY29udmVydC5cbiAqIEByZXR1cm5zIFRoZSBjb252ZXJ0ZWQge0BsaW5rIG94I1NpZ25hdHVyZS5ScGN9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9ScGMoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgeyByLCBzLCB5UGFyaXR5IH0gPSBzaWduYXR1cmU7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcjogSGV4LmZyb21OdW1iZXIociwgeyBzaXplOiAzMiB9KSxcbiAgICAgICAgczogSGV4LmZyb21OdW1iZXIocywgeyBzaXplOiAzMiB9KSxcbiAgICAgICAgeVBhcml0eTogeVBhcml0eSA9PT0gMCA/ICcweDAnIDogJzB4MScsXG4gICAgfTtcbn1cbi8qKlxuICogQ29udmVydHMgYSB7QGxpbmsgb3gjU2lnbmF0dXJlLlNpZ25hdHVyZX0gdG8gYSBzZXJpYWxpemVkIHtAbGluayBveCNTaWduYXR1cmUuVHVwbGV9IHRvIGJlIHVzZWQgZm9yIHNpZ25hdHVyZXMgaW4gVHJhbnNhY3Rpb24gRW52ZWxvcGVzLCBFSVAtNzcwMiBBdXRob3JpemF0aW9uIExpc3RzLCBldGMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTaWduYXR1cmUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBzaWduYXR1cmVUdXBsZSA9IFNpZ25hdHVyZS50b1R1cGxlKHtcbiAqICAgcjogMTIzbixcbiAqICAgczogNDU2bixcbiAqICAgeVBhcml0eTogMSxcbiAqIH0pXG4gKiAvLyBAbG9nOiBbeVBhcml0eTogJzB4MDEnLCByOiAnMHg3YicsIHM6ICcweDFjOCddXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2lnbmF0dXJlIC0gVGhlIHtAbGluayBveCNTaWduYXR1cmUuU2lnbmF0dXJlfSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIHtAbGluayBveCNTaWduYXR1cmUuVHVwbGV9LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9UdXBsZShzaWduYXR1cmUpIHtcbiAgICBjb25zdCB7IHIsIHMsIHlQYXJpdHkgfSA9IHNpZ25hdHVyZTtcbiAgICByZXR1cm4gW1xuICAgICAgICB5UGFyaXR5ID8gJzB4MDEnIDogJzB4JyxcbiAgICAgICAgciA9PT0gMG4gPyAnMHgnIDogSGV4LnRyaW1MZWZ0KEhleC5mcm9tTnVtYmVyKHIpKSxcbiAgICAgICAgcyA9PT0gMG4gPyAnMHgnIDogSGV4LnRyaW1MZWZ0KEhleC5mcm9tTnVtYmVyKHMpKSxcbiAgICBdO1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBTaWduYXR1cmUuIFJldHVybnMgYHRydWVgIGlmIHRoZSBzaWduYXR1cmUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsaWQgPSBTaWduYXR1cmUudmFsaWRhdGUoe1xuICogICByOiAtNDk3ODI3NTMzNDg0NjI0OTQxOTk4MjM3MTI3MDAwMDQ1NTIzOTQ0MjU3MTkwMTQ0NTg5MTg4NzE0NTIzMjk3NzQ5MTA0NTA2MDc4MDduLFxuICogICBzOiAzMzcyNjY5NTk3Nzg0NDQ3NjIxNDY3NjkxMzIwMTE0MDQ4MTEwMjIyNTQ2OTI4NDMwNzAxNjkzNzkxNTU5NTc1NjM1NTkyODQxOTc2OG4sXG4gKiAgIHlQYXJpdHk6IDEsXG4gKiB9KVxuICogLy8gQGxvZzogZmFsc2VcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzaWduYXR1cmUgLSBUaGUgc2lnbmF0dXJlIG9iamVjdCB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShzaWduYXR1cmUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChzaWduYXR1cmUsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEVDRFNBIGB2YCB2YWx1ZSB0byBhIGB5UGFyaXR5YCB2YWx1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNpZ25hdHVyZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IHlQYXJpdHkgPSBTaWduYXR1cmUudlRvWVBhcml0eSgyOClcbiAqIC8vIEBsb2c6IDFcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2IC0gVGhlIEVDRFNBIGB2YCB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMgVGhlIGB5UGFyaXR5YCB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZUb1lQYXJpdHkodikge1xuICAgIGlmICh2ID09PSAwIHx8IHYgPT09IDI3KVxuICAgICAgICByZXR1cm4gMDtcbiAgICBpZiAodiA9PT0gMSB8fCB2ID09PSAyOClcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgaWYgKHYgPj0gMzUpXG4gICAgICAgIHJldHVybiB2ICUgMiA9PT0gMCA/IDEgOiAwO1xuICAgIHRocm93IG5ldyBJbnZhbGlkVkVycm9yKHsgdmFsdWU6IHYgfSk7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgRUNEU0EgYHZgIHZhbHVlIHRvIGEgYHlQYXJpdHlgIHZhbHVlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2lnbmF0dXJlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdiA9IFNpZ25hdHVyZS55UGFyaXR5VG9WKDEpXG4gKiAvLyBAbG9nOiAyOFxuICogYGBgXG4gKlxuICogQHBhcmFtIHlQYXJpdHkgLSBUaGUgRUNEU0EgYHlQYXJpdHlgIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBUaGUgYHZgIHZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24geVBhcml0eVRvVih5UGFyaXR5KSB7XG4gICAgaWYgKHlQYXJpdHkgPT09IDApXG4gICAgICAgIHJldHVybiAyNztcbiAgICBpZiAoeVBhcml0eSA9PT0gMSlcbiAgICAgICAgcmV0dXJuIDI4O1xuICAgIHRocm93IG5ldyBJbnZhbGlkWVBhcml0eUVycm9yKHsgdmFsdWU6IHlQYXJpdHkgfSk7XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNlcmlhbGl6ZWQgc2lnbmF0dXJlIGlzIG9mIGFuIGludmFsaWQgc2l6ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkU2VyaWFsaXplZFNpemVFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgc2lnbmF0dXJlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7c2lnbmF0dXJlfVxcYCBpcyBhbiBpbnZhbGlkIHNpZ25hdHVyZSBzaXplLmAsIHtcbiAgICAgICAgICAgIG1ldGFNZXNzYWdlczogW1xuICAgICAgICAgICAgICAgICdFeHBlY3RlZDogNjQgYnl0ZXMgb3IgNjUgYnl0ZXMuJyxcbiAgICAgICAgICAgICAgICBgUmVjZWl2ZWQgJHtIZXguc2l6ZShIZXguZnJvbShzaWduYXR1cmUpKX0gYnl0ZXMuYCxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRTZXJpYWxpemVkU2l6ZUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBpcyBtaXNzaW5nIGVpdGhlciBhbiBgcmAsIGBzYCwgb3IgYHlQYXJpdHlgIHByb3BlcnR5LiAqL1xuZXhwb3J0IGNsYXNzIE1pc3NpbmdQcm9wZXJ0aWVzRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHNpZ25hdHVyZSB9KSB7XG4gICAgICAgIHN1cGVyKGBTaWduYXR1cmUgXFxgJHtKc29uLnN0cmluZ2lmeShzaWduYXR1cmUpfVxcYCBpcyBtaXNzaW5nIGVpdGhlciBhbiBcXGByXFxgLCBcXGBzXFxgLCBvciBcXGB5UGFyaXR5XFxgIHByb3BlcnR5LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLk1pc3NpbmdQcm9wZXJ0aWVzRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGhhcyBhbiBpbnZhbGlkIGByYCB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkUkVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIHIgdmFsdWUuIHIgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIDJeMjU2LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRSRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGhhcyBhbiBpbnZhbGlkIGBzYCB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkU0Vycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIHMgdmFsdWUuIHMgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgbGVzcyB0aGFuIDJeMjU2LmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnU2lnbmF0dXJlLkludmFsaWRTRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKiBUaHJvd24gd2hlbiB0aGUgc2lnbmF0dXJlIGhhcyBhbiBpbnZhbGlkIGB5UGFyaXR5YCB2YWx1ZS4gKi9cbmV4cG9ydCBjbGFzcyBJbnZhbGlkWVBhcml0eUVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyB2YWx1ZSB9KSB7XG4gICAgICAgIHN1cGVyKGBWYWx1ZSBcXGAke3ZhbHVlfVxcYCBpcyBhbiBpbnZhbGlkIHktcGFyaXR5IHZhbHVlLiBZLXBhcml0eSBtdXN0IGJlIDAgb3IgMS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1NpZ25hdHVyZS5JbnZhbGlkWVBhcml0eUVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKiogVGhyb3duIHdoZW4gdGhlIHNpZ25hdHVyZSBoYXMgYW4gaW52YWxpZCBgdmAgdmFsdWUuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFZFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgdmFsdWUgfSkge1xuICAgICAgICBzdXBlcihgVmFsdWUgXFxgJHt2YWx1ZX1cXGAgaXMgYW4gaW52YWxpZCB2IHZhbHVlLiB2IG11c3QgYmUgMjcsIDI4IG9yID49MzUuYCk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIm5hbWVcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6ICdTaWduYXR1cmUuSW52YWxpZFZFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U2lnbmF0dXJlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js":
/*!**********************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelope.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FeeCapTooHighError: () => (/* binding */ FeeCapTooHighError),\n/* harmony export */   GasPriceTooHighError: () => (/* binding */ GasPriceTooHighError),\n/* harmony export */   InvalidChainIdError: () => (/* binding */ InvalidChainIdError),\n/* harmony export */   InvalidSerializedError: () => (/* binding */ InvalidSerializedError),\n/* harmony export */   TipAboveFeeCapError: () => (/* binding */ TipAboveFeeCapError)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n/* harmony import */ var _Value_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Value.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Value.js\");\n\n\n/**\n * Thrown when a fee cap is too high.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.FeeCapTooHighError: The fee cap (`maxFeePerGas`/`maxPriorityFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */\nclass FeeCapTooHighError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ feeCap, } = {}) {\n        super(`The fee cap (\\`maxFeePerGas\\`/\\`maxPriorityFeePerGas\\`${feeCap ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(feeCap)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.FeeCapTooHighError'\n        });\n    }\n}\n/**\n * Thrown when a gas price is too high.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n * })\n * // @error: TransactionEnvelope.GasPriceTooHighError: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913.129639936 gwei) cannot be higher than the maximum allowed value (2^256-1).\n * ```\n */\nclass GasPriceTooHighError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ gasPrice, } = {}) {\n        super(`The gas price (\\`gasPrice\\`${gasPrice ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(gasPrice)} gwei` : ''}) cannot be higher than the maximum allowed value (2^256-1).`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.GasPriceTooHighError'\n        });\n    }\n}\n/**\n * Thrown when a chain ID is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({ chainId: 0 })\n * // @error: TransactionEnvelope.InvalidChainIdError: Chain ID \"0\" is invalid.\n * ```\n */\nclass InvalidChainIdError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ chainId }) {\n        super(typeof chainId !== 'undefined'\n            ? `Chain ID \"${chainId}\" is invalid.`\n            : 'Chain ID is invalid.');\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.InvalidChainIdError'\n        });\n    }\n}\n/**\n * Thrown when a serialized transaction is invalid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.deserialize('0x02c0')\n * // @error: TransactionEnvelope.InvalidSerializedError: Invalid serialized transaction of type \"eip1559\" was provided.\n * // @error: Serialized Transaction: \"0x02c0\"\n * // @error: Missing Attributes: chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList\n * ```\n */\nclass InvalidSerializedError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ attributes, serialized, type, }) {\n        const missing = Object.entries(attributes)\n            .map(([key, value]) => (typeof value === 'undefined' ? key : undefined))\n            .filter(Boolean);\n        super(`Invalid serialized transaction of type \"${type}\" was provided.`, {\n            metaMessages: [\n                `Serialized Transaction: \"${serialized}\"`,\n                missing.length > 0 ? `Missing Attributes: ${missing.join(', ')}` : '',\n            ].filter(Boolean),\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.InvalidSerializedError'\n        });\n    }\n}\n/**\n * Thrown when a tip is higher than a fee cap.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   chainId: 1,\n *   maxFeePerGas: 10n,\n *   maxPriorityFeePerGas: 11n,\n * })\n * // @error: TransactionEnvelope.TipAboveFeeCapError: The provided tip (`maxPriorityFeePerGas` = 11 gwei) cannot be higher than the fee cap (`maxFeePerGas` = 10 gwei).\n * ```\n */\nclass TipAboveFeeCapError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ maxPriorityFeePerGas, maxFeePerGas, } = {}) {\n        super([\n            `The provided tip (\\`maxPriorityFeePerGas\\`${maxPriorityFeePerGas\n                ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(maxPriorityFeePerGas)} gwei`\n                : ''}) cannot be higher than the fee cap (\\`maxFeePerGas\\`${maxFeePerGas ? ` = ${_Value_js__WEBPACK_IMPORTED_MODULE_1__.formatGwei(maxFeePerGas)} gwei` : ''}).`,\n        ].join('\\n'));\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'TransactionEnvelope.TipAboveFeeCapError'\n        });\n    }\n}\n//# sourceMappingURL=TransactionEnvelope.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQXNDO0FBQ0Y7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNPLGlDQUFpQyxpREFBZ0I7QUFDeEQsa0JBQWtCLFVBQVUsSUFBSTtBQUNoQyx1RUFBdUUsZUFBZSxpREFBZ0IsVUFBVSxXQUFXO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDTyxtQ0FBbUMsaURBQWdCO0FBQzFELGtCQUFrQixZQUFZLElBQUk7QUFDbEMsNENBQTRDLGlCQUFpQixpREFBZ0IsWUFBWSxXQUFXO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBLHVDQUF1QyxZQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQyxpREFBZ0I7QUFDekQsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZCQUE2QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFDQUFxQyxpREFBZ0I7QUFDNUQsa0JBQWtCLCtCQUErQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsS0FBSztBQUM5RDtBQUNBLDRDQUE0QyxXQUFXO0FBQ3ZELDREQUE0RCxtQkFBbUI7QUFDL0U7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ08sa0NBQWtDLGlEQUFnQjtBQUN6RCxrQkFBa0Isc0NBQXNDLElBQUk7QUFDNUQ7QUFDQSx5REFBeUQ7QUFDekQsd0JBQXdCLGlEQUFnQix3QkFBd0I7QUFDaEUscUJBQXFCLHVEQUF1RCxxQkFBcUIsaURBQWdCLGdCQUFnQixXQUFXO0FBQzVJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWluYWRvaS9EZXNrdG9wL2dpdGh1YlByb2plY3QvdGhyaWR3ZWJ0dXRvcmlhbC9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbmltcG9ydCAqIGFzIFZhbHVlIGZyb20gJy4vVmFsdWUuanMnO1xuLyoqXG4gKiBUaHJvd24gd2hlbiBhIGZlZSBjYXAgaXMgdG9vIGhpZ2guXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSB9IGZyb20gJ294J1xuICpcbiAqIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmFzc2VydCh7XG4gKiAgIG1heEZlZVBlckdhczogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiB9KVxuICogLy8gQGVycm9yOiBUcmFuc2FjdGlvbkVudmVsb3BlLkZlZUNhcFRvb0hpZ2hFcnJvcjogVGhlIGZlZSBjYXAgKGBtYXhGZWVQZXJHYXNgL2BtYXhQcmlvcml0eUZlZVBlckdhc2AgPSAxMTU3OTIwODkyMzczMTYxOTU0MjM1NzA5ODUwMDg2ODc5MDc4NTMyNjk5ODQ2NjU2NDA1NjQwMzk0NTc1ODQwMDc5MTMuMTI5NjM5OTM2IGd3ZWkpIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlICgyXjI1Ni0xKS5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgRmVlQ2FwVG9vSGlnaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBmZWVDYXAsIH0gPSB7fSkge1xuICAgICAgICBzdXBlcihgVGhlIGZlZSBjYXAgKFxcYG1heEZlZVBlckdhc1xcYC9cXGBtYXhQcmlvcml0eUZlZVBlckdhc1xcYCR7ZmVlQ2FwID8gYCA9ICR7VmFsdWUuZm9ybWF0R3dlaShmZWVDYXApfSBnd2VpYCA6ICcnfSkgY2Fubm90IGJlIGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVHJhbnNhY3Rpb25FbnZlbG9wZS5GZWVDYXBUb29IaWdoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBnYXMgcHJpY2UgaXMgdG9vIGhpZ2guXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5IH0gZnJvbSAnb3gnXG4gKlxuICogVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5hc3NlcnQoe1xuICogICBnYXNQcmljZTogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiB9KVxuICogLy8gQGVycm9yOiBUcmFuc2FjdGlvbkVudmVsb3BlLkdhc1ByaWNlVG9vSGlnaEVycm9yOiBUaGUgZ2FzIHByaWNlIChgZ2FzUHJpY2VgID0gMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3NTg0MDA3OTEzLjEyOTYzOTkzNiBnd2VpKSBjYW5ub3QgYmUgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEdhc1ByaWNlVG9vSGlnaEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBnYXNQcmljZSwgfSA9IHt9KSB7XG4gICAgICAgIHN1cGVyKGBUaGUgZ2FzIHByaWNlIChcXGBnYXNQcmljZVxcYCR7Z2FzUHJpY2UgPyBgID0gJHtWYWx1ZS5mb3JtYXRHd2VpKGdhc1ByaWNlKX0gZ3dlaWAgOiAnJ30pIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlICgyXjI1Ni0xKS5gKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1RyYW5zYWN0aW9uRW52ZWxvcGUuR2FzUHJpY2VUb29IaWdoRXJyb3InXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSBjaGFpbiBJRCBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgfSBmcm9tICdveCdcbiAqXG4gKiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5hc3NlcnQoeyBjaGFpbklkOiAwIH0pXG4gKiAvLyBAZXJyb3I6IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZENoYWluSWRFcnJvcjogQ2hhaW4gSUQgXCIwXCIgaXMgaW52YWxpZC5cbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZENoYWluSWRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgY2hhaW5JZCB9KSB7XG4gICAgICAgIHN1cGVyKHR5cGVvZiBjaGFpbklkICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBgQ2hhaW4gSUQgXCIke2NoYWluSWR9XCIgaXMgaW52YWxpZC5gXG4gICAgICAgICAgICA6ICdDaGFpbiBJRCBpcyBpbnZhbGlkLicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkQ2hhaW5JZEVycm9yJ1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biB3aGVuIGEgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBpcyBpbnZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgfSBmcm9tICdveCdcbiAqXG4gKiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5kZXNlcmlhbGl6ZSgnMHgwMmMwJylcbiAqIC8vIEBlcnJvcjogVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkU2VyaWFsaXplZEVycm9yOiBJbnZhbGlkIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24gb2YgdHlwZSBcImVpcDE1NTlcIiB3YXMgcHJvdmlkZWQuXG4gKiAvLyBAZXJyb3I6IFNlcmlhbGl6ZWQgVHJhbnNhY3Rpb246IFwiMHgwMmMwXCJcbiAqIC8vIEBlcnJvcjogTWlzc2luZyBBdHRyaWJ1dGVzOiBjaGFpbklkLCBub25jZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgZ2FzLCB0bywgdmFsdWUsIGRhdGEsIGFjY2Vzc0xpc3RcbiAqIGBgYFxuICovXG5leHBvcnQgY2xhc3MgSW52YWxpZFNlcmlhbGl6ZWRFcnJvciBleHRlbmRzIEVycm9ycy5CYXNlRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgYXR0cmlidXRlcywgc2VyaWFsaXplZCwgdHlwZSwgfSkge1xuICAgICAgICBjb25zdCBtaXNzaW5nID0gT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcylcbiAgICAgICAgICAgIC5tYXAoKFtrZXksIHZhbHVlXSkgPT4gKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBrZXkgOiB1bmRlZmluZWQpKVxuICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKTtcbiAgICAgICAgc3VwZXIoYEludmFsaWQgc2VyaWFsaXplZCB0cmFuc2FjdGlvbiBvZiB0eXBlIFwiJHt0eXBlfVwiIHdhcyBwcm92aWRlZC5gLCB7XG4gICAgICAgICAgICBtZXRhTWVzc2FnZXM6IFtcbiAgICAgICAgICAgICAgICBgU2VyaWFsaXplZCBUcmFuc2FjdGlvbjogXCIke3NlcmlhbGl6ZWR9XCJgLFxuICAgICAgICAgICAgICAgIG1pc3NpbmcubGVuZ3RoID4gMCA/IGBNaXNzaW5nIEF0dHJpYnV0ZXM6ICR7bWlzc2luZy5qb2luKCcsICcpfWAgOiAnJyxcbiAgICAgICAgICAgIF0uZmlsdGVyKEJvb2xlYW4pLFxuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1RyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZFNlcmlhbGl6ZWRFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBUaHJvd24gd2hlbiBhIHRpcCBpcyBoaWdoZXIgdGhhbiBhIGZlZSBjYXAuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSB9IGZyb20gJ294J1xuICpcbiAqIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmFzc2VydCh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG1heEZlZVBlckdhczogMTBuLFxuICogICBtYXhQcmlvcml0eUZlZVBlckdhczogMTFuLFxuICogfSlcbiAqIC8vIEBlcnJvcjogVHJhbnNhY3Rpb25FbnZlbG9wZS5UaXBBYm92ZUZlZUNhcEVycm9yOiBUaGUgcHJvdmlkZWQgdGlwIChgbWF4UHJpb3JpdHlGZWVQZXJHYXNgID0gMTEgZ3dlaSkgY2Fubm90IGJlIGhpZ2hlciB0aGFuIHRoZSBmZWUgY2FwIChgbWF4RmVlUGVyR2FzYCA9IDEwIGd3ZWkpLlxuICogYGBgXG4gKi9cbmV4cG9ydCBjbGFzcyBUaXBBYm92ZUZlZUNhcEVycm9yIGV4dGVuZHMgRXJyb3JzLkJhc2VFcnJvciB7XG4gICAgY29uc3RydWN0b3IoeyBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzLCB9ID0ge30pIHtcbiAgICAgICAgc3VwZXIoW1xuICAgICAgICAgICAgYFRoZSBwcm92aWRlZCB0aXAgKFxcYG1heFByaW9yaXR5RmVlUGVyR2FzXFxgJHttYXhQcmlvcml0eUZlZVBlckdhc1xuICAgICAgICAgICAgICAgID8gYCA9ICR7VmFsdWUuZm9ybWF0R3dlaShtYXhQcmlvcml0eUZlZVBlckdhcyl9IGd3ZWlgXG4gICAgICAgICAgICAgICAgOiAnJ30pIGNhbm5vdCBiZSBoaWdoZXIgdGhhbiB0aGUgZmVlIGNhcCAoXFxgbWF4RmVlUGVyR2FzXFxgJHttYXhGZWVQZXJHYXMgPyBgID0gJHtWYWx1ZS5mb3JtYXRHd2VpKG1heEZlZVBlckdhcyl9IGd3ZWlgIDogJyd9KS5gLFxuICAgICAgICBdLmpvaW4oJ1xcbicpKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwibmFtZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogJ1RyYW5zYWN0aW9uRW52ZWxvcGUuVGlwQWJvdmVGZWVDYXBFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb25FbnZlbG9wZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializedType: () => (/* binding */ serializedType),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _AccessList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AccessList.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\");\n\n\n\n\n\n\n\nconst serializedType = '0x02';\nconst type = 'eip1559';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nfunction assert(envelope) {\n    const { chainId, maxPriorityFeePerGas, maxFeePerGas, to } = envelope;\n    if (chainId <= 0)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidChainIdError({ chainId });\n    if (to)\n        _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(to, { strict: false });\n    if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.FeeCapTooHighError({ feeCap: maxFeePerGas });\n    if (maxPriorityFeePerGas &&\n        maxFeePerGas &&\n        maxPriorityFeePerGas > maxFeePerGas)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.TipAboveFeeCapError({\n            maxFeePerGas,\n            maxPriorityFeePerGas,\n        });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.deserialize('0x02ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip1559',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nfunction deserialize(serialized) {\n    const transactionArray = _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.slice(serialized, 1));\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, yParity, r, s,] = transactionArray;\n    if (!(transactionArray.length === 9 || transactionArray.length === 12))\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidSerializedError({\n            attributes: {\n                chainId,\n                nonce,\n                maxPriorityFeePerGas,\n                maxFeePerGas,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                ...(transactionArray.length > 9\n                    ? {\n                        yParity,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    let transaction = {\n        chainId: Number(chainId),\n        type,\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(to) && to !== '0x')\n        transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(data) && data !== '0x')\n        transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce) && nonce !== '0x')\n        transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(value) && value !== '0x')\n        transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n        transaction.maxFeePerGas = BigInt(maxFeePerGas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n        transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n    if (accessList.length !== 0 && accessList !== '0x')\n        transaction.accessList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.fromTupleList(accessList);\n    const signature = r && s && yParity ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.fromTuple([yParity, r, s]) : undefined;\n    if (signature)\n        transaction = {\n            ...transaction,\n            ...signature,\n        };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-1559 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-1559 Transaction Envelope from a {@link ox#TransactionEnvelopeEip1559.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from('0x02f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip1559',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-1559 Transaction Envelope.\n */\nfunction from(envelope, options = {}) {\n    const { signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.from(signature) : {}),\n        type: 'eip1559',\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip1559.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nfunction getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip1559.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip1559.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-1559 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nfunction hash(envelope, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_6__.keccak256(serialize({\n        ...envelope,\n        ...(presign\n            ? {\n                r: undefined,\n                s: undefined,\n                yParity: undefined,\n                v: undefined,\n            }\n            : {}),\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip1559.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip1559.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nfunction serialize(envelope, options = {}) {\n    const { chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input, } = envelope;\n    assert(envelope);\n    const accessTupleList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.toTupleList(accessList);\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(options.signature || envelope);\n    const serialized = [\n        _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId),\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : '0x',\n        maxPriorityFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(maxPriorityFeePerGas) : '0x',\n        maxFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(maxFeePerGas) : '0x',\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : '0x',\n        to ?? '0x',\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(value) : '0x',\n        data ?? input ?? '0x',\n        accessTupleList,\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toTuple(signature) : []),\n    ];\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.concat(serializedType, _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized));\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559} to an {@link ox#TransactionEnvelopeEip1559.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip1559.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip1559.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-1559 transaction envelope to convert.\n * @returns An RPC-formatted EIP-1559 transaction envelope.\n */\nfunction toRpc(envelope) {\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(envelope);\n    return {\n        ...envelope,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.chainId),\n        data: envelope.data ?? envelope.input,\n        type: '0x2',\n        ...(typeof envelope.gas === 'bigint'\n            ? { gas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gas) }\n            : {}),\n        ...(typeof envelope.nonce === 'bigint'\n            ? { nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.nonce) }\n            : {}),\n        ...(typeof envelope.value === 'bigint'\n            ? { value: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.value) }\n            : {}),\n        ...(typeof envelope.maxFeePerGas === 'bigint'\n            ? { maxFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.maxFeePerGas) }\n            : {}),\n        ...(typeof envelope.maxPriorityFeePerGas === 'bigint'\n            ? {\n                maxPriorityFeePerGas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.maxPriorityFeePerGas),\n            }\n            : {}),\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toRpc(signature) : {}),\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip1559.TransactionEnvelopeEip1559}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip1559, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip1559.assert({\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nfunction validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=TransactionEnvelopeEip1559.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDTjtBQUNOO0FBQ0Y7QUFDQTtBQUNZO0FBQ29CO0FBQ3pEO0FBQ0E7QUFDUDtBQUNBLGNBQWMsZ0VBQWdFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxrREFBa0Q7QUFDOUQ7QUFDQSxrQkFBa0Isd0VBQXVDLEdBQUcsU0FBUztBQUNyRTtBQUNBLFFBQVEsK0NBQWMsT0FBTyxlQUFlO0FBQzVDO0FBQ0Esa0JBQWtCLHVFQUFzQyxHQUFHLHNCQUFzQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0VBQXVDO0FBQ3pEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG1CQUFtQixnRUFBZ0U7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsMENBQVMsQ0FBQywwQ0FBUztBQUNoRDtBQUNBO0FBQ0Esa0JBQWtCLDJFQUEwQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNkNBQVk7QUFDcEI7QUFDQSxRQUFRLDZDQUFZO0FBQ3BCO0FBQ0EsUUFBUSw2Q0FBWTtB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QUNBLHdCQUF3QixrREFBaUI7QUFDekM7QUFDQSxXQUFXLDJDQUFVLGlCQUFpQiw0Q0FBVztBQUNqRDtBQUNBO0FBQ0EsZ0JBQWdCLGdFQUFnRSxPQUFPLHdDQUF3QztBQUMvSDtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFnRDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxzQkFBc0Isa0RBQWlCO0FBQ3ZDO0FBQ0E7QUFDQSxpQkFBaUIsK0NBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUssK0NBQWM7QUFDbkMsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCLE9BQU8sK0NBQWM7QUFDckMsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCLE9BQU8sK0NBQWM7QUFDckMsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCLGNBQWMsK0NBQWM7QUFDNUMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxzQ0FBc0MsK0NBQWM7QUFDcEQ7QUFDQSxnQkFBZ0I7QUFDaEIsd0JBQXdCLGdEQUFlLGdCQUFnQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0RBQStEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWluYWRvaS9EZXNrdG9wL2dpdGh1YlByb2plY3QvdGhyaWR3ZWJ0dXRvcmlhbC9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEFjY2Vzc0xpc3QgZnJvbSAnLi9BY2Nlc3NMaXN0LmpzJztcbmltcG9ydCAqIGFzIEFkZHJlc3MgZnJvbSAnLi9BZGRyZXNzLmpzJztcbmltcG9ydCAqIGFzIEhhc2ggZnJvbSAnLi9IYXNoLmpzJztcbmltcG9ydCAqIGFzIEhleCBmcm9tICcuL0hleC5qcyc7XG5pbXBvcnQgKiBhcyBSbHAgZnJvbSAnLi9SbHAuanMnO1xuaW1wb3J0ICogYXMgU2lnbmF0dXJlIGZyb20gJy4vU2lnbmF0dXJlLmpzJztcbmltcG9ydCAqIGFzIFRyYW5zYWN0aW9uRW52ZWxvcGUgZnJvbSAnLi9UcmFuc2FjdGlvbkVudmVsb3BlLmpzJztcbmV4cG9ydCBjb25zdCBzZXJpYWxpemVkVHlwZSA9ICcweDAyJztcbmV4cG9ydCBjb25zdCB0eXBlID0gJ2VpcDE1NTknO1xuLyoqXG4gKiBBc3NlcnRzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5fSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmFzc2VydCh7XG4gKiAgIG1heEZlZVBlckdhczogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIC8vIEBlcnJvcjogRmVlQ2FwVG9vSGlnaEVycm9yOlxuICogLy8gQGVycm9yOiBUaGUgZmVlIGNhcCAoYG1hc0ZlZVBlckdhc2AgPSAxMTU3OTIwODkyMzczMTYxOTU0MjM1NzA5ODUwMDg2ODc5MDc4NTMyNjk5ODQ2NjU2NDA1NjQwMzk0NTc1ODQwMDc5MTMgZ3dlaSkgY2Fubm90IGJlXG4gKiAvLyBAZXJyb3I6IGhpZ2hlciB0aGFuIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUgKDJeMjU2LTEpLlxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGFzc2VydC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChlbnZlbG9wZSkge1xuICAgIGNvbnN0IHsgY2hhaW5JZCwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgdG8gfSA9IGVudmVsb3BlO1xuICAgIGlmIChjaGFpbklkIDw9IDApXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRDaGFpbklkRXJyb3IoeyBjaGFpbklkIH0pO1xuICAgIGlmICh0bylcbiAgICAgICAgQWRkcmVzcy5hc3NlcnQodG8sIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICBpZiAobWF4RmVlUGVyR2FzICYmIEJpZ0ludChtYXhGZWVQZXJHYXMpID4gMm4gKiogMjU2biAtIDFuKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5GZWVDYXBUb29IaWdoRXJyb3IoeyBmZWVDYXA6IG1heEZlZVBlckdhcyB9KTtcbiAgICBpZiAobWF4UHJpb3JpdHlGZWVQZXJHYXMgJiZcbiAgICAgICAgbWF4RmVlUGVyR2FzICYmXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID4gbWF4RmVlUGVyR2FzKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5UaXBBYm92ZUZlZUNhcEVycm9yKHtcbiAgICAgICAgICAgIG1heEZlZVBlckdhcyxcbiAgICAgICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzLFxuICAgICAgICB9KTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5fSBmcm9tIGl0cyBzZXJpYWxpemVkIGZvcm0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZGVzZXJpYWxpemUoJzB4MDJlZjAxODIwMzExODQ3NzM1OTQwMDg0NzczNTk0MDA4MDk0NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljODg4MGRlMGI2YjNhNzY0MDAwMDgwYzAnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICB0eXBlOiAnZWlwMTU1OScsXG4gKiAvLyBAbG9nOiAgIG5vbmNlOiA3ODVuLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDIwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBnYXM6IDEwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBzZXJpYWxpemVkIC0gVGhlIHNlcmlhbGl6ZWQgdHJhbnNhY3Rpb24uXG4gKiBAcmV0dXJucyBEZXNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb25BcnJheSA9IFJscC50b0hleChIZXguc2xpY2Uoc2VyaWFsaXplZCwgMSkpO1xuICAgIGNvbnN0IFtjaGFpbklkLCBub25jZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIG1heEZlZVBlckdhcywgZ2FzLCB0bywgdmFsdWUsIGRhdGEsIGFjY2Vzc0xpc3QsIHlQYXJpdHksIHIsIHMsXSA9IHRyYW5zYWN0aW9uQXJyYXk7XG4gICAgaWYgKCEodHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPT09IDkgfHwgdHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPT09IDEyKSlcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZFNlcmlhbGl6ZWRFcnJvcih7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgY2hhaW5JZCxcbiAgICAgICAgICAgICAgICBub25jZSxcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgZ2FzLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgYWNjZXNzTGlzdCxcbiAgICAgICAgICAgICAgICAuLi4odHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPiA5XG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgeVBhcml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICB9KTtcbiAgICBsZXQgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgIGNoYWluSWQ6IE51bWJlcihjaGFpbklkKSxcbiAgICAgICAgdHlwZSxcbiAgICB9O1xuICAgIGlmIChIZXgudmFsaWRhdGUodG8pICYmIHRvICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi50byA9IHRvO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZ2FzKSAmJiBnYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmdhcyA9IEJpZ0ludChnYXMpO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZGF0YSkgJiYgZGF0YSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IGRhdGE7XG4gICAgaWYgKEhleC52YWxpZGF0ZShub25jZSkgJiYgbm9uY2UgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gQmlnSW50KG5vbmNlKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIGlmIChIZXgudmFsaWRhdGUobWF4RmVlUGVyR2FzKSAmJiBtYXhGZWVQZXJHYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyA9IEJpZ0ludChtYXhGZWVQZXJHYXMpO1xuICAgIGlmIChIZXgudmFsaWRhdGUobWF4UHJpb3JpdHlGZWVQZXJHYXMpICYmIG1heFByaW9yaXR5RmVlUGVyR2FzICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5tYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ0ludChtYXhQcmlvcml0eUZlZVBlckdhcyk7XG4gICAgaWYgKGFjY2Vzc0xpc3QubGVuZ3RoICE9PSAwICYmIGFjY2Vzc0xpc3QgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgPSBBY2Nlc3NMaXN0LmZyb21UdXBsZUxpc3QoYWNjZXNzTGlzdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gciAmJiBzICYmIHlQYXJpdHkgPyBTaWduYXR1cmUuZnJvbVR1cGxlKFt5UGFyaXR5LCByLCBzXSkgOiB1bmRlZmluZWQ7XG4gICAgaWYgKHNpZ25hdHVyZSlcbiAgICAgICAgdHJhbnNhY3Rpb24gPSB7XG4gICAgICAgICAgICAuLi50cmFuc2FjdGlvbixcbiAgICAgICAgICAgIC4uLnNpZ25hdHVyZSxcbiAgICAgICAgfTtcbiAgICBhc3NlcnQodHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYXJiaXRyYXJ5IHRyYW5zYWN0aW9uIG9iamVjdCBpbnRvIGFuIEVJUC0xNTU5IFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggYSBgc2lnbmF0dXJlYCB0byB0aGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZnJvbShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXAxNTU5JyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICByOiAxMjUuLi5uLFxuICogLy8gQGxvZzogICBzOiA2NDIuLi5uLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBpbnN0YW50aWF0ZSBhbiBFSVAtMTU1OSBUcmFuc2FjdGlvbiBFbnZlbG9wZSBmcm9tIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlNlcmlhbGl6ZWR9IHZhbHVlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZnJvbSgnMHgwMmY4NTgwMTgyMDMxMTg1MDI1NDBiZTQwMDg1MDRhODE3YzgwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDg0NzczNTk0MDBlMWEwMDE2MjdjNjg3MjYxYjBlN2Y4NjM4YWYxMTEyZWZhOGE3N2UyMzY1NmY2ZTc5NDUyNzViMTllOWRlZWQ4MDI2MScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICBtYXhQcmlvcml0eUZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2VpcDE1NTknLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBBbiBFSVAtMTU1OSBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGVudmVsb3BlXyA9ICh0eXBlb2YgZW52ZWxvcGUgPT09ICdzdHJpbmcnID8gZGVzZXJpYWxpemUoZW52ZWxvcGUpIDogZW52ZWxvcGUpO1xuICAgIGFzc2VydChlbnZlbG9wZV8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlXyxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS5mcm9tKHNpZ25hdHVyZSkgOiB7fSksXG4gICAgICAgIHR5cGU6ICdlaXAxNTU5JyxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXlsb2FkIHRvIHNpZ24gZm9yIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGhvdyB0byBjb21wdXRlIHRoZSBzaWduIHBheWxvYWQgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHdpdGggRUNEU0Egc2lnbmluZyB1dGlsaXRpZXMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3QgcGF5bG9hZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiAnMHguLi4nXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oeyBwYXlsb2FkLCBwcml2YXRlS2V5OiAnMHguLi4nIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gZ2V0IHRoZSBzaWduIHBheWxvYWQgZm9yLlxuICogQHJldHVybnMgVGhlIHNpZ24gcGF5bG9hZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSB7XG4gICAgcmV0dXJuIGhhc2goZW52ZWxvcGUsIHsgcHJlc2lnbjogdHJ1ZSB9KTtcbn1cbi8qKlxuICogSGFzaGVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5fS4gVGhpcyBpcyB0aGUgXCJ0cmFuc2FjdGlvbiBoYXNoXCIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3NpZ25lZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmZyb20oZW52ZWxvcGUsIHsgc2lnbmF0dXJlIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5Lmhhc2goZW52ZWxvcGVfc2lnbmVkKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgRUlQLTE1NTkgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gaGFzaC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlc2lnbiB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoc2VyaWFsaXplKHtcbiAgICAgICAgLi4uZW52ZWxvcGUsXG4gICAgICAgIC4uLihwcmVzaWduXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICByOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHlQYXJpdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICB9KSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTl9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzZXJpYWxpemVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuc2VyaWFsaXplKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LnNlcmlhbGl6ZShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIC4uLiBzZW5kIGBzZXJpYWxpemVkYCB0cmFuc2FjdGlvbiB0byBKU09OLVJQQyBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmBcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaGFpbklkLCBnYXMsIG5vbmNlLCB0bywgdmFsdWUsIG1heEZlZVBlckdhcywgbWF4UHJpb3JpdHlGZWVQZXJHYXMsIGFjY2Vzc0xpc3QsIGRhdGEsIGlucHV0LCB9ID0gZW52ZWxvcGU7XG4gICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICBjb25zdCBhY2Nlc3NUdXBsZUxpc3QgPSBBY2Nlc3NMaXN0LnRvVHVwbGVMaXN0KGFjY2Vzc0xpc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KG9wdGlvbnMuc2lnbmF0dXJlIHx8IGVudmVsb3BlKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gW1xuICAgICAgICBIZXguZnJvbU51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA/IEhleC5mcm9tTnVtYmVyKG1heFByaW9yaXR5RmVlUGVyR2FzKSA6ICcweCcsXG4gICAgICAgIG1heEZlZVBlckdhcyA/IEhleC5mcm9tTnVtYmVyKG1heEZlZVBlckdhcykgOiAnMHgnLFxuICAgICAgICBnYXMgPyBIZXguZnJvbU51bWJlcihnYXMpIDogJzB4JyxcbiAgICAgICAgdG8gPz8gJzB4JyxcbiAgICAgICAgdmFsdWUgPyBIZXguZnJvbU51bWJlcih2YWx1ZSkgOiAnMHgnLFxuICAgICAgICBkYXRhID8/IGlucHV0ID8/ICcweCcsXG4gICAgICAgIGFjY2Vzc1R1cGxlTGlzdCxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS50b1R1cGxlKHNpZ25hdHVyZSkgOiBbXSksXG4gICAgXTtcbiAgICByZXR1cm4gSGV4LmNvbmNhdChzZXJpYWxpemVkVHlwZSwgUmxwLmZyb21IZXgoc2VyaWFsaXplZCkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTl9IHRvIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjUmVxdWVzdCwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3JwYyA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LnRvUnBjKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFJwY1JlcXVlc3QuZnJvbSh7XG4gKiAgIGlkOiAwLFxuICogICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAqICAgcGFyYW1zOiBbZW52ZWxvcGVfcnBjXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgRUlQLTE1NTkgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgRUlQLTE1NTkgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhlbnZlbG9wZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KGVudmVsb3BlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbnZlbG9wZSxcbiAgICAgICAgY2hhaW5JZDogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuY2hhaW5JZCksXG4gICAgICAgIGRhdGE6IGVudmVsb3BlLmRhdGEgPz8gZW52ZWxvcGUuaW5wdXQsXG4gICAgICAgIHR5cGU6ICcweDInLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLmdhcyA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBnYXM6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLmdhcykgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUubm9uY2UgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgbm9uY2U6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLm5vbmNlKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS52YWx1ZSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyB2YWx1ZTogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUudmFsdWUpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLm1heEZlZVBlckdhcyA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBtYXhGZWVQZXJHYXM6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLm1heEZlZVBlckdhcykgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhczogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUubWF4UHJpb3JpdHlGZWVQZXJHYXMpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSA6IHt9KSxcbiAgICB9O1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTl9LiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTksIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsaWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5hc3NlcnQoe1xuICogICBtYXhGZWVQZXJHYXM6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIHZhbGlkYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoZW52ZWxvcGUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializedType: () => (/* binding */ serializedType),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _AccessList_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AccessList.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\");\n\n\n\n\n\n\n\nconst serializedType = '0x01';\nconst type = 'eip2930';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nfunction assert(envelope) {\n    const { chainId, gasPrice, to } = envelope;\n    if (chainId <= 0)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidChainIdError({ chainId });\n    if (to)\n        _Address_js__WEBPACK_IMPORTED_MODULE_1__.assert(to, { strict: false });\n    if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.GasPriceTooHighError({ gasPrice });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'eip2930',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nfunction deserialize(serialized) {\n    const transactionArray = _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.slice(serialized, 1));\n    const [chainId, nonce, gasPrice, gas, to, value, data, accessList, yParity, r, s,] = transactionArray;\n    if (!(transactionArray.length === 8 || transactionArray.length === 11))\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_0__.InvalidSerializedError({\n            attributes: {\n                chainId,\n                nonce,\n                gasPrice,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                ...(transactionArray.length > 8\n                    ? {\n                        yParity,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    let transaction = {\n        chainId: Number(chainId),\n        type,\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(to) && to !== '0x')\n        transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(data) && data !== '0x')\n        transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce) && nonce !== '0x')\n        transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(value) && value !== '0x')\n        transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gasPrice) && gasPrice !== '0x')\n        transaction.gasPrice = BigInt(gasPrice);\n    if (accessList.length !== 0 && accessList !== '0x')\n        transaction.accessList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.fromTupleList(accessList);\n    const signature = r && s && yParity ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.fromTuple([yParity, r, s]) : undefined;\n    if (signature)\n        transaction = {\n            ...transaction,\n            ...signature,\n        };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-2930 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   accessList: [...],\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-2930 Transaction Envelope from a {@link ox#TransactionEnvelopeEip2930.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from('0x01f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip2930',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}\n */\nfunction from(envelope, options = {}) {\n    const { signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.from(signature) : {}),\n        type: 'eip2930',\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip2930.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nfunction getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip2930.from(envelope, {\n *   signature,\n * })\n *\n * const hash = TransactionEnvelopeEip2930.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-2930 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nfunction hash(envelope, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_6__.keccak256(serialize({\n        ...envelope,\n        ...(presign\n            ? {\n                r: undefined,\n                s: undefined,\n                yParity: undefined,\n                v: undefined,\n            }\n            : {}),\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip2930.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip2930.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nfunction serialize(envelope, options = {}) {\n    const { chainId, gas, data, input, nonce, to, value, accessList, gasPrice } = envelope;\n    assert(envelope);\n    const accessTupleList = _AccessList_js__WEBPACK_IMPORTED_MODULE_4__.toTupleList(accessList);\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(options.signature || envelope);\n    const serialized = [\n        _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId),\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : '0x',\n        gasPrice ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gasPrice) : '0x',\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : '0x',\n        to ?? '0x',\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(value) : '0x',\n        data ?? input ?? '0x',\n        accessTupleList,\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toTuple(signature) : []),\n    ];\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_3__.concat('0x01', _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized));\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930} to an {@link ox#TransactionEnvelopeEip2930.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip2930.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   maxFeePerGas: Value.fromGwei('20'),\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeEip2930.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The EIP-2930 transaction envelope to convert.\n * @returns An RPC-formatted EIP-2930 transaction envelope.\n */\nfunction toRpc(envelope) {\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_5__.extract(envelope);\n    return {\n        ...envelope,\n        chainId: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.chainId),\n        data: envelope.data ?? envelope.input,\n        ...(typeof envelope.gas === 'bigint'\n            ? { gas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gas) }\n            : {}),\n        ...(typeof envelope.nonce === 'bigint'\n            ? { nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.nonce) }\n            : {}),\n        ...(typeof envelope.value === 'bigint'\n            ? { value: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.value) }\n            : {}),\n        ...(typeof envelope.gasPrice === 'bigint'\n            ? { gasPrice: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gasPrice) }\n            : {}),\n        type: '0x1',\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_5__.toRpc(signature) : {}),\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip2930.TransactionEnvelopeEip2930}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip2930, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip2930.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nfunction validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=TransactionEnvelopeEip2930.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEM7QUFDTjtBQUNOO0FBQ0Y7QUFDQTtBQUNZO0FBQ29CO0FBQ3pEO0FBQ0E7QUFDUDtBQUNBLGNBQWMsZ0VBQWdFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQSxrQkFBa0Isd0VBQXVDLEdBQUcsU0FBUztBQUNyRTtBQUNBLFFBQVEsK0NBQWMsT0FBTyxlQUFlO0FBQzVDO0FBQ0Esa0JBQWtCLHlFQUF3QyxHQUFHLFVBQVU7QUFDdkU7QUFDQTtBQUNBLG1CQUFtQixnRUFBZ0U7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsMENBQVMsQ0FBQywwQ0FBUztBQUNoRDtBQUNBO0FBQ0Esa0JBQWtCLDJFQUEwQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZDQUFZO0FBQ3BCO0FBQ0EsUUFBUSw2Q0FBWTtBQUNwQjtBQUNBLFFBQVEsNkNBQVk7QUFDcEI7QUFDQSxRQUFRLDZDQUFZO0FBQ3BCO0FBQ0EsUUFBUSw2Q0FBWTtBQUNwQjtBQUNBLFFBQVEsNkNB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QVksZ0RBQWdEO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asc0JBQXNCLGtEQUFpQjtBQUN2QztBQUNBO0FBQ0EsaUJBQWlCLCtDQUFjO0FBQy9CO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSywrQ0FBYztBQUNuQyxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0IsT0FBTywrQ0FBYztBQUNyQyxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0IsT0FBTywrQ0FBYztBQUNyQyxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0IsVUFBVSwrQ0FBYztBQUN4QyxnQkFBZ0I7QUFDaEI7QUFDQSx3QkFBd0IsZ0RBQWUsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBK0Q7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21paW5hZG9pL0Rlc2t0b3AvZ2l0aHViUHJvamVjdC90aHJpZHdlYnR1dG9yaWFsL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWNjZXNzTGlzdCBmcm9tICcuL0FjY2Vzc0xpc3QuanMnO1xuaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZSBmcm9tICcuL1RyYW5zYWN0aW9uRW52ZWxvcGUuanMnO1xuZXhwb3J0IGNvbnN0IHNlcmlhbGl6ZWRUeXBlID0gJzB4MDEnO1xuZXhwb3J0IGNvbnN0IHR5cGUgPSAnZWlwMjkzMCc7XG4vKipcbiAqIEFzc2VydHMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9IGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuYXNzZXJ0KHtcbiAqICAgZ2FzUHJpY2U6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAZXJyb3I6IEdhc1ByaWNlVG9vSGlnaEVycm9yOlxuICogLy8gQGVycm9yOiBUaGUgZ2FzIHByaWNlIChgZ2FzUHJpY2VgID0gMTE1NzkyMDg5MjM3MzE2MTk1NDIzNTcwOTg1MDA4Njg3OTA3ODUzMjY5OTg0NjY1NjQwNTY0MDM5NDU3NTg0MDA3OTEzIGd3ZWkpIGNhbm5vdCBiZVxuICogLy8gQGVycm9yOiBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlICgyXjI1Ni0xKS5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBhc3NlcnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoZW52ZWxvcGUpIHtcbiAgICBjb25zdCB7IGNoYWluSWQsIGdhc1ByaWNlLCB0byB9ID0gZW52ZWxvcGU7XG4gICAgaWYgKGNoYWluSWQgPD0gMClcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZENoYWluSWRFcnJvcih7IGNoYWluSWQgfSk7XG4gICAgaWYgKHRvKVxuICAgICAgICBBZGRyZXNzLmFzc2VydCh0bywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIGlmIChnYXNQcmljZSAmJiBCaWdJbnQoZ2FzUHJpY2UpID4gMm4gKiogMjU2biAtIDFuKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5HYXNQcmljZVRvb0hpZ2hFcnJvcih7IGdhc1ByaWNlIH0pO1xufVxuLyoqXG4gKiBEZXNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9IGZyb20gaXRzIHNlcmlhbGl6ZWQgZm9ybS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5kZXNlcmlhbGl6ZSgnMHgwMWVmMDE4MjAzMTE4NDc3MzU5NDAwODQ3NzM1OTQwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMCcpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXAyOTMwJyxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDc4NW4sXG4gKiAvLyBAbG9nOiAgIGdhc1ByaWNlOiAyMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgZ2FzOiAxMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICogQHJldHVybnMgRGVzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uQXJyYXkgPSBSbHAudG9IZXgoSGV4LnNsaWNlKHNlcmlhbGl6ZWQsIDEpKTtcbiAgICBjb25zdCBbY2hhaW5JZCwgbm9uY2UsIGdhc1ByaWNlLCBnYXMsIHRvLCB2YWx1ZSwgZGF0YSwgYWNjZXNzTGlzdCwgeVBhcml0eSwgciwgcyxdID0gdHJhbnNhY3Rpb25BcnJheTtcbiAgICBpZiAoISh0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA9PT0gOCB8fCB0cmFuc2FjdGlvbkFycmF5Lmxlbmd0aCA9PT0gMTEpKVxuICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FbnZlbG9wZS5JbnZhbGlkU2VyaWFsaXplZEVycm9yKHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICBjaGFpbklkLFxuICAgICAgICAgICAgICAgIG5vbmNlLFxuICAgICAgICAgICAgICAgIGdhc1ByaWNlLFxuICAgICAgICAgICAgICAgIGdhcyxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGFjY2Vzc0xpc3QsXG4gICAgICAgICAgICAgICAgLi4uKHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID4gOFxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlQYXJpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICByLFxuICAgICAgICAgICAgICAgICAgICAgICAgcyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXJpYWxpemVkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgfSk7XG4gICAgbGV0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIHR5cGUsXG4gICAgfTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHRvKSAmJiB0byAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udG8gPSB0bztcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGdhcykgJiYgZ2FzICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5nYXMgPSBCaWdJbnQoZ2FzKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGRhdGEpICYmIGRhdGEgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSBkYXRhO1xuICAgIGlmIChIZXgudmFsaWRhdGUobm9uY2UpICYmIG5vbmNlICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5ub25jZSA9IEJpZ0ludChub25jZSk7XG4gICAgaWYgKEhleC52YWxpZGF0ZSh2YWx1ZSkgJiYgdmFsdWUgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLnZhbHVlID0gQmlnSW50KHZhbHVlKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGdhc1ByaWNlKSAmJiBnYXNQcmljZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2FzUHJpY2UgPSBCaWdJbnQoZ2FzUHJpY2UpO1xuICAgIGlmIChhY2Nlc3NMaXN0Lmxlbmd0aCAhPT0gMCAmJiBhY2Nlc3NMaXN0ICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ID0gQWNjZXNzTGlzdC5mcm9tVHVwbGVMaXN0KGFjY2Vzc0xpc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHIgJiYgcyAmJiB5UGFyaXR5ID8gU2lnbmF0dXJlLmZyb21UdXBsZShbeVBhcml0eSwgciwgc10pIDogdW5kZWZpbmVkO1xuICAgIGlmIChzaWduYXR1cmUpXG4gICAgICAgIHRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAuLi5zaWduYXR1cmUsXG4gICAgICAgIH07XG4gICAgYXNzZXJ0KHRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGFyYml0cmFyeSB0cmFuc2FjdGlvbiBvYmplY3QgaW50byBhbiBFSVAtMjkzMCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgYWNjZXNzTGlzdDogWy4uLl0sXG4gKiAgIGdhc1ByaWNlOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBhIGBzaWduYXR1cmVgIHRvIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBnYXNQcmljZTogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBnYXNQcmljZTogMTAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXAyOTMwJyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICByOiAxMjUuLi5uLFxuICogLy8gQGxvZzogICBzOiA2NDIuLi5uLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBpbnN0YW50aWF0ZSBhbiBFSVAtMjkzMCBUcmFuc2FjdGlvbiBFbnZlbG9wZSBmcm9tIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLlNlcmlhbGl6ZWR9IHZhbHVlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbSgnMHgwMWY4NTgwMTgyMDMxMTg1MDI1NDBiZTQwMDg1MDRhODE3YzgwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDg0NzczNTk0MDBlMWEwMDE2MjdjNjg3MjYxYjBlN2Y4NjM4YWYxMTEyZWZhOGE3N2UyMzY1NmY2ZTc5NDUyNzViMTllOWRlZWQ4MDI2MScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2VpcDI5MzAnLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBBIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGVudmVsb3BlXyA9ICh0eXBlb2YgZW52ZWxvcGUgPT09ICdzdHJpbmcnID8gZGVzZXJpYWxpemUoZW52ZWxvcGUpIDogZW52ZWxvcGUpO1xuICAgIGFzc2VydChlbnZlbG9wZV8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlXyxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS5mcm9tKHNpZ25hdHVyZSkgOiB7fSksXG4gICAgICAgIHR5cGU6ICdlaXAyOTMwJyxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXlsb2FkIHRvIHNpZ24gZm9yIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGhvdyB0byBjb21wdXRlIHRoZSBzaWduIHBheWxvYWQgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHdpdGggRUNEU0Egc2lnbmluZyB1dGlsaXRpZXMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6ICcweC4uLidcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7IHBheWxvYWQsIHByaXZhdGVLZXk6ICcweC4uLicgfSlcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZSB0byBnZXQgdGhlIHNpZ24gcGF5bG9hZCBmb3IuXG4gKiBAcmV0dXJucyBUaGUgc2lnbiBwYXlsb2FkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2lnblBheWxvYWQoZW52ZWxvcGUpIHtcbiAgICByZXR1cm4gaGFzaChlbnZlbG9wZSwgeyBwcmVzaWduOiB0cnVlIH0pO1xufVxuLyoqXG4gKiBIYXNoZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9LiBUaGlzIGlzIHRoZSBcInRyYW5zYWN0aW9uIGhhc2hcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbShlbnZlbG9wZSwge1xuICogICBzaWduYXR1cmUsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGhhc2ggPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5oYXNoKGVudmVsb3BlX3NpZ25lZCkgLy8gWyFjb2RlIGZvY3VzXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIEVJUC0yOTMwIFRyYW5zYWN0aW9uIEVudmVsb3BlIHRvIGhhc2guXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgaGFzaCBvZiB0aGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHByZXNpZ24gfSA9IG9wdGlvbnM7XG4gICAgcmV0dXJuIEhhc2gua2VjY2FrMjU2KHNlcmlhbGl6ZSh7XG4gICAgICAgIC4uLmVudmVsb3BlLFxuICAgICAgICAuLi4ocHJlc2lnblxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgcjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB5UGFyaXR5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgdjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgfSkpO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLlRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIGdhc1ByaWNlOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNlcmlhbGl6ZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5zZXJpYWxpemUoZW52ZWxvcGUpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggYSBgc2lnbmF0dXJlYCB0byB0aGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMCwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmZyb20oe1xuICogICBjaGFpbklkOiAxLFxuICogICBnYXNQcmljZTogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLnNlcmlhbGl6ZShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIC4uLiBzZW5kIGBzZXJpYWxpemVkYCB0cmFuc2FjdGlvbiB0byBKU09OLVJQQyBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmBcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBjaGFpbklkLCBnYXMsIGRhdGEsIGlucHV0LCBub25jZSwgdG8sIHZhbHVlLCBhY2Nlc3NMaXN0LCBnYXNQcmljZSB9ID0gZW52ZWxvcGU7XG4gICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICBjb25zdCBhY2Nlc3NUdXBsZUxpc3QgPSBBY2Nlc3NMaXN0LnRvVHVwbGVMaXN0KGFjY2Vzc0xpc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KG9wdGlvbnMuc2lnbmF0dXJlIHx8IGVudmVsb3BlKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gW1xuICAgICAgICBIZXguZnJvbU51bWJlcihjaGFpbklkKSxcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICBnYXNQcmljZSA/IEhleC5mcm9tTnVtYmVyKGdhc1ByaWNlKSA6ICcweCcsXG4gICAgICAgIGdhcyA/IEhleC5mcm9tTnVtYmVyKGdhcykgOiAnMHgnLFxuICAgICAgICB0byA/PyAnMHgnLFxuICAgICAgICB2YWx1ZSA/IEhleC5mcm9tTnVtYmVyKHZhbHVlKSA6ICcweCcsXG4gICAgICAgIGRhdGEgPz8gaW5wdXQgPz8gJzB4JyxcbiAgICAgICAgYWNjZXNzVHVwbGVMaXN0LFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gU2lnbmF0dXJlLnRvVHVwbGUoc2lnbmF0dXJlKSA6IFtdKSxcbiAgICBdO1xuICAgIHJldHVybiBIZXguY29uY2F0KCcweDAxJywgUmxwLmZyb21IZXgoc2VyaWFsaXplZCkpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9IHRvIGFuIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjUmVxdWVzdCwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgbWF4RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMjAnKSxcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3JwYyA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLnRvUnBjKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFJwY1JlcXVlc3QuZnJvbSh7XG4gKiAgIGlkOiAwLFxuICogICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAqICAgcGFyYW1zOiBbZW52ZWxvcGVfcnBjXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgRUlQLTI5MzAgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIEFuIFJQQy1mb3JtYXR0ZWQgRUlQLTI5MzAgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1JwYyhlbnZlbG9wZSkge1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IFNpZ25hdHVyZS5leHRyYWN0KGVudmVsb3BlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbnZlbG9wZSxcbiAgICAgICAgY2hhaW5JZDogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuY2hhaW5JZCksXG4gICAgICAgIGRhdGE6IGVudmVsb3BlLmRhdGEgPz8gZW52ZWxvcGUuaW5wdXQsXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUuZ2FzID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IGdhczogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuZ2FzKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5ub25jZSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBub25jZTogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUubm9uY2UpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLnZhbHVlID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IHZhbHVlOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS52YWx1ZSkgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUuZ2FzUHJpY2UgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgZ2FzUHJpY2U6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLmdhc1ByaWNlKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgdHlwZTogJzB4MScsXG4gICAgICAgIC4uLihzaWduYXR1cmUgPyBTaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSA6IHt9KSxcbiAgICB9O1xufVxuLyoqXG4gKiBWYWxpZGF0ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAuVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzB9LiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDI5MzAsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgdmFsaWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5hc3NlcnQoe1xuICogICBnYXNQcmljZTogMm4gKiogMjU2biAtIDFuICsgMW4sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqIC8vIEBsb2c6IGZhbHNlXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gdmFsaWRhdGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZShlbnZlbG9wZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydChlbnZlbG9wZSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js":
/*!*****************************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializedType: () => (/* binding */ serializedType),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _AccessList_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./AccessList.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/AccessList.js\");\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Authorization_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Authorization.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Authorization.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\");\n/* harmony import */ var _TransactionEnvelopeEip1559_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TransactionEnvelopeEip1559.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js\");\n\n\n\n\n\n\n\n\n\nconst serializedType = '0x04';\nconst type = 'eip7702';\n/**\n * Asserts a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * TransactionEnvelopeEip7702.assert({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: FeeCapTooHighError:\n * // @error: The fee cap (`masFeePerGas` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nfunction assert(envelope) {\n    const { authorizationList } = envelope;\n    if (authorizationList) {\n        for (const authorization of authorizationList) {\n            const { address, chainId } = authorization;\n            if (address)\n                _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(address, { strict: false });\n            if (Number(chainId) < 0)\n                throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidChainIdError({ chainId });\n        }\n    }\n    _TransactionEnvelopeEip1559_js__WEBPACK_IMPORTED_MODULE_2__.assert(envelope);\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.deserialize('0x04ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   type: 'eip7702',\n * // @log:   nonce: 785n,\n * // @log:   maxFeePerGas: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nfunction deserialize(serialized) {\n    const transactionArray = _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.toHex(_Hex_js__WEBPACK_IMPORTED_MODULE_4__.slice(serialized, 1));\n    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to, value, data, accessList, authorizationList, yParity, r, s,] = transactionArray;\n    if (!(transactionArray.length === 10 || transactionArray.length === 13))\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSerializedError({\n            attributes: {\n                chainId,\n                nonce,\n                maxPriorityFeePerGas,\n                maxFeePerGas,\n                gas,\n                to,\n                value,\n                data,\n                accessList,\n                authorizationList,\n                ...(transactionArray.length > 9\n                    ? {\n                        yParity,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    let transaction = {\n        chainId: Number(chainId),\n        type,\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(to) && to !== '0x')\n        transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(data) && data !== '0x')\n        transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(nonce) && nonce !== '0x')\n        transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(value) && value !== '0x')\n        transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(maxFeePerGas) && maxFeePerGas !== '0x')\n        transaction.maxFeePerGas = BigInt(maxFeePerGas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_4__.validate(maxPriorityFeePerGas) && maxPriorityFeePerGas !== '0x')\n        transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);\n    if (accessList.length !== 0 && accessList !== '0x')\n        transaction.accessList = _AccessList_js__WEBPACK_IMPORTED_MODULE_5__.fromTupleList(accessList);\n    if (authorizationList !== '0x')\n        transaction.authorizationList = _Authorization_js__WEBPACK_IMPORTED_MODULE_6__.fromTupleList(authorizationList);\n    const signature = r && s && yParity ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.fromTuple([yParity, r, s]) : undefined;\n    if (signature)\n        transaction = {\n            ...transaction,\n            ...signature,\n        };\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into an EIP-7702 Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({ // [!code focus]\n *   authorizationList, // [!code focus]\n *   chainId: 1, // [!code focus]\n *   maxFeePerGas: Value.fromGwei('10'), // [!code focus]\n *   maxPriorityFeePerGas: Value.fromGwei('1'), // [!code focus]\n *   to: '0x0000000000000000000000000000000000000000', // [!code focus]\n *   value: Value.fromEther('1'), // [!code focus]\n * }) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   maxPriorityFeePerGas: Value.fromGwei('1'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   maxPriorityFeePerGas: 1000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an EIP-7702 Transaction Envelope from a {@link ox#TransactionEnvelopeEip7702.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from('0x04f858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   maxFeePerGas: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns An EIP-7702 Transaction Envelope.\n */\nfunction from(envelope, options = {}) {\n    const { signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    return {\n        ...envelope_,\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.from(signature) : {}),\n        type: 'eip7702',\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeEip7702.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nfunction getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702 } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   nonce: 0n,\n *   maxFeePerGas: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeEip7702.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeEip7702.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The EIP-7702 Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nfunction hash(envelope, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_8__.keccak256(serialize({\n        ...envelope,\n        ...(presign\n            ? {\n                r: undefined,\n                s: undefined,\n                yParity: undefined,\n            }\n            : {}),\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { Authorization, Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const authorization = Authorization.from({\n *   address: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   chainId: 1,\n *   nonce: 0n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: Authorization.getSignPayload(authorization),\n *   privateKey: '0x...',\n * })\n *\n * const authorizationList = [Authorization.from(authorization, { signature })]\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList,\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeEip7702.from({\n *   authorizationList: [...],\n *   chainId: 1,\n *   maxFeePerGas: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeEip7702.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeEip7702.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nfunction serialize(envelope, options = {}) {\n    const { authorizationList, chainId, gas, nonce, to, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input, } = envelope;\n    assert(envelope);\n    const accessTupleList = _AccessList_js__WEBPACK_IMPORTED_MODULE_5__.toTupleList(accessList);\n    const authorizationTupleList = _Authorization_js__WEBPACK_IMPORTED_MODULE_6__.toTupleList(authorizationList);\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_7__.extract(options.signature || envelope);\n    const serialized = [\n        _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(chainId),\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(nonce) : '0x',\n        maxPriorityFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(maxPriorityFeePerGas) : '0x',\n        maxFeePerGas ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(maxFeePerGas) : '0x',\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(gas) : '0x',\n        to ?? '0x',\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_4__.fromNumber(value) : '0x',\n        data ?? input ?? '0x',\n        accessTupleList,\n        authorizationTupleList,\n        ...(signature ? _Signature_js__WEBPACK_IMPORTED_MODULE_7__.toTuple(signature) : []),\n    ];\n    return _Hex_js__WEBPACK_IMPORTED_MODULE_4__.concat(serializedType, _Rlp_js__WEBPACK_IMPORTED_MODULE_3__.fromHex(serialized));\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeEip7702.TransactionEnvelopeEip7702}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeEip7702, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeEip7702.validate({\n *   authorizationList: [],\n *   maxFeePerGas: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nfunction validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=TransactionEnvelopeEip7702.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQThDO0FBQ047QUFDWTtBQUNsQjtBQUNGO0FBQ0E7QUFDWTtBQUNvQjtBQUNjO0FBQ3ZFO0FBQ0E7QUFDUDtBQUNBLGNBQWMsZ0VBQWdFO0FBQzlFO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLG9CQUFvQjtBQUNoQztBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBLGdCQUFnQiwrQ0FBYyxZQUFZLGVBQWU7QUFDekQ7QUFDQSwwQkFBMEIsd0VBQXVDLEdBQUcsU0FBUztBQUM3RTtBQUNBO0FBQ0EsSUFBSSxrRUFBaUM7QUFDckM7QUFDQTtBQUNBLG1CQUFtQixnRUFBZ0U7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2QkFBNkI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QiwwQ0FBUyxDQUFDLDBDQUFTO0FBQ2hEO0FBQ0E7QUFDQSxrQkFBa0IsMkVBQTBDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZDQUFZO0FBQ3BCO0FBQ0EsUUFBUSw2Q0FBWTtBQUNwQjtBQUNBLFFBQVEsNkNBQVk7QUFDcEI7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STtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx5Q0FBeUM7QUFDaEQsWUFBWSxrSEFBa0g7QUFDOUg7QUFDQSw0QkFBNEIsdURBQXNCO0FBQ2xELG1DQUFtQywwREFBeUI7QUFDNUQsc0JBQXNCLGtEQUFpQjtBQUN2QztBQUNBLFFBQVEsK0NBQWM7QUFDdEIsZ0JBQWdCLCtDQUFjO0FBQzlCLCtCQUErQiwrQ0FBYztBQUM3Qyx1QkFBdUIsK0NBQWM7QUFDckMsY0FBYywrQ0FBYztBQUM1QjtBQUNBLGdCQUFnQiwrQ0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0RBQWlCO0FBQ3pDO0FBQ0EsV0FBVywyQ0FBVSxpQkFBaUIsNENBQVc7QUFDakQ7QUFDQTtBQUNBLGdCQUFnQiwrREFBK0Q7QUFDL0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSxvQ0FBb0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWlpbmFkb2kvRGVza3RvcC9naXRodWJQcm9qZWN0L3Rocmlkd2VidHV0b3JpYWwvbm9kZV9tb2R1bGVzL294L19lc20vY29yZS9UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBY2Nlc3NMaXN0IGZyb20gJy4vQWNjZXNzTGlzdC5qcyc7XG5pbXBvcnQgKiBhcyBBZGRyZXNzIGZyb20gJy4vQWRkcmVzcy5qcyc7XG5pbXBvcnQgKiBhcyBBdXRob3JpemF0aW9uIGZyb20gJy4vQXV0aG9yaXphdGlvbi5qcyc7XG5pbXBvcnQgKiBhcyBIYXNoIGZyb20gJy4vSGFzaC5qcyc7XG5pbXBvcnQgKiBhcyBIZXggZnJvbSAnLi9IZXguanMnO1xuaW1wb3J0ICogYXMgUmxwIGZyb20gJy4vUmxwLmpzJztcbmltcG9ydCAqIGFzIFNpZ25hdHVyZSBmcm9tICcuL1NpZ25hdHVyZS5qcyc7XG5pbXBvcnQgKiBhcyBUcmFuc2FjdGlvbkVudmVsb3BlIGZyb20gJy4vVHJhbnNhY3Rpb25FbnZlbG9wZS5qcyc7XG5pbXBvcnQgKiBhcyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OSBmcm9tICcuL1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmpzJztcbmV4cG9ydCBjb25zdCBzZXJpYWxpemVkVHlwZSA9ICcweDA0JztcbmV4cG9ydCBjb25zdCB0eXBlID0gJ2VpcDc3MDInO1xuLyoqXG4gKiBBc3NlcnRzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLlRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyfSBpcyB2YWxpZC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmFzc2VydCh7XG4gKiAgIGF1dGhvcml6YXRpb25MaXN0OiBbXSxcbiAqICAgbWF4RmVlUGVyR2FzOiAybiAqKiAyNTZuIC0gMW4gKyAxbixcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogLy8gQGVycm9yOiBGZWVDYXBUb29IaWdoRXJyb3I6XG4gKiAvLyBAZXJyb3I6IFRoZSBmZWUgY2FwIChgbWFzRmVlUGVyR2FzYCA9IDExNTc5MjA4OTIzNzMxNjE5NTQyMzU3MDk4NTAwODY4NzkwNzg1MzI2OTk4NDY2NTY0MDU2NDAzOTQ1NzU4NDAwNzkxMyBnd2VpKSBjYW5ub3QgYmVcbiAqIC8vIEBlcnJvcjogaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGVudmVsb3BlKSB7XG4gICAgY29uc3QgeyBhdXRob3JpemF0aW9uTGlzdCB9ID0gZW52ZWxvcGU7XG4gICAgaWYgKGF1dGhvcml6YXRpb25MaXN0KSB7XG4gICAgICAgIGZvciAoY29uc3QgYXV0aG9yaXphdGlvbiBvZiBhdXRob3JpemF0aW9uTGlzdCkge1xuICAgICAgICAgICAgY29uc3QgeyBhZGRyZXNzLCBjaGFpbklkIH0gPSBhdXRob3JpemF0aW9uO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MpXG4gICAgICAgICAgICAgICAgQWRkcmVzcy5hc3NlcnQoYWRkcmVzcywgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgICAgICAgICAgaWYgKE51bWJlcihjaGFpbklkKSA8IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZENoYWluSWRFcnJvcih7IGNoYWluSWQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDE1NTkuYXNzZXJ0KGVudmVsb3BlKTtcbn1cbi8qKlxuICogRGVzZXJpYWxpemVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLlRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyfSBmcm9tIGl0cyBzZXJpYWxpemVkIGZvcm0uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZGVzZXJpYWxpemUoJzB4MDRlZjAxODIwMzExODQ3NzM1OTQwMDg0NzczNTk0MDA4MDk0NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljODg4MGRlMGI2YjNhNzY0MDAwMDgwYzAnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICBhdXRob3JpemF0aW9uTGlzdDogWy4uLl0sXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXA3NzAyJyxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDc4NW4sXG4gKiAvLyBAbG9nOiAgIG1heEZlZVBlckdhczogMjAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIGdhczogMTAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIHNlcmlhbGl6ZWQgLSBUaGUgc2VyaWFsaXplZCB0cmFuc2FjdGlvbi5cbiAqIEByZXR1cm5zIERlc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkFycmF5ID0gUmxwLnRvSGV4KEhleC5zbGljZShzZXJpYWxpemVkLCAxKSk7XG4gICAgY29uc3QgW2NoYWluSWQsIG5vbmNlLCBtYXhQcmlvcml0eUZlZVBlckdhcywgbWF4RmVlUGVyR2FzLCBnYXMsIHRvLCB2YWx1ZSwgZGF0YSwgYWNjZXNzTGlzdCwgYXV0aG9yaXphdGlvbkxpc3QsIHlQYXJpdHksIHIsIHMsXSA9IHRyYW5zYWN0aW9uQXJyYXk7XG4gICAgaWYgKCEodHJhbnNhY3Rpb25BcnJheS5sZW5ndGggPT09IDEwIHx8IHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID09PSAxMykpXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLkludmFsaWRTZXJpYWxpemVkRXJyb3Ioe1xuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIGNoYWluSWQsXG4gICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXMsXG4gICAgICAgICAgICAgICAgbWF4RmVlUGVyR2FzLFxuICAgICAgICAgICAgICAgIGdhcyxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICAgIGFjY2Vzc0xpc3QsXG4gICAgICAgICAgICAgICAgYXV0aG9yaXphdGlvbkxpc3QsXG4gICAgICAgICAgICAgICAgLi4uKHRyYW5zYWN0aW9uQXJyYXkubGVuZ3RoID4gOVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlQYXJpdHksXG4gICAgICAgICAgICAgICAgICAgICAgICByLFxuICAgICAgICAgICAgICAgICAgICAgICAgcyxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXJpYWxpemVkLFxuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgfSk7XG4gICAgbGV0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgICBjaGFpbklkOiBOdW1iZXIoY2hhaW5JZCksXG4gICAgICAgIHR5cGUsXG4gICAgfTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHRvKSAmJiB0byAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udG8gPSB0bztcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGdhcykgJiYgZ2FzICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5nYXMgPSBCaWdJbnQoZ2FzKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKGRhdGEpICYmIGRhdGEgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSBkYXRhO1xuICAgIGlmIChIZXgudmFsaWRhdGUobm9uY2UpICYmIG5vbmNlICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5ub25jZSA9IEJpZ0ludChub25jZSk7XG4gICAgaWYgKEhleC52YWxpZGF0ZSh2YWx1ZSkgJiYgdmFsdWUgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLnZhbHVlID0gQmlnSW50KHZhbHVlKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKG1heEZlZVBlckdhcykgJiYgbWF4RmVlUGVyR2FzICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMgPSBCaWdJbnQobWF4RmVlUGVyR2FzKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKG1heFByaW9yaXR5RmVlUGVyR2FzKSAmJiBtYXhQcmlvcml0eUZlZVBlckdhcyAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24ubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBCaWdJbnQobWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgIGlmIChhY2Nlc3NMaXN0Lmxlbmd0aCAhPT0gMCAmJiBhY2Nlc3NMaXN0ICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ID0gQWNjZXNzTGlzdC5mcm9tVHVwbGVMaXN0KGFjY2Vzc0xpc3QpO1xuICAgIGlmIChhdXRob3JpemF0aW9uTGlzdCAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uYXV0aG9yaXphdGlvbkxpc3QgPSBBdXRob3JpemF0aW9uLmZyb21UdXBsZUxpc3QoYXV0aG9yaXphdGlvbkxpc3QpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHIgJiYgcyAmJiB5UGFyaXR5ID8gU2lnbmF0dXJlLmZyb21UdXBsZShbeVBhcml0eSwgciwgc10pIDogdW5kZWZpbmVkO1xuICAgIGlmIChzaWduYXR1cmUpXG4gICAgICAgIHRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAuLi5zaWduYXR1cmUsXG4gICAgICAgIH07XG4gICAgYXNzZXJ0KHRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG59XG4vKipcbiAqIENvbnZlcnRzIGFuIGFyYml0cmFyeSB0cmFuc2FjdGlvbiBvYmplY3QgaW50byBhbiBFSVAtNzcwMiBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IEF1dGhvcml6YXRpb24sIFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIsIFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbiA9IEF1dGhvcml6YXRpb24uZnJvbSh7XG4gKiAgIGFkZHJlc3M6ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHtcbiAqICAgcGF5bG9hZDogQXV0aG9yaXphdGlvbi5nZXRTaWduUGF5bG9hZChhdXRob3JpemF0aW9uKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgYXV0aG9yaXphdGlvbkxpc3QgPSBbQXV0aG9yaXphdGlvbi5mcm9tKGF1dGhvcml6YXRpb24sIHsgc2lnbmF0dXJlIH0pXVxuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbSh7IC8vIFshY29kZSBmb2N1c11cbiAqICAgYXV0aG9yaXphdGlvbkxpc3QsIC8vIFshY29kZSBmb2N1c11cbiAqICAgY2hhaW5JZDogMSwgLy8gWyFjb2RlIGZvY3VzXVxuICogICBtYXhGZWVQZXJHYXM6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMScpLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJywgLy8gWyFjb2RlIGZvY3VzXVxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgQXR0YWNoaW5nIFNpZ25hdHVyZXNcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBhdHRhY2ggYSBgc2lnbmF0dXJlYCB0byB0aGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMiwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oe1xuICogICBhdXRob3JpemF0aW9uTGlzdDogWy4uLl0sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG1heEZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBWYWx1ZS5mcm9tR3dlaSgnMScpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLicsXG4gKiB9KVxuICpcbiAqIGNvbnN0IGVudmVsb3BlX3NpZ25lZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oZW52ZWxvcGUsIHsgLy8gWyFjb2RlIGZvY3VzXVxuICogICBzaWduYXR1cmUsIC8vIFshY29kZSBmb2N1c11cbiAqIH0pIC8vIFshY29kZSBmb2N1c11cbiAqIC8vIEBsb2c6IHtcbiAqIC8vIEBsb2c6ICAgYXV0aG9yaXphdGlvbkxpc3Q6IFsuLi5dLFxuICogLy8gQGxvZzogICBjaGFpbklkOiAxLFxuICogLy8gQGxvZzogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAvLyBAbG9nOiAgIHR5cGU6ICdlaXA3NzAyJyxcbiAqIC8vIEBsb2c6ICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogLy8gQGxvZzogICByOiAxMjUuLi5uLFxuICogLy8gQGxvZzogICBzOiA2NDIuLi5uLFxuICogLy8gQGxvZzogICB5UGFyaXR5OiAwLFxuICogLy8gQGxvZzogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBGcm9tIFNlcmlhbGl6ZWRcbiAqXG4gKiBJdCBpcyBwb3NzaWJsZSB0byBpbnN0YW50aWF0ZSBhbiBFSVAtNzcwMiBUcmFuc2FjdGlvbiBFbnZlbG9wZSBmcm9tIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLlNlcmlhbGl6ZWR9IHZhbHVlLlxuICpcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbSgnMHgwNGY4NTgwMTgyMDMxMTg1MDI1NDBiZTQwMDg1MDRhODE3YzgwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDg0NzczNTk0MDBlMWEwMDE2MjdjNjg3MjYxYjBlN2Y4NjM4YWYxMTEyZWZhOGE3N2UyMzY1NmY2ZTc5NDUyNzViMTllOWRlZWQ4MDI2MScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGF1dGhvcml6YXRpb25MaXN0OiBbLi4uXSxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgbWF4RmVlUGVyR2FzOiAxMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2VpcDc3MDInLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gb2JqZWN0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBBbiBFSVAtNzcwMiBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb20oZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgc2lnbmF0dXJlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGVudmVsb3BlXyA9ICh0eXBlb2YgZW52ZWxvcGUgPT09ICdzdHJpbmcnID8gZGVzZXJpYWxpemUoZW52ZWxvcGUpIDogZW52ZWxvcGUpO1xuICAgIGFzc2VydChlbnZlbG9wZV8pO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlXyxcbiAgICAgICAgLi4uKHNpZ25hdHVyZSA/IFNpZ25hdHVyZS5mcm9tKHNpZ25hdHVyZSkgOiB7fSksXG4gICAgICAgIHR5cGU6ICdlaXA3NzAyJyxcbiAgICB9O1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwYXlsb2FkIHRvIHNpZ24gZm9yIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLlRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGhvdyB0byBjb21wdXRlIHRoZSBzaWduIHBheWxvYWQgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHdpdGggRUNEU0Egc2lnbmluZyB1dGlsaXRpZXMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMiB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbSh7XG4gKiAgIGF1dGhvcml6YXRpb25MaXN0OiBbLi4uXSxcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBtYXhGZWVQZXJHYXM6IDEwMDAwMDAwMDBuLFxuICogICBnYXM6IDIxMDAwbixcbiAqICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiB9KVxuICpcbiAqIGNvbnN0IHBheWxvYWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogJzB4Li4uJ1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZCwgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGdldCB0aGUgc2lnbiBwYXlsb2FkIGZvci5cbiAqIEByZXR1cm5zIFRoZSBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChlbnZlbG9wZSkge1xuICAgIHJldHVybiBoYXNoKGVudmVsb3BlLCB7IHByZXNpZ246IHRydWUgfSk7XG59XG4vKipcbiAqIEhhc2hlcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMn0uIFRoaXMgaXMgdGhlIFwidHJhbnNhY3Rpb24gaGFzaFwiLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogLy8gQG5vRXJyb3JzXG4gKiBpbXBvcnQgeyBTZWNwMjU2azEsIFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyIH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5mcm9tKHtcbiAqICAgYXV0aG9yaXphdGlvbkxpc3Q6IFsuLi5dLFxuICogICBjaGFpbklkOiAxLFxuICogICBub25jZTogMG4sXG4gKiAgIG1heEZlZVBlckdhczogMTAwMDAwMDAwMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSksXG4gKiAgIHByaXZhdGVLZXk6ICcweC4uLidcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuZnJvbShlbnZlbG9wZSwgeyBzaWduYXR1cmUgfSlcbiAqXG4gKiBjb25zdCBoYXNoID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuaGFzaChlbnZlbG9wZV9zaWduZWQpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBFSVAtNzcwMiBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBoYXNoLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zLlxuICogQHJldHVybnMgVGhlIGhhc2ggb2YgdGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaChlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBwcmVzaWduIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiBIYXNoLmtlY2NhazI1NihzZXJpYWxpemUoe1xuICAgICAgICAuLi5lbnZlbG9wZSxcbiAgICAgICAgLi4uKHByZXNpZ25cbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHI6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICBzOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgeVBhcml0eTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgfSkpO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGEge0BsaW5rIG94I1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLlRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyfS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgQXV0aG9yaXphdGlvbiwgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMiwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uID0gQXV0aG9yaXphdGlvbi5mcm9tKHtcbiAqICAgYWRkcmVzczogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBBdXRob3JpemF0aW9uLmdldFNpZ25QYXlsb2FkKGF1dGhvcml6YXRpb24pLFxuICogICBwcml2YXRlS2V5OiAnMHguLi4nLFxuICogfSlcbiAqXG4gKiBjb25zdCBhdXRob3JpemF0aW9uTGlzdCA9IFtBdXRob3JpemF0aW9uLmZyb20oYXV0aG9yaXphdGlvbiwgeyBzaWduYXR1cmUgfSldXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5mcm9tKHtcbiAqICAgYXV0aG9yaXphdGlvbkxpc3QsXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG1heEZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzZXJpYWxpemVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuc2VyaWFsaXplKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMiwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmZyb20oe1xuICogICBhdXRob3JpemF0aW9uTGlzdDogWy4uLl0sXG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG1heEZlZVBlckdhczogVmFsdWUuZnJvbUd3ZWkoJzEwJyksXG4gKiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBzaWduYXR1cmUgPSBTZWNwMjU2azEuc2lnbih7XG4gKiAgIHBheWxvYWQ6IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLnNlcmlhbGl6ZShlbnZlbG9wZSwgeyAvLyBbIWNvZGUgZm9jdXNdXG4gKiAgIHNpZ25hdHVyZSwgLy8gWyFjb2RlIGZvY3VzXVxuICogfSkgLy8gWyFjb2RlIGZvY3VzXVxuICpcbiAqIC8vIC4uLiBzZW5kIGBzZXJpYWxpemVkYCB0cmFuc2FjdGlvbiB0byBKU09OLVJQQyBgZXRoX3NlbmRSYXdUcmFuc2FjdGlvbmBcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBUcmFuc2FjdGlvbiBFbnZlbG9wZSB0byBzZXJpYWxpemUuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gKiBAcmV0dXJucyBUaGUgc2VyaWFsaXplZCBUcmFuc2FjdGlvbiBFbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBhdXRob3JpemF0aW9uTGlzdCwgY2hhaW5JZCwgZ2FzLCBub25jZSwgdG8sIHZhbHVlLCBtYXhGZWVQZXJHYXMsIG1heFByaW9yaXR5RmVlUGVyR2FzLCBhY2Nlc3NMaXN0LCBkYXRhLCBpbnB1dCwgfSA9IGVudmVsb3BlO1xuICAgIGFzc2VydChlbnZlbG9wZSk7XG4gICAgY29uc3QgYWNjZXNzVHVwbGVMaXN0ID0gQWNjZXNzTGlzdC50b1R1cGxlTGlzdChhY2Nlc3NMaXN0KTtcbiAgICBjb25zdCBhdXRob3JpemF0aW9uVHVwbGVMaXN0ID0gQXV0aG9yaXphdGlvbi50b1R1cGxlTGlzdChhdXRob3JpemF0aW9uTGlzdCk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmV4dHJhY3Qob3B0aW9ucy5zaWduYXR1cmUgfHwgZW52ZWxvcGUpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBbXG4gICAgICAgIEhleC5mcm9tTnVtYmVyKGNoYWluSWQpLFxuICAgICAgICBub25jZSA/IEhleC5mcm9tTnVtYmVyKG5vbmNlKSA6ICcweCcsXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzID8gSGV4LmZyb21OdW1iZXIobWF4UHJpb3JpdHlGZWVQZXJHYXMpIDogJzB4JyxcbiAgICAgICAgbWF4RmVlUGVyR2FzID8gSGV4LmZyb21OdW1iZXIobWF4RmVlUGVyR2FzKSA6ICcweCcsXG4gICAgICAgIGdhcyA/IEhleC5mcm9tTnVtYmVyKGdhcykgOiAnMHgnLFxuICAgICAgICB0byA/PyAnMHgnLFxuICAgICAgICB2YWx1ZSA/IEhleC5mcm9tTnVtYmVyKHZhbHVlKSA6ICcweCcsXG4gICAgICAgIGRhdGEgPz8gaW5wdXQgPz8gJzB4JyxcbiAgICAgICAgYWNjZXNzVHVwbGVMaXN0LFxuICAgICAgICBhdXRob3JpemF0aW9uVHVwbGVMaXN0LFxuICAgICAgICAuLi4oc2lnbmF0dXJlID8gU2lnbmF0dXJlLnRvVHVwbGUoc2lnbmF0dXJlKSA6IFtdKSxcbiAgICBdO1xuICAgIHJldHVybiBIZXguY29uY2F0KHNlcmlhbGl6ZWRUeXBlLCBSbHAuZnJvbUhleChzZXJpYWxpemVkKSk7XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMn0uIFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnZlbG9wZSBpcyB2YWxpZCwgYGZhbHNlYCBvdGhlcndpc2UuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBUcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMiwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLnZhbGlkYXRlKHtcbiAqICAgYXV0aG9yaXphdGlvbkxpc3Q6IFtdLFxuICogICBtYXhGZWVQZXJHYXM6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIHZhbGlkYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoZW52ZWxvcGUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb25FbnZlbG9wZUVpcDc3MDIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js":
/*!****************************************************************!*\
  !*** ./node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assert: () => (/* binding */ assert),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   getSignPayload: () => (/* binding */ getSignPayload),\n/* harmony export */   hash: () => (/* binding */ hash),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   toRpc: () => (/* binding */ toRpc),\n/* harmony export */   type: () => (/* binding */ type),\n/* harmony export */   validate: () => (/* binding */ validate)\n/* harmony export */ });\n/* harmony import */ var _Address_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Address.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Address.js\");\n/* harmony import */ var _Hash_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Hash.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hash.js\");\n/* harmony import */ var _Hex_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hex.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var _Rlp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rlp.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Rlp.js\");\n/* harmony import */ var _Signature_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Signature.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TransactionEnvelope.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelope.js\");\n\n\n\n\n\n\nconst type = 'legacy';\n/**\n * Asserts a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} is valid.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @error: GasPriceTooHighError:\n * // @error: The gas price (`gasPrice` = 115792089237316195423570985008687907853269984665640564039457584007913 gwei) cannot be\n * // @error: higher than the maximum allowed value (2^256-1).\n * ```\n *\n * @param envelope - The transaction envelope to assert.\n */\nfunction assert(envelope) {\n    const { chainId, gasPrice, to } = envelope;\n    if (to)\n        _Address_js__WEBPACK_IMPORTED_MODULE_0__.assert(to, { strict: false });\n    if (typeof chainId !== 'undefined' && chainId <= 0)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidChainIdError({ chainId });\n    if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.GasPriceTooHighError({ gasPrice });\n}\n/**\n * Deserializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} from its serialized form.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.deserialize('0x01ef0182031184773594008477359400809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c0')\n * // @log: {\n * // @log:   type: 'legacy',\n * // @log:   nonce: 785n,\n * // @log:   gasPrice: 2000000000n,\n * // @log:   gas: 1000000n,\n * // @log:   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param serialized - The serialized transaction.\n * @returns Deserialized Transaction Envelope.\n */\nfunction deserialize(serialized) {\n    const tuple = _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.toHex(serialized);\n    const [nonce, gasPrice, gas, to, value, data, chainIdOrV_, r, s] = tuple;\n    if (!(tuple.length === 6 || tuple.length === 9))\n        throw new _TransactionEnvelope_js__WEBPACK_IMPORTED_MODULE_1__.InvalidSerializedError({\n            attributes: {\n                nonce,\n                gasPrice,\n                gas,\n                to,\n                value,\n                data,\n                ...(tuple.length > 6\n                    ? {\n                        v: chainIdOrV_,\n                        r,\n                        s,\n                    }\n                    : {}),\n            },\n            serialized,\n            type,\n        });\n    const transaction = {\n        type,\n    };\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(to) && to !== '0x')\n        transaction.to = to;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gas) && gas !== '0x')\n        transaction.gas = BigInt(gas);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(data) && data !== '0x')\n        transaction.data = data;\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(nonce) && nonce !== '0x')\n        transaction.nonce = BigInt(nonce);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(value) && value !== '0x')\n        transaction.value = BigInt(value);\n    if (_Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(gasPrice) && gasPrice !== '0x')\n        transaction.gasPrice = BigInt(gasPrice);\n    if (tuple.length === 6)\n        return transaction;\n    const chainIdOrV = _Hex_js__WEBPACK_IMPORTED_MODULE_3__.validate(chainIdOrV_) && chainIdOrV_ !== '0x'\n        ? Number(chainIdOrV_)\n        : 0;\n    if (s === '0x' && r === '0x') {\n        if (chainIdOrV > 0)\n            transaction.chainId = Number(chainIdOrV);\n        return transaction;\n    }\n    const v = chainIdOrV;\n    const chainId = Math.floor((v - 35) / 2);\n    if (chainId > 0)\n        transaction.chainId = chainId;\n    else if (v !== 27 && v !== 28)\n        throw new _Signature_js__WEBPACK_IMPORTED_MODULE_4__.InvalidVError({ value: v });\n    transaction.yParity = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.vToYParity(v);\n    transaction.v = v;\n    transaction.s = s === '0x' ? 0n : BigInt(s);\n    transaction.r = r === '0x' ? 0n : BigInt(r);\n    assert(transaction);\n    return transaction;\n}\n/**\n * Converts an arbitrary transaction object into a legacy Transaction Envelope.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the transaction envelope.\n *\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n * // @log: {\n * // @log:   authorizationList: [...],\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'eip7702',\n * // @log:   value: 1000000000000000000n,\n * // @log:   r: 125...n,\n * // @log:   s: 642...n,\n * // @log:   yParity: 0,\n * // @log: }\n * ```\n *\n * @example\n * ### From Serialized\n *\n * It is possible to instantiate an legacy Transaction Envelope from a {@link ox#TransactionEnvelopeLegacy.Serialized} value.\n *\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from('0xf858018203118502540be4008504a817c800809470997970c51812dc3a010c7d01b50e0d17dc79c8880de0b6b3a764000080c08477359400e1a001627c687261b0e7f8638af1112efa8a77e23656f6e7945275b19e9deed80261')\n * // @log: {\n * // @log:   chainId: 1,\n * // @log:   gasPrice: 10000000000n,\n * // @log:   to: '0x0000000000000000000000000000000000000000',\n * // @log:   type: 'legacy',\n * // @log:   value: 1000000000000000000n,\n * // @log: }\n * ```\n *\n * @param envelope - The transaction object to convert.\n * @param options - Options.\n * @returns A legacy Transaction Envelope.\n */\nfunction from(envelope, options = {}) {\n    const { signature } = options;\n    const envelope_ = (typeof envelope === 'string' ? deserialize(envelope) : envelope);\n    assert(envelope_);\n    const signature_ = (() => {\n        if (!signature)\n            return {};\n        const s = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.from(signature);\n        s.v = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.yParityToV(s.yParity);\n        return s;\n    })();\n    return {\n        ...envelope_,\n        ...signature_,\n        type: 'legacy',\n    };\n}\n/**\n * Returns the payload to sign for a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * The example below demonstrates how to compute the sign payload which can be used\n * with ECDSA signing utilities like {@link ox#Secp256k1.(sign:function)}.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const payload = TransactionEnvelopeLegacy.getSignPayload(envelope) // [!code focus]\n * // @log: '0x...'\n *\n * const signature = Secp256k1.sign({ payload, privateKey: '0x...' })\n * ```\n *\n * @param envelope - The transaction envelope to get the sign payload for.\n * @returns The sign payload.\n */\nfunction getSignPayload(envelope) {\n    return hash(envelope, { presign: true });\n}\n/**\n * Hashes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. This is the \"transaction hash\".\n *\n * @example\n * ```ts twoslash\n * import { Secp256k1, TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gasPrice: 1000000000n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: 1000000000000000000n,\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...'\n * })\n *\n * const envelope_signed = TransactionEnvelopeLegacy.from(envelope, { signature })\n *\n * const hash = TransactionEnvelopeLegacy.hash(envelope_signed) // [!code focus]\n * ```\n *\n * @param envelope - The Legacy Transaction Envelope to hash.\n * @param options - Options.\n * @returns The hash of the transaction envelope.\n */\nfunction hash(envelope, options = {}) {\n    const { presign } = options;\n    return _Hash_js__WEBPACK_IMPORTED_MODULE_5__.keccak256(serialize({\n        ...envelope,\n        ...(presign\n            ? {\n                r: undefined,\n                s: undefined,\n                yParity: undefined,\n                v: undefined,\n            }\n            : {}),\n    }));\n}\n/**\n * Serializes a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}.\n *\n * @example\n * ```ts twoslash\n * // @noErrors\n * import { TransactionEnvelopeLegacy } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope) // [!code focus]\n * ```\n *\n * @example\n * ### Attaching Signatures\n *\n * It is possible to attach a `signature` to the serialized Transaction Envelope.\n *\n * ```ts twoslash\n * // @noErrors\n * import { Secp256k1, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   gasPrice: Value.fromGwei('10'),\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n *\n * const signature = Secp256k1.sign({\n *   payload: TransactionEnvelopeLegacy.getSignPayload(envelope),\n *   privateKey: '0x...',\n * })\n *\n * const serialized = TransactionEnvelopeLegacy.serialize(envelope, { // [!code focus]\n *   signature, // [!code focus]\n * }) // [!code focus]\n *\n * // ... send `serialized` transaction to JSON-RPC `eth_sendRawTransaction`\n * ```\n *\n * @param envelope - The Transaction Envelope to serialize.\n * @param options - Options.\n * @returns The serialized Transaction Envelope.\n */\nfunction serialize(envelope, options = {}) {\n    const { chainId = 0, gas, data, input, nonce, to, value, gasPrice } = envelope;\n    assert(envelope);\n    let serialized = [\n        nonce ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(nonce) : '0x',\n        gasPrice ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gasPrice) : '0x',\n        gas ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(gas) : '0x',\n        to ?? '0x',\n        value ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(value) : '0x',\n        data ?? input ?? '0x',\n    ];\n    const signature = (() => {\n        if (options.signature)\n            return {\n                r: options.signature.r,\n                s: options.signature.s,\n                v: _Signature_js__WEBPACK_IMPORTED_MODULE_4__.yParityToV(options.signature.yParity),\n            };\n        if (typeof envelope.r === 'undefined' || typeof envelope.s === 'undefined')\n            return undefined;\n        return {\n            r: envelope.r,\n            s: envelope.s,\n            v: envelope.v,\n        };\n    })();\n    if (signature) {\n        const v = (() => {\n            // EIP-155 (inferred chainId)\n            if (signature.v >= 35) {\n                const inferredChainId = Math.floor((signature.v - 35) / 2);\n                if (inferredChainId > 0)\n                    return signature.v;\n                return 27 + (signature.v === 35 ? 0 : 1);\n            }\n            // EIP-155 (explicit chainId)\n            if (chainId > 0)\n                return chainId * 2 + 35 + signature.v - 27;\n            // Pre-EIP-155 (no chainId)\n            const v = 27 + (signature.v === 27 ? 0 : 1);\n            if (signature.v !== v)\n                throw new _Signature_js__WEBPACK_IMPORTED_MODULE_4__.InvalidVError({ value: signature.v });\n            return v;\n        })();\n        serialized = [\n            ...serialized,\n            _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(v),\n            signature.r === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(signature.r)),\n            signature.s === 0n ? '0x' : _Hex_js__WEBPACK_IMPORTED_MODULE_3__.trimLeft(_Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(signature.s)),\n        ];\n    }\n    else if (chainId > 0)\n        serialized = [...serialized, _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(chainId), '0x', '0x'];\n    return _Rlp_js__WEBPACK_IMPORTED_MODULE_2__.fromHex(serialized);\n}\n/**\n * Converts an {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy} to an {@link ox#TransactionEnvelopeLegacy.Rpc}.\n *\n * @example\n * ```ts twoslash\n * import { RpcRequest, TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const envelope = TransactionEnvelopeLegacy.from({\n *   chainId: 1,\n *   nonce: 0n,\n *   gas: 21000n,\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *   value: Value.fromEther('1'),\n * })\n *\n * const envelope_rpc = TransactionEnvelopeLegacy.toRpc(envelope) // [!code focus]\n *\n * const request = RpcRequest.from({\n *   id: 0,\n *   method: 'eth_sendTransaction',\n *   params: [envelope_rpc],\n * })\n * ```\n *\n * @param envelope - The legacy transaction envelope to convert.\n * @returns An RPC-formatted legacy transaction envelope.\n */\nfunction toRpc(envelope) {\n    const signature = _Signature_js__WEBPACK_IMPORTED_MODULE_4__.extract(envelope);\n    return {\n        ...envelope,\n        chainId: typeof envelope.chainId === 'number'\n            ? _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.chainId)\n            : undefined,\n        data: envelope.data ?? envelope.input,\n        type: '0x0',\n        ...(typeof envelope.gas === 'bigint'\n            ? { gas: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gas) }\n            : {}),\n        ...(typeof envelope.nonce === 'bigint'\n            ? { nonce: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.nonce) }\n            : {}),\n        ...(typeof envelope.value === 'bigint'\n            ? { value: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.value) }\n            : {}),\n        ...(typeof envelope.gasPrice === 'bigint'\n            ? { gasPrice: _Hex_js__WEBPACK_IMPORTED_MODULE_3__.fromNumber(envelope.gasPrice) }\n            : {}),\n        ...(signature\n            ? {\n                ..._Signature_js__WEBPACK_IMPORTED_MODULE_4__.toRpc(signature),\n                v: signature.yParity === 0 ? '0x1b' : '0x1c',\n            }\n            : {}),\n    };\n}\n/**\n * Validates a {@link ox#TransactionEnvelopeLegacy.TransactionEnvelopeLegacy}. Returns `true` if the envelope is valid, `false` otherwise.\n *\n * @example\n * ```ts twoslash\n * import { TransactionEnvelopeLegacy, Value } from 'ox'\n *\n * const valid = TransactionEnvelopeLegacy.assert({\n *   gasPrice: 2n ** 256n - 1n + 1n,\n *   chainId: 1,\n *   to: '0x0000000000000000000000000000000000000000',\n *   value: Value.fromEther('1'),\n * })\n * // @log: false\n * ```\n *\n * @param envelope - The transaction envelope to validate.\n */\nfunction validate(envelope) {\n    try {\n        assert(envelope);\n        return true;\n    }\n    catch {\n        return false;\n    }\n}\n//# sourceMappingURL=TransactionEnvelopeLegacy.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDTjtBQUNGO0FBQ0E7QUFDWTtBQUNvQjtBQUN6RDtBQUNQO0FBQ0EsY0FBYyw4REFBOEQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtQ0FBbUM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHdCQUF3QjtBQUNwQztBQUNBLFFBQVEsK0NBQWMsT0FBTyxlQUFlO0FBQzVDO0FBQ0Esa0JBQWtCLHdFQUF1QyxHQUFHLFNBQVM7QUFDckU7QUFDQSxrQkFBa0IseUVBQXdDLEdBQUcsVUFBVTtBQUN2RTtBQUNBO0FBQ0EsbUJBQW1CLDhEQUE4RDtBQUNqRjtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGtCQUFrQiwwQ0FBUztBQUMzQjtBQUNBO0FBQ0Esa0JBQWtCLDJFQUEwQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRLDZDQUFZO0FBQ3BCO0FBQ0EsUUFBUSw2Q0FBWTtBQUNwQjtBQUNBLFFBQVEsNkNBQVk7QUFDcEI7QUFDQSxRQUFRLDZDQUFZO0FBQ3BCO0FBQ0EsUUFBUSw2Q0FBWTtBQUNwQjtBQUNBLFFBQVEsNkNBQVk7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDZDQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix3REFBdUIsR0FBRyxVQUFVO0FBQ3RELDBCQUEwQixxREFBb0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSwrQ0FBK0M7QUFDdkg7QUFDQTtBQUNBLFlBQVksNEJBQTRCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG9DQUFvQztBQUMzQyxZQUFZLFlBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwrQ0FBYztBQUNoQyxjQUFjLHFEQUFvQjtBQUNsQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2REFBNkQ7QUFDbkc7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG1DQUFtQztBQUN6RTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw4QkFBOEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNEJBQTRCLGVBQWU7QUFDM0M7QUFDQTtBQUNBLGFBQWEsNkRBQTZEO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLFlBQVksdUNBQXVDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzRUFBc0UsV0FBVztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sb0NBQW9DO0FBQzNDLFlBQVksVUFBVTtBQUN0QixXQUFXLCtDQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUIsNkRBQTZEO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDhDQUE4QztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHlDQUF5QztBQUNoRCxZQUFZLDREQUE0RDtBQUN4RTtBQUNBO0FBQ0EsZ0JBQWdCLCtDQUFjO0FBQzlCLG1CQUFtQiwrQ0FBYztBQUNqQyxjQUFjLCtDQUFjO0FBQzVCO0FBQ0EsZ0JBQWdCLCtDQUFjO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFEQUFvQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBdUIsR0FBRyxvQkFBb0I7QUFDeEU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFlBQVksK0NBQWM7QUFDMUIsd0NBQXdDLDZDQUFZLENBQUMsK0NBQWM7QUFDbkUsd0NBQXdDLDZDQUFZLENBQUMsK0NBQWM7QUFDbkU7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLCtDQUFjO0FBQ25ELFdBQVcsNENBQVc7QUFDdEI7QUFDQTtBQUNBLGdCQUFnQiw4REFBOEQsT0FBTyx1Q0FBdUM7QUFDNUg7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrQ0FBK0M7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asc0JBQXNCLGtEQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxjQUFjLCtDQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLEtBQUssK0NBQWM7QUFDbkMsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCLE9BQU8sK0NBQWM7QUFDckMsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCLE9BQU8sK0NBQWM7QUFDckMsZ0JBQWdCO0FBQ2hCO0FBQ0EsZ0JBQWdCLFVBQVUsK0NBQWM7QUFDeEMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQWU7QUFDbEM7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkRBQTZEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWluYWRvaS9EZXNrdG9wL2dpdGh1YlByb2plY3QvdGhyaWR3ZWJ0dXRvcmlhbC9ub2RlX21vZHVsZXMvb3gvX2VzbS9jb3JlL1RyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgQWRkcmVzcyBmcm9tICcuL0FkZHJlc3MuanMnO1xuaW1wb3J0ICogYXMgSGFzaCBmcm9tICcuL0hhc2guanMnO1xuaW1wb3J0ICogYXMgSGV4IGZyb20gJy4vSGV4LmpzJztcbmltcG9ydCAqIGFzIFJscCBmcm9tICcuL1JscC5qcyc7XG5pbXBvcnQgKiBhcyBTaWduYXR1cmUgZnJvbSAnLi9TaWduYXR1cmUuanMnO1xuaW1wb3J0ICogYXMgVHJhbnNhY3Rpb25FbnZlbG9wZSBmcm9tICcuL1RyYW5zYWN0aW9uRW52ZWxvcGUuanMnO1xuZXhwb3J0IGNvbnN0IHR5cGUgPSAnbGVnYWN5Jztcbi8qKlxuICogQXNzZXJ0cyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9IGlzIHZhbGlkLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmFzc2VydCh7XG4gKiAgIGdhc1ByaWNlOiAybiAqKiAyNTZuIC0gMW4gKyAxbixcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogLy8gQGVycm9yOiBHYXNQcmljZVRvb0hpZ2hFcnJvcjpcbiAqIC8vIEBlcnJvcjogVGhlIGdhcyBwcmljZSAoYGdhc1ByaWNlYCA9IDExNTc5MjA4OTIzNzMxNjE5NTQyMzU3MDk4NTAwODY4NzkwNzg1MzI2OTk4NDY2NTY0MDU2NDAzOTQ1NzU4NDAwNzkxMyBnd2VpKSBjYW5ub3QgYmVcbiAqIC8vIEBlcnJvcjogaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gYWxsb3dlZCB2YWx1ZSAoMl4yNTYtMSkuXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgdHJhbnNhY3Rpb24gZW52ZWxvcGUgdG8gYXNzZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KGVudmVsb3BlKSB7XG4gICAgY29uc3QgeyBjaGFpbklkLCBnYXNQcmljZSwgdG8gfSA9IGVudmVsb3BlO1xuICAgIGlmICh0bylcbiAgICAgICAgQWRkcmVzcy5hc3NlcnQodG8sIHsgc3RyaWN0OiBmYWxzZSB9KTtcbiAgICBpZiAodHlwZW9mIGNoYWluSWQgIT09ICd1bmRlZmluZWQnICYmIGNoYWluSWQgPD0gMClcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZENoYWluSWRFcnJvcih7IGNoYWluSWQgfSk7XG4gICAgaWYgKGdhc1ByaWNlICYmIEJpZ0ludChnYXNQcmljZSkgPiAybiAqKiAyNTZuIC0gMW4pXG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkVudmVsb3BlLkdhc1ByaWNlVG9vSGlnaEVycm9yKHsgZ2FzUHJpY2UgfSk7XG59XG4vKipcbiAqIERlc2VyaWFsaXplcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9IGZyb20gaXRzIHNlcmlhbGl6ZWQgZm9ybS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZGVzZXJpYWxpemUoJzB4MDFlZjAxODIwMzExODQ3NzM1OTQwMDg0NzczNTk0MDA4MDk0NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljODg4MGRlMGI2YjNhNzY0MDAwMDgwYzAnKVxuICogLy8gQGxvZzoge1xuICogLy8gQGxvZzogICB0eXBlOiAnbGVnYWN5JyxcbiAqIC8vIEBsb2c6ICAgbm9uY2U6IDc4NW4sXG4gKiAvLyBAbG9nOiAgIGdhc1ByaWNlOiAyMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgZ2FzOiAxMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDcwOTk3OTcwYzUxODEyZGMzYTAxMGM3ZDAxYjUwZTBkMTdkYzc5YzgnLFxuICogLy8gQGxvZzogICB2YWx1ZTogMTAwMDAwMDAwMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gc2VyaWFsaXplZCAtIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICogQHJldHVybnMgRGVzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCkge1xuICAgIGNvbnN0IHR1cGxlID0gUmxwLnRvSGV4KHNlcmlhbGl6ZWQpO1xuICAgIGNvbnN0IFtub25jZSwgZ2FzUHJpY2UsIGdhcywgdG8sIHZhbHVlLCBkYXRhLCBjaGFpbklkT3JWXywgciwgc10gPSB0dXBsZTtcbiAgICBpZiAoISh0dXBsZS5sZW5ndGggPT09IDYgfHwgdHVwbGUubGVuZ3RoID09PSA5KSlcbiAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRW52ZWxvcGUuSW52YWxpZFNlcmlhbGl6ZWRFcnJvcih7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgbm9uY2UsXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2UsXG4gICAgICAgICAgICAgICAgZ2FzLFxuICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgLi4uKHR1cGxlLmxlbmd0aCA+IDZcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2OiBjaGFpbklkT3JWXyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICB9KTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgdHlwZSxcbiAgICB9O1xuICAgIGlmIChIZXgudmFsaWRhdGUodG8pICYmIHRvICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi50byA9IHRvO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZ2FzKSAmJiBnYXMgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLmdhcyA9IEJpZ0ludChnYXMpO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZGF0YSkgJiYgZGF0YSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24uZGF0YSA9IGRhdGE7XG4gICAgaWYgKEhleC52YWxpZGF0ZShub25jZSkgJiYgbm9uY2UgIT09ICcweCcpXG4gICAgICAgIHRyYW5zYWN0aW9uLm5vbmNlID0gQmlnSW50KG5vbmNlKTtcbiAgICBpZiAoSGV4LnZhbGlkYXRlKHZhbHVlKSAmJiB2YWx1ZSAhPT0gJzB4JylcbiAgICAgICAgdHJhbnNhY3Rpb24udmFsdWUgPSBCaWdJbnQodmFsdWUpO1xuICAgIGlmIChIZXgudmFsaWRhdGUoZ2FzUHJpY2UpICYmIGdhc1ByaWNlICE9PSAnMHgnKVxuICAgICAgICB0cmFuc2FjdGlvbi5nYXNQcmljZSA9IEJpZ0ludChnYXNQcmljZSk7XG4gICAgaWYgKHR1cGxlLmxlbmd0aCA9PT0gNilcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIGNvbnN0IGNoYWluSWRPclYgPSBIZXgudmFsaWRhdGUoY2hhaW5JZE9yVl8pICYmIGNoYWluSWRPclZfICE9PSAnMHgnXG4gICAgICAgID8gTnVtYmVyKGNoYWluSWRPclZfKVxuICAgICAgICA6IDA7XG4gICAgaWYgKHMgPT09ICcweCcgJiYgciA9PT0gJzB4Jykge1xuICAgICAgICBpZiAoY2hhaW5JZE9yViA+IDApXG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5jaGFpbklkID0gTnVtYmVyKGNoYWluSWRPclYpO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gICAgfVxuICAgIGNvbnN0IHYgPSBjaGFpbklkT3JWO1xuICAgIGNvbnN0IGNoYWluSWQgPSBNYXRoLmZsb29yKCh2IC0gMzUpIC8gMik7XG4gICAgaWYgKGNoYWluSWQgPiAwKVxuICAgICAgICB0cmFuc2FjdGlvbi5jaGFpbklkID0gY2hhaW5JZDtcbiAgICBlbHNlIGlmICh2ICE9PSAyNyAmJiB2ICE9PSAyOClcbiAgICAgICAgdGhyb3cgbmV3IFNpZ25hdHVyZS5JbnZhbGlkVkVycm9yKHsgdmFsdWU6IHYgfSk7XG4gICAgdHJhbnNhY3Rpb24ueVBhcml0eSA9IFNpZ25hdHVyZS52VG9ZUGFyaXR5KHYpO1xuICAgIHRyYW5zYWN0aW9uLnYgPSB2O1xuICAgIHRyYW5zYWN0aW9uLnMgPSBzID09PSAnMHgnID8gMG4gOiBCaWdJbnQocyk7XG4gICAgdHJhbnNhY3Rpb24uciA9IHIgPT09ICcweCcgPyAwbiA6IEJpZ0ludChyKTtcbiAgICBhc3NlcnQodHJhbnNhY3Rpb24pO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbn1cbi8qKlxuICogQ29udmVydHMgYW4gYXJiaXRyYXJ5IHRyYW5zYWN0aW9uIG9iamVjdCBpbnRvIGEgbGVnYWN5IFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZnJvbSh7XG4gKiAgIGdhc1ByaWNlOiBWYWx1ZS5mcm9tR3dlaSgnMTAnKSxcbiAqICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogICB2YWx1ZTogVmFsdWUuZnJvbUV0aGVyKCcxJyksXG4gKiB9KVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqICMjIyBBdHRhY2hpbmcgU2lnbmF0dXJlc1xuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRvIGF0dGFjaCBhIGBzaWduYXR1cmVgIHRvIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3QgZW52ZWxvcGVfc2lnbmVkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGF1dGhvcml6YXRpb25MaXN0OiBbLi4uXSxcbiAqIC8vIEBsb2c6ICAgY2hhaW5JZDogMSxcbiAqIC8vIEBsb2c6ICAgZ2FzUHJpY2U6IDEwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgdG86ICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICogLy8gQGxvZzogICB0eXBlOiAnZWlwNzcwMicsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6ICAgcjogMTI1Li4ubixcbiAqIC8vIEBsb2c6ICAgczogNjQyLi4ubixcbiAqIC8vIEBsb2c6ICAgeVBhcml0eTogMCxcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlXG4gKiAjIyMgRnJvbSBTZXJpYWxpemVkXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gaW5zdGFudGlhdGUgYW4gbGVnYWN5IFRyYW5zYWN0aW9uIEVudmVsb3BlIGZyb20gYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5TZXJpYWxpemVkfSB2YWx1ZS5cbiAqXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKCcweGY4NTgwMTgyMDMxMTg1MDI1NDBiZTQwMDg1MDRhODE3YzgwMDgwOTQ3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4ODgwZGUwYjZiM2E3NjQwMDAwODBjMDg0NzczNTk0MDBlMWEwMDE2MjdjNjg3MjYxYjBlN2Y4NjM4YWYxMTEyZWZhOGE3N2UyMzY1NmY2ZTc5NDUyNzViMTllOWRlZWQ4MDI2MScpXG4gKiAvLyBAbG9nOiB7XG4gKiAvLyBAbG9nOiAgIGNoYWluSWQ6IDEsXG4gKiAvLyBAbG9nOiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwMG4sXG4gKiAvLyBAbG9nOiAgIHRvOiAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAqIC8vIEBsb2c6ICAgdHlwZTogJ2xlZ2FjeScsXG4gKiAvLyBAbG9nOiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIC8vIEBsb2c6IH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSB0cmFuc2FjdGlvbiBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIEEgbGVnYWN5IFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbShlbnZlbG9wZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgeyBzaWduYXR1cmUgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgZW52ZWxvcGVfID0gKHR5cGVvZiBlbnZlbG9wZSA9PT0gJ3N0cmluZycgPyBkZXNlcmlhbGl6ZShlbnZlbG9wZSkgOiBlbnZlbG9wZSk7XG4gICAgYXNzZXJ0KGVudmVsb3BlXyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlXyA9ICgoKSA9PiB7XG4gICAgICAgIGlmICghc2lnbmF0dXJlKVxuICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICBjb25zdCBzID0gU2lnbmF0dXJlLmZyb20oc2lnbmF0dXJlKTtcbiAgICAgICAgcy52ID0gU2lnbmF0dXJlLnlQYXJpdHlUb1Yocy55UGFyaXR5KTtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgfSkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5lbnZlbG9wZV8sXG4gICAgICAgIC4uLnNpZ25hdHVyZV8sXG4gICAgICAgIHR5cGU6ICdsZWdhY3knLFxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHBheWxvYWQgdG8gc2lnbiBmb3IgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogVGhlIGV4YW1wbGUgYmVsb3cgZGVtb25zdHJhdGVzIGhvdyB0byBjb21wdXRlIHRoZSBzaWduIHBheWxvYWQgd2hpY2ggY2FuIGJlIHVzZWRcbiAqIHdpdGggRUNEU0Egc2lnbmluZyB1dGlsaXRpZXMgbGlrZSB7QGxpbmsgb3gjU2VjcDI1NmsxLihzaWduOmZ1bmN0aW9uKX0uXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5IH0gZnJvbSAnb3gnXG4gKlxuICogY29uc3QgZW52ZWxvcGUgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oe1xuICogICBub25jZTogMG4sXG4gKiAgIGdhc1ByaWNlOiAxMDAwMDAwMDAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IDEwMDAwMDAwMDAwMDAwMDAwMDBuLFxuICogfSlcbiAqXG4gKiBjb25zdCBwYXlsb2FkID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5nZXRTaWduUGF5bG9hZChlbnZlbG9wZSkgLy8gWyFjb2RlIGZvY3VzXVxuICogLy8gQGxvZzogJzB4Li4uJ1xuICpcbiAqIGNvbnN0IHNpZ25hdHVyZSA9IFNlY3AyNTZrMS5zaWduKHsgcGF5bG9hZCwgcHJpdmF0ZUtleTogJzB4Li4uJyB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGdldCB0aGUgc2lnbiBwYXlsb2FkIGZvci5cbiAqIEByZXR1cm5zIFRoZSBzaWduIHBheWxvYWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaWduUGF5bG9hZChlbnZlbG9wZSkge1xuICAgIHJldHVybiBoYXNoKGVudmVsb3BlLCB7IHByZXNpZ246IHRydWUgfSk7XG59XG4vKipcbiAqIEhhc2hlcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9LiBUaGlzIGlzIHRoZSBcInRyYW5zYWN0aW9uIGhhc2hcIi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFNlY3AyNTZrMSwgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgbm9uY2U6IDBuLFxuICogICBnYXNQcmljZTogMTAwMDAwMDAwMG4sXG4gKiAgIGdhczogMjEwMDBuLFxuICogICB0bzogJzB4NzA5OTc5NzBjNTE4MTJkYzNhMDEwYzdkMDFiNTBlMGQxN2RjNzljOCcsXG4gKiAgIHZhbHVlOiAxMDAwMDAwMDAwMDAwMDAwMDAwbixcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJ1xuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9zaWduZWQgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmZyb20oZW52ZWxvcGUsIHsgc2lnbmF0dXJlIH0pXG4gKlxuICogY29uc3QgaGFzaCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuaGFzaChlbnZlbG9wZV9zaWduZWQpIC8vIFshY29kZSBmb2N1c11cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBlbnZlbG9wZSAtIFRoZSBMZWdhY3kgVHJhbnNhY3Rpb24gRW52ZWxvcGUgdG8gaGFzaC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBoYXNoIG9mIHRoZSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2goZW52ZWxvcGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHsgcHJlc2lnbiB9ID0gb3B0aW9ucztcbiAgICByZXR1cm4gSGFzaC5rZWNjYWsyNTYoc2VyaWFsaXplKHtcbiAgICAgICAgLi4uZW52ZWxvcGUsXG4gICAgICAgIC4uLihwcmVzaWduXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICByOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgczogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHlQYXJpdHk6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB2OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICB9KSk7XG59XG4vKipcbiAqIFNlcmlhbGl6ZXMgYSB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5fS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuc2VyaWFsaXplKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZVxuICogIyMjIEF0dGFjaGluZyBTaWduYXR1cmVzXG4gKlxuICogSXQgaXMgcG9zc2libGUgdG8gYXR0YWNoIGEgYHNpZ25hdHVyZWAgdG8gdGhlIHNlcmlhbGl6ZWQgVHJhbnNhY3Rpb24gRW52ZWxvcGUuXG4gKlxuICogYGBgdHMgdHdvc2xhc2hcbiAqIC8vIEBub0Vycm9yc1xuICogaW1wb3J0IHsgU2VjcDI1NmsxLCBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LCBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIGNvbnN0IGVudmVsb3BlID0gVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5mcm9tKHtcbiAqICAgY2hhaW5JZDogMSxcbiAqICAgZ2FzUHJpY2U6IFZhbHVlLmZyb21Hd2VpKCcxMCcpLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2lnbmF0dXJlID0gU2VjcDI1NmsxLnNpZ24oe1xuICogICBwYXlsb2FkOiBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LmdldFNpZ25QYXlsb2FkKGVudmVsb3BlKSxcbiAqICAgcHJpdmF0ZUtleTogJzB4Li4uJyxcbiAqIH0pXG4gKlxuICogY29uc3Qgc2VyaWFsaXplZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuc2VyaWFsaXplKGVudmVsb3BlLCB7IC8vIFshY29kZSBmb2N1c11cbiAqICAgc2lnbmF0dXJlLCAvLyBbIWNvZGUgZm9jdXNdXG4gKiB9KSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogLy8gLi4uIHNlbmQgYHNlcmlhbGl6ZWRgIHRyYW5zYWN0aW9uIHRvIEpTT04tUlBDIGBldGhfc2VuZFJhd1RyYW5zYWN0aW9uYFxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIFRyYW5zYWN0aW9uIEVudmVsb3BlIHRvIHNlcmlhbGl6ZS5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIFRyYW5zYWN0aW9uIEVudmVsb3BlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplKGVudmVsb3BlLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNoYWluSWQgPSAwLCBnYXMsIGRhdGEsIGlucHV0LCBub25jZSwgdG8sIHZhbHVlLCBnYXNQcmljZSB9ID0gZW52ZWxvcGU7XG4gICAgYXNzZXJ0KGVudmVsb3BlKTtcbiAgICBsZXQgc2VyaWFsaXplZCA9IFtcbiAgICAgICAgbm9uY2UgPyBIZXguZnJvbU51bWJlcihub25jZSkgOiAnMHgnLFxuICAgICAgICBnYXNQcmljZSA/IEhleC5mcm9tTnVtYmVyKGdhc1ByaWNlKSA6ICcweCcsXG4gICAgICAgIGdhcyA/IEhleC5mcm9tTnVtYmVyKGdhcykgOiAnMHgnLFxuICAgICAgICB0byA/PyAnMHgnLFxuICAgICAgICB2YWx1ZSA/IEhleC5mcm9tTnVtYmVyKHZhbHVlKSA6ICcweCcsXG4gICAgICAgIGRhdGEgPz8gaW5wdXQgPz8gJzB4JyxcbiAgICBdO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hdHVyZSlcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcjogb3B0aW9ucy5zaWduYXR1cmUucixcbiAgICAgICAgICAgICAgICBzOiBvcHRpb25zLnNpZ25hdHVyZS5zLFxuICAgICAgICAgICAgICAgIHY6IFNpZ25hdHVyZS55UGFyaXR5VG9WKG9wdGlvbnMuc2lnbmF0dXJlLnlQYXJpdHkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnZlbG9wZS5yID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgZW52ZWxvcGUucyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcjogZW52ZWxvcGUucixcbiAgICAgICAgICAgIHM6IGVudmVsb3BlLnMsXG4gICAgICAgICAgICB2OiBlbnZlbG9wZS52LFxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgaWYgKHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCB2ID0gKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEVJUC0xNTUgKGluZmVycmVkIGNoYWluSWQpXG4gICAgICAgICAgICBpZiAoc2lnbmF0dXJlLnYgPj0gMzUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmZlcnJlZENoYWluSWQgPSBNYXRoLmZsb29yKChzaWduYXR1cmUudiAtIDM1KSAvIDIpO1xuICAgICAgICAgICAgICAgIGlmIChpbmZlcnJlZENoYWluSWQgPiAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlLnY7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDI3ICsgKHNpZ25hdHVyZS52ID09PSAzNSA/IDAgOiAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVJUC0xNTUgKGV4cGxpY2l0IGNoYWluSWQpXG4gICAgICAgICAgICBpZiAoY2hhaW5JZCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoYWluSWQgKiAyICsgMzUgKyBzaWduYXR1cmUudiAtIDI3O1xuICAgICAgICAgICAgLy8gUHJlLUVJUC0xNTUgKG5vIGNoYWluSWQpXG4gICAgICAgICAgICBjb25zdCB2ID0gMjcgKyAoc2lnbmF0dXJlLnYgPT09IDI3ID8gMCA6IDEpO1xuICAgICAgICAgICAgaWYgKHNpZ25hdHVyZS52ICE9PSB2KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTaWduYXR1cmUuSW52YWxpZFZFcnJvcih7IHZhbHVlOiBzaWduYXR1cmUudiB9KTtcbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9KSgpO1xuICAgICAgICBzZXJpYWxpemVkID0gW1xuICAgICAgICAgICAgLi4uc2VyaWFsaXplZCxcbiAgICAgICAgICAgIEhleC5mcm9tTnVtYmVyKHYpLFxuICAgICAgICAgICAgc2lnbmF0dXJlLnIgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihzaWduYXR1cmUucikpLFxuICAgICAgICAgICAgc2lnbmF0dXJlLnMgPT09IDBuID8gJzB4JyA6IEhleC50cmltTGVmdChIZXguZnJvbU51bWJlcihzaWduYXR1cmUucykpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGFpbklkID4gMClcbiAgICAgICAgc2VyaWFsaXplZCA9IFsuLi5zZXJpYWxpemVkLCBIZXguZnJvbU51bWJlcihjaGFpbklkKSwgJzB4JywgJzB4J107XG4gICAgcmV0dXJuIFJscC5mcm9tSGV4KHNlcmlhbGl6ZWQpO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5UcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5fSB0byBhbiB7QGxpbmsgb3gjVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5ScGN9LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgUnBjUmVxdWVzdCwgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCBlbnZlbG9wZSA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuZnJvbSh7XG4gKiAgIGNoYWluSWQ6IDEsXG4gKiAgIG5vbmNlOiAwbixcbiAqICAgZ2FzOiAyMTAwMG4sXG4gKiAgIHRvOiAnMHg3MDk5Nzk3MGM1MTgxMmRjM2EwMTBjN2QwMWI1MGUwZDE3ZGM3OWM4JyxcbiAqICAgdmFsdWU6IFZhbHVlLmZyb21FdGhlcignMScpLFxuICogfSlcbiAqXG4gKiBjb25zdCBlbnZlbG9wZV9ycGMgPSBUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LnRvUnBjKGVudmVsb3BlKSAvLyBbIWNvZGUgZm9jdXNdXG4gKlxuICogY29uc3QgcmVxdWVzdCA9IFJwY1JlcXVlc3QuZnJvbSh7XG4gKiAgIGlkOiAwLFxuICogICBtZXRob2Q6ICdldGhfc2VuZFRyYW5zYWN0aW9uJyxcbiAqICAgcGFyYW1zOiBbZW52ZWxvcGVfcnBjXSxcbiAqIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZW52ZWxvcGUgLSBUaGUgbGVnYWN5IHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBbiBSUEMtZm9ybWF0dGVkIGxlZ2FjeSB0cmFuc2FjdGlvbiBlbnZlbG9wZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvUnBjKGVudmVsb3BlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gU2lnbmF0dXJlLmV4dHJhY3QoZW52ZWxvcGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmVudmVsb3BlLFxuICAgICAgICBjaGFpbklkOiB0eXBlb2YgZW52ZWxvcGUuY2hhaW5JZCA9PT0gJ251bWJlcidcbiAgICAgICAgICAgID8gSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuY2hhaW5JZClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICBkYXRhOiBlbnZlbG9wZS5kYXRhID8/IGVudmVsb3BlLmlucHV0LFxuICAgICAgICB0eXBlOiAnMHgwJyxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5nYXMgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgZ2FzOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5nYXMpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4odHlwZW9mIGVudmVsb3BlLm5vbmNlID09PSAnYmlnaW50J1xuICAgICAgICAgICAgPyB7IG5vbmNlOiBIZXguZnJvbU51bWJlcihlbnZlbG9wZS5ub25jZSkgfVxuICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgZW52ZWxvcGUudmFsdWUgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICA/IHsgdmFsdWU6IEhleC5mcm9tTnVtYmVyKGVudmVsb3BlLnZhbHVlKSB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgLi4uKHR5cGVvZiBlbnZlbG9wZS5nYXNQcmljZSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgID8geyBnYXNQcmljZTogSGV4LmZyb21OdW1iZXIoZW52ZWxvcGUuZ2FzUHJpY2UpIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgICAgICAuLi4oc2lnbmF0dXJlXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAuLi5TaWduYXR1cmUudG9ScGMoc2lnbmF0dXJlKSxcbiAgICAgICAgICAgICAgICB2OiBzaWduYXR1cmUueVBhcml0eSA9PT0gMCA/ICcweDFiJyA6ICcweDFjJyxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge30pLFxuICAgIH07XG59XG4vKipcbiAqIFZhbGlkYXRlcyBhIHtAbGluayBveCNUcmFuc2FjdGlvbkVudmVsb3BlTGVnYWN5LlRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3l9LiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW52ZWxvcGUgaXMgdmFsaWQsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeSwgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBjb25zdCB2YWxpZCA9IFRyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kuYXNzZXJ0KHtcbiAqICAgZ2FzUHJpY2U6IDJuICoqIDI1Nm4gLSAxbiArIDFuLFxuICogICBjaGFpbklkOiAxLFxuICogICB0bzogJzB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gKiAgIHZhbHVlOiBWYWx1ZS5mcm9tRXRoZXIoJzEnKSxcbiAqIH0pXG4gKiAvLyBAbG9nOiBmYWxzZVxuICogYGBgXG4gKlxuICogQHBhcmFtIGVudmVsb3BlIC0gVGhlIHRyYW5zYWN0aW9uIGVudmVsb3BlIHRvIHZhbGlkYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGUoZW52ZWxvcGUpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnQoZW52ZWxvcGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ox/_esm/core/Value.js":
/*!********************************************!*\
  !*** ./node_modules/ox/_esm/core/Value.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   InvalidDecimalNumberError: () => (/* binding */ InvalidDecimalNumberError),\n/* harmony export */   exponents: () => (/* binding */ exponents),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   formatEther: () => (/* binding */ formatEther),\n/* harmony export */   formatGwei: () => (/* binding */ formatGwei),\n/* harmony export */   from: () => (/* binding */ from),\n/* harmony export */   fromEther: () => (/* binding */ fromEther),\n/* harmony export */   fromGwei: () => (/* binding */ fromGwei)\n/* harmony export */ });\n/* harmony import */ var _Errors_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Errors.js */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Errors.js\");\n\n/** @see https://ethereum.github.io/yellowpaper/paper.pdf */\nconst exponents = {\n    wei: 0,\n    gwei: 9,\n    szabo: 12,\n    finney: 15,\n    ether: 18,\n};\n/**\n * Formats a `bigint` Value to its string representation (divided by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.format(420_000_000_000n, 9)\n * // @log: '420'\n * ```\n *\n * @param value - The `bigint` Value to format.\n * @param decimals - The exponent to divide the `bigint` Value by.\n * @returns The string representation of the Value.\n */\nfunction format(value, decimals = 0) {\n    let display = value.toString();\n    const negative = display.startsWith('-');\n    if (negative)\n        display = display.slice(1);\n    display = display.padStart(decimals, '0');\n    let [integer, fraction] = [\n        display.slice(0, display.length - decimals),\n        display.slice(display.length - decimals),\n    ];\n    fraction = fraction.replace(/(0+)$/, '');\n    return `${negative ? '-' : ''}${integer || '0'}${fraction ? `.${fraction}` : ''}`;\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Ether.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatEther(1_000_000_000_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Ether string representation of the Value.\n */\nfunction formatEther(wei, unit = 'wei') {\n    return format(wei, exponents.ether - exponents[unit]);\n}\n/**\n * Formats a `bigint` Value (default: wei) to a string representation of Gwei.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.formatGwei(1_000_000_000n)\n * // @log: '1'\n * ```\n *\n * @param wei - The Value to format.\n * @param unit - The unit to format the Value in. @default 'wei'.\n * @returns The Gwei string representation of the Value.\n */\nfunction formatGwei(wei, unit = 'wei') {\n    return format(wei, exponents.gwei - exponents[unit]);\n}\n/**\n * Parses a `string` representation of a Value to `bigint` (multiplied by the given exponent).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.from('420', 9)\n * // @log: 420000000000n\n * ```\n *\n * @param value - The string representation of the Value.\n * @param decimals - The exponent to multiply the Value by.\n * @returns The `bigint` representation of the Value.\n */\nfunction from(value, decimals = 0) {\n    if (!/^(-?)([0-9]*)\\.?([0-9]*)$/.test(value))\n        throw new InvalidDecimalNumberError({ value });\n    let [integer = '', fraction = '0'] = value.split('.');\n    const negative = integer.startsWith('-');\n    if (negative)\n        integer = integer.slice(1);\n    // trim trailing zeros.\n    fraction = fraction.replace(/(0+)$/, '');\n    // round off if the fraction is larger than the number of decimals.\n    if (decimals === 0) {\n        if (Math.round(Number(`.${fraction}`)) === 1)\n            integer = `${BigInt(integer) + 1n}`;\n        fraction = '';\n    }\n    else if (fraction.length > decimals) {\n        const [left, unit, right] = [\n            fraction.slice(0, decimals - 1),\n            fraction.slice(decimals - 1, decimals),\n            fraction.slice(decimals),\n        ];\n        const rounded = Math.round(Number(`${unit}.${right}`));\n        if (rounded > 9)\n            fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, '0');\n        else\n            fraction = `${left}${rounded}`;\n        if (fraction.length > decimals) {\n            fraction = fraction.slice(1);\n            integer = `${BigInt(integer) + 1n}`;\n        }\n        fraction = fraction.slice(0, decimals);\n    }\n    else {\n        fraction = fraction.padEnd(decimals, '0');\n    }\n    return BigInt(`${negative ? '-' : ''}${integer}${fraction}`);\n}\n/**\n * Parses a string representation of Ether to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('420')\n * // @log: 420000000000000000000n\n * ```\n *\n * @param ether - String representation of Ether.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nfunction fromEther(ether, unit = 'wei') {\n    return from(ether, exponents.ether - exponents[unit]);\n}\n/**\n * Parses a string representation of Gwei to a `bigint` Value (default: wei).\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromGwei('420')\n * // @log: 420000000000n\n * ```\n *\n * @param gwei - String representation of Gwei.\n * @param unit - The unit to parse to. @default 'wei'.\n * @returns A `bigint` Value.\n */\nfunction fromGwei(gwei, unit = 'wei') {\n    return from(gwei, exponents.gwei - exponents[unit]);\n}\n/**\n * Thrown when a value is not a valid decimal number.\n *\n * @example\n * ```ts twoslash\n * import { Value } from 'ox'\n *\n * Value.fromEther('123.456.789')\n * // @error: Value.InvalidDecimalNumberError: Value `123.456.789` is not a valid decimal number.\n * ```\n */\nclass InvalidDecimalNumberError extends _Errors_js__WEBPACK_IMPORTED_MODULE_0__.BaseError {\n    constructor({ value }) {\n        super(`Value \\`${value}\\` is not a valid decimal number.`);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 'Value.InvalidDecimalNumberError'\n        });\n    }\n}\n//# sourceMappingURL=Value.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVmFsdWUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQXNDO0FBQ3RDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9CQUFvQixFQUFFLGVBQWUsRUFBRSxlQUFlLFNBQVMsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw4Q0FBOEMsT0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0MseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUssR0FBRyxNQUFNO0FBQzNEO0FBQ0EsMEJBQTBCLHlCQUF5QjtBQUNuRDtBQUNBLDBCQUEwQixLQUFLLEVBQUUsUUFBUTtBQUN6QztBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CLEVBQUUsUUFBUSxFQUFFLFNBQVM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sd0NBQXdDLGlEQUFnQjtBQUMvRCxrQkFBa0IsT0FBTztBQUN6Qix5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL21paW5hZG9pL0Rlc2t0b3AvZ2l0aHViUHJvamVjdC90aHJpZHdlYnR1dG9yaWFsL25vZGVfbW9kdWxlcy9veC9fZXNtL2NvcmUvVmFsdWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gJy4vRXJyb3JzLmpzJztcbi8qKiBAc2VlIGh0dHBzOi8vZXRoZXJldW0uZ2l0aHViLmlvL3llbGxvd3BhcGVyL3BhcGVyLnBkZiAqL1xuZXhwb3J0IGNvbnN0IGV4cG9uZW50cyA9IHtcbiAgICB3ZWk6IDAsXG4gICAgZ3dlaTogOSxcbiAgICBzemFibzogMTIsXG4gICAgZmlubmV5OiAxNSxcbiAgICBldGhlcjogMTgsXG59O1xuLyoqXG4gKiBGb3JtYXRzIGEgYGJpZ2ludGAgVmFsdWUgdG8gaXRzIHN0cmluZyByZXByZXNlbnRhdGlvbiAoZGl2aWRlZCBieSB0aGUgZ2l2ZW4gZXhwb25lbnQpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBWYWx1ZS5mb3JtYXQoNDIwXzAwMF8wMDBfMDAwbiwgOSlcbiAqIC8vIEBsb2c6ICc0MjAnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gdmFsdWUgLSBUaGUgYGJpZ2ludGAgVmFsdWUgdG8gZm9ybWF0LlxuICogQHBhcmFtIGRlY2ltYWxzIC0gVGhlIGV4cG9uZW50IHRvIGRpdmlkZSB0aGUgYGJpZ2ludGAgVmFsdWUgYnkuXG4gKiBAcmV0dXJucyBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdCh2YWx1ZSwgZGVjaW1hbHMgPSAwKSB7XG4gICAgbGV0IGRpc3BsYXkgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gZGlzcGxheS5zdGFydHNXaXRoKCctJyk7XG4gICAgaWYgKG5lZ2F0aXZlKVxuICAgICAgICBkaXNwbGF5ID0gZGlzcGxheS5zbGljZSgxKTtcbiAgICBkaXNwbGF5ID0gZGlzcGxheS5wYWRTdGFydChkZWNpbWFscywgJzAnKTtcbiAgICBsZXQgW2ludGVnZXIsIGZyYWN0aW9uXSA9IFtcbiAgICAgICAgZGlzcGxheS5zbGljZSgwLCBkaXNwbGF5Lmxlbmd0aCAtIGRlY2ltYWxzKSxcbiAgICAgICAgZGlzcGxheS5zbGljZShkaXNwbGF5Lmxlbmd0aCAtIGRlY2ltYWxzKSxcbiAgICBdO1xuICAgIGZyYWN0aW9uID0gZnJhY3Rpb24ucmVwbGFjZSgvKDArKSQvLCAnJyk7XG4gICAgcmV0dXJuIGAke25lZ2F0aXZlID8gJy0nIDogJyd9JHtpbnRlZ2VyIHx8ICcwJ30ke2ZyYWN0aW9uID8gYC4ke2ZyYWN0aW9ufWAgOiAnJ31gO1xufVxuLyoqXG4gKiBGb3JtYXRzIGEgYGJpZ2ludGAgVmFsdWUgKGRlZmF1bHQ6IHdlaSkgdG8gYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgRXRoZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZvcm1hdEV0aGVyKDFfMDAwXzAwMF8wMDBfMDAwXzAwMF8wMDBuKVxuICogLy8gQGxvZzogJzEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd2VpIC0gVGhlIFZhbHVlIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gZm9ybWF0IHRoZSBWYWx1ZSBpbi4gQGRlZmF1bHQgJ3dlaScuXG4gKiBAcmV0dXJucyBUaGUgRXRoZXIgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEV0aGVyKHdlaSwgdW5pdCA9ICd3ZWknKSB7XG4gICAgcmV0dXJuIGZvcm1hdCh3ZWksIGV4cG9uZW50cy5ldGhlciAtIGV4cG9uZW50c1t1bml0XSk7XG59XG4vKipcbiAqIEZvcm1hdHMgYSBgYmlnaW50YCBWYWx1ZSAoZGVmYXVsdDogd2VpKSB0byBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBHd2VpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cyB0d29zbGFzaFxuICogaW1wb3J0IHsgVmFsdWUgfSBmcm9tICdveCdcbiAqXG4gKiBWYWx1ZS5mb3JtYXRHd2VpKDFfMDAwXzAwMF8wMDBuKVxuICogLy8gQGxvZzogJzEnXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gd2VpIC0gVGhlIFZhbHVlIHRvIGZvcm1hdC5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gZm9ybWF0IHRoZSBWYWx1ZSBpbi4gQGRlZmF1bHQgJ3dlaScuXG4gKiBAcmV0dXJucyBUaGUgR3dlaSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhbHVlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0R3dlaSh3ZWksIHVuaXQgPSAnd2VpJykge1xuICAgIHJldHVybiBmb3JtYXQod2VpLCBleHBvbmVudHMuZ3dlaSAtIGV4cG9uZW50c1t1bml0XSk7XG59XG4vKipcbiAqIFBhcnNlcyBhIGBzdHJpbmdgIHJlcHJlc2VudGF0aW9uIG9mIGEgVmFsdWUgdG8gYGJpZ2ludGAgKG11bHRpcGxpZWQgYnkgdGhlIGdpdmVuIGV4cG9uZW50KS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZnJvbSgnNDIwJywgOSlcbiAqIC8vIEBsb2c6IDQyMDAwMDAwMDAwMG5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIFZhbHVlLlxuICogQHBhcmFtIGRlY2ltYWxzIC0gVGhlIGV4cG9uZW50IHRvIG11bHRpcGx5IHRoZSBWYWx1ZSBieS5cbiAqIEByZXR1cm5zIFRoZSBgYmlnaW50YCByZXByZXNlbnRhdGlvbiBvZiB0aGUgVmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tKHZhbHVlLCBkZWNpbWFscyA9IDApIHtcbiAgICBpZiAoIS9eKC0/KShbMC05XSopXFwuPyhbMC05XSopJC8udGVzdCh2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkRGVjaW1hbE51bWJlckVycm9yKHsgdmFsdWUgfSk7XG4gICAgbGV0IFtpbnRlZ2VyID0gJycsIGZyYWN0aW9uID0gJzAnXSA9IHZhbHVlLnNwbGl0KCcuJyk7XG4gICAgY29uc3QgbmVnYXRpdmUgPSBpbnRlZ2VyLnN0YXJ0c1dpdGgoJy0nKTtcbiAgICBpZiAobmVnYXRpdmUpXG4gICAgICAgIGludGVnZXIgPSBpbnRlZ2VyLnNsaWNlKDEpO1xuICAgIC8vIHRyaW0gdHJhaWxpbmcgemVyb3MuXG4gICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5yZXBsYWNlKC8oMCspJC8sICcnKTtcbiAgICAvLyByb3VuZCBvZmYgaWYgdGhlIGZyYWN0aW9uIGlzIGxhcmdlciB0aGFuIHRoZSBudW1iZXIgb2YgZGVjaW1hbHMuXG4gICAgaWYgKGRlY2ltYWxzID09PSAwKSB7XG4gICAgICAgIGlmIChNYXRoLnJvdW5kKE51bWJlcihgLiR7ZnJhY3Rpb259YCkpID09PSAxKVxuICAgICAgICAgICAgaW50ZWdlciA9IGAke0JpZ0ludChpbnRlZ2VyKSArIDFufWA7XG4gICAgICAgIGZyYWN0aW9uID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZyYWN0aW9uLmxlbmd0aCA+IGRlY2ltYWxzKSB7XG4gICAgICAgIGNvbnN0IFtsZWZ0LCB1bml0LCByaWdodF0gPSBbXG4gICAgICAgICAgICBmcmFjdGlvbi5zbGljZSgwLCBkZWNpbWFscyAtIDEpLFxuICAgICAgICAgICAgZnJhY3Rpb24uc2xpY2UoZGVjaW1hbHMgLSAxLCBkZWNpbWFscyksXG4gICAgICAgICAgICBmcmFjdGlvbi5zbGljZShkZWNpbWFscyksXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHJvdW5kZWQgPSBNYXRoLnJvdW5kKE51bWJlcihgJHt1bml0fS4ke3JpZ2h0fWApKTtcbiAgICAgICAgaWYgKHJvdW5kZWQgPiA5KVxuICAgICAgICAgICAgZnJhY3Rpb24gPSBgJHtCaWdJbnQobGVmdCkgKyBCaWdJbnQoMSl9MGAucGFkU3RhcnQobGVmdC5sZW5ndGggKyAxLCAnMCcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBmcmFjdGlvbiA9IGAke2xlZnR9JHtyb3VuZGVkfWA7XG4gICAgICAgIGlmIChmcmFjdGlvbi5sZW5ndGggPiBkZWNpbWFscykge1xuICAgICAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zbGljZSgxKTtcbiAgICAgICAgICAgIGludGVnZXIgPSBgJHtCaWdJbnQoaW50ZWdlcikgKyAxbn1gO1xuICAgICAgICB9XG4gICAgICAgIGZyYWN0aW9uID0gZnJhY3Rpb24uc2xpY2UoMCwgZGVjaW1hbHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5wYWRFbmQoZGVjaW1hbHMsICcwJyk7XG4gICAgfVxuICAgIHJldHVybiBCaWdJbnQoYCR7bmVnYXRpdmUgPyAnLScgOiAnJ30ke2ludGVnZXJ9JHtmcmFjdGlvbn1gKTtcbn1cbi8qKlxuICogUGFyc2VzIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIEV0aGVyIHRvIGEgYGJpZ2ludGAgVmFsdWUgKGRlZmF1bHQ6IHdlaSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZyb21FdGhlcignNDIwJylcbiAqIC8vIEBsb2c6IDQyMDAwMDAwMDAwMDAwMDAwMDAwMG5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBldGhlciAtIFN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBFdGhlci5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gcGFyc2UgdG8uIEBkZWZhdWx0ICd3ZWknLlxuICogQHJldHVybnMgQSBgYmlnaW50YCBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21FdGhlcihldGhlciwgdW5pdCA9ICd3ZWknKSB7XG4gICAgcmV0dXJuIGZyb20oZXRoZXIsIGV4cG9uZW50cy5ldGhlciAtIGV4cG9uZW50c1t1bml0XSk7XG59XG4vKipcbiAqIFBhcnNlcyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBHd2VpIHRvIGEgYGJpZ2ludGAgVmFsdWUgKGRlZmF1bHQ6IHdlaSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzIHR3b3NsYXNoXG4gKiBpbXBvcnQgeyBWYWx1ZSB9IGZyb20gJ294J1xuICpcbiAqIFZhbHVlLmZyb21Hd2VpKCc0MjAnKVxuICogLy8gQGxvZzogNDIwMDAwMDAwMDAwblxuICogYGBgXG4gKlxuICogQHBhcmFtIGd3ZWkgLSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgR3dlaS5cbiAqIEBwYXJhbSB1bml0IC0gVGhlIHVuaXQgdG8gcGFyc2UgdG8uIEBkZWZhdWx0ICd3ZWknLlxuICogQHJldHVybnMgQSBgYmlnaW50YCBWYWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21Hd2VpKGd3ZWksIHVuaXQgPSAnd2VpJykge1xuICAgIHJldHVybiBmcm9tKGd3ZWksIGV4cG9uZW50cy5nd2VpIC0gZXhwb25lbnRzW3VuaXRdKTtcbn1cbi8qKlxuICogVGhyb3duIHdoZW4gYSB2YWx1ZSBpcyBub3QgYSB2YWxpZCBkZWNpbWFsIG51bWJlci5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMgdHdvc2xhc2hcbiAqIGltcG9ydCB7IFZhbHVlIH0gZnJvbSAnb3gnXG4gKlxuICogVmFsdWUuZnJvbUV0aGVyKCcxMjMuNDU2Ljc4OScpXG4gKiAvLyBAZXJyb3I6IFZhbHVlLkludmFsaWREZWNpbWFsTnVtYmVyRXJyb3I6IFZhbHVlIGAxMjMuNDU2Ljc4OWAgaXMgbm90IGEgdmFsaWQgZGVjaW1hbCBudW1iZXIuXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEludmFsaWREZWNpbWFsTnVtYmVyRXJyb3IgZXh0ZW5kcyBFcnJvcnMuQmFzZUVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih7IHZhbHVlIH0pIHtcbiAgICAgICAgc3VwZXIoYFZhbHVlIFxcYCR7dmFsdWV9XFxgIGlzIG5vdCBhIHZhbGlkIGRlY2ltYWwgbnVtYmVyLmApO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJuYW1lXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiAnVmFsdWUuSW52YWxpZERlY2ltYWxOdW1iZXJFcnJvcidcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VmFsdWUuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ox/_esm/core/Value.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/gas/estimate-l1-fee.js":
/*!***************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/gas/estimate-l1-fee.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   estimateL1Fee: () => (/* binding */ estimateL1Fee)\n/* harmony export */ });\n/* harmony import */ var _contract_contract_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../contract/contract.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/contract/contract.js\");\n/* harmony import */ var _transaction_actions_to_serializable_transaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../transaction/actions/to-serializable-transaction.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/actions/to-serializable-transaction.js\");\n/* harmony import */ var _transaction_read_contract_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../transaction/read-contract.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/read-contract.js\");\n/* harmony import */ var _transaction_serialize_transaction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../transaction/serialize-transaction.js */ \"(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js\");\n\n\n\n\nconst OPStackGasPriceOracleAddress = \"0x420000000000000000000000000000000000000F\";\n/**\n * @internal\n */\nasync function estimateL1Fee(options) {\n    const { transaction, gasPriceOracleAddress } = options;\n    const oracleContract = (0,_contract_contract_js__WEBPACK_IMPORTED_MODULE_0__.getContract)({\n        client: transaction.client,\n        address: gasPriceOracleAddress || OPStackGasPriceOracleAddress,\n        chain: transaction.chain,\n    });\n    // purposefully remove gasPrice from the transaction\n    const { gasPrice, ...serializableTx } = await (0,_transaction_actions_to_serializable_transaction_js__WEBPACK_IMPORTED_MODULE_1__.toSerializableTransaction)({\n        transaction,\n    });\n    const serialized = (0,_transaction_serialize_transaction_js__WEBPACK_IMPORTED_MODULE_2__.serializeTransaction)({\n        transaction: serializableTx,\n    });\n    //serializeTransaction(transaction);\n    return (0,_transaction_read_contract_js__WEBPACK_IMPORTED_MODULE_3__.readContract)({\n        contract: oracleContract,\n        method: \"function getL1Fee(bytes memory _data) view returns (uint256)\",\n        params: [serialized],\n    });\n}\n//# sourceMappingURL=estimate-l1-fee.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS9nYXMvZXN0aW1hdGUtbDEtZmVlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNEO0FBQzRDO0FBQ25DO0FBQ2dCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxZQUFZLHFDQUFxQztBQUNqRCwyQkFBMkIsa0VBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWSw4QkFBOEIsUUFBUSw4R0FBeUI7QUFDM0U7QUFDQSxLQUFLO0FBQ0wsdUJBQXVCLDJGQUFvQjtBQUMzQztBQUNBLEtBQUs7QUFDTDtBQUNBLFdBQVcsMkVBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taWluYWRvaS9EZXNrdG9wL2dpdGh1YlByb2plY3QvdGhyaWR3ZWJ0dXRvcmlhbC9ub2RlX21vZHVsZXMvdGhpcmR3ZWIvZGlzdC9lc20vZ2FzL2VzdGltYXRlLWwxLWZlZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRDb250cmFjdCB9IGZyb20gXCIuLi9jb250cmFjdC9jb250cmFjdC5qc1wiO1xuaW1wb3J0IHsgdG9TZXJpYWxpemFibGVUcmFuc2FjdGlvbiB9IGZyb20gXCIuLi90cmFuc2FjdGlvbi9hY3Rpb25zL3RvLXNlcmlhbGl6YWJsZS10cmFuc2FjdGlvbi5qc1wiO1xuaW1wb3J0IHsgcmVhZENvbnRyYWN0IH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL3JlYWQtY29udHJhY3QuanNcIjtcbmltcG9ydCB7IHNlcmlhbGl6ZVRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL3RyYW5zYWN0aW9uL3NlcmlhbGl6ZS10cmFuc2FjdGlvbi5qc1wiO1xuY29uc3QgT1BTdGFja0dhc1ByaWNlT3JhY2xlQWRkcmVzcyA9IFwiMHg0MjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBGXCI7XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXN0aW1hdGVMMUZlZShvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbiwgZ2FzUHJpY2VPcmFjbGVBZGRyZXNzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IG9yYWNsZUNvbnRyYWN0ID0gZ2V0Q29udHJhY3Qoe1xuICAgICAgICBjbGllbnQ6IHRyYW5zYWN0aW9uLmNsaWVudCxcbiAgICAgICAgYWRkcmVzczogZ2FzUHJpY2VPcmFjbGVBZGRyZXNzIHx8IE9QU3RhY2tHYXNQcmljZU9yYWNsZUFkZHJlc3MsXG4gICAgICAgIGNoYWluOiB0cmFuc2FjdGlvbi5jaGFpbixcbiAgICB9KTtcbiAgICAvLyBwdXJwb3NlZnVsbHkgcmVtb3ZlIGdhc1ByaWNlIGZyb20gdGhlIHRyYW5zYWN0aW9uXG4gICAgY29uc3QgeyBnYXNQcmljZSwgLi4uc2VyaWFsaXphYmxlVHggfSA9IGF3YWl0IHRvU2VyaWFsaXphYmxlVHJhbnNhY3Rpb24oe1xuICAgICAgICB0cmFuc2FjdGlvbixcbiAgICB9KTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gc2VyaWFsaXplVHJhbnNhY3Rpb24oe1xuICAgICAgICB0cmFuc2FjdGlvbjogc2VyaWFsaXphYmxlVHgsXG4gICAgfSk7XG4gICAgLy9zZXJpYWxpemVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIHJlYWRDb250cmFjdCh7XG4gICAgICAgIGNvbnRyYWN0OiBvcmFjbGVDb250cmFjdCxcbiAgICAgICAgbWV0aG9kOiBcImZ1bmN0aW9uIGdldEwxRmVlKGJ5dGVzIG1lbW9yeSBfZGF0YSkgdmlldyByZXR1cm5zICh1aW50MjU2KVwiLFxuICAgICAgICBwYXJhbXM6IFtzZXJpYWxpemVkXSxcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVzdGltYXRlLWwxLWZlZS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/gas/estimate-l1-fee.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   serializeTransaction: () => (/* binding */ serializeTransaction)\n/* harmony export */ });\n/* harmony import */ var ox_Hex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ox/Hex */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Hex.js\");\n/* harmony import */ var ox_Signature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ox/Signature */ \"(app-pages-browser)/./node_modules/ox/_esm/core/Signature.js\");\n/* harmony import */ var ox_TransactionEnvelopeEip1559__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ox/TransactionEnvelopeEip1559 */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js\");\n/* harmony import */ var ox_TransactionEnvelopeEip2930__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ox/TransactionEnvelopeEip2930 */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js\");\n/* harmony import */ var ox_TransactionEnvelopeEip7702__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ox/TransactionEnvelopeEip7702 */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js\");\n/* harmony import */ var ox_TransactionEnvelopeLegacy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ox/TransactionEnvelopeLegacy */ \"(app-pages-browser)/./node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js\");\n\n\n\n\n\n\n/**\n * Serializes a legacy, EIP-1559, EIP-2930, EIP-4844, or EIP-7702 transaction object.\n *\n * @param options - The serialization options.\n * @param options.transaction - The transaction object to be serialized.\n * @param [options.signature] - The signature to include with the transaction, if necessary.\n * @returns The serialized transaction.\n * @throws An error if the provided transaction object is invalid.\n * @transaction\n * @example\n * ```ts\n * import { serializeTransaction } from \"thirdweb\";\n *\n * const serializedTransaction = serializeTransaction({ transaction: {\n *    to: \"0x\",\n *    value: 0n,\n *  }\n * });\n * ```\n */\nfunction serializeTransaction(options) {\n    const { transaction } = options;\n    const type = getTransactionEnvelopeType(transaction);\n    // This is to maintain compatibility with our old interface (including the signature in the transaction object)\n    const signature = (() => {\n        if (options.signature) {\n            if (\"v\" in options.signature &&\n                typeof options.signature.v !== \"undefined\") {\n                return ox_Signature__WEBPACK_IMPORTED_MODULE_0__.fromLegacy({\n                    r: ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(options.signature.r),\n                    s: ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(options.signature.s),\n                    v: Number(options.signature.v),\n                });\n            }\n            return {\n                r: ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(options.signature.r),\n                s: ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(options.signature.s),\n                // We force the Signature type here because we filter for legacy type above\n                yParity: options.signature\n                    .yParity,\n            };\n        }\n        if (typeof transaction.v === \"undefined\" &&\n            typeof transaction.yParity === \"undefined\") {\n            return undefined;\n        }\n        if (transaction.r === undefined || transaction.s === undefined) {\n            throw new Error(\"Invalid signature provided with transaction\");\n        }\n        return {\n            r: typeof transaction.r === \"bigint\"\n                ? transaction.r\n                : ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(transaction.r),\n            s: typeof transaction.s === \"bigint\"\n                ? transaction.s\n                : ox_Hex__WEBPACK_IMPORTED_MODULE_1__.toBigInt(transaction.s),\n            yParity: typeof transaction.v !== \"undefined\" &&\n                typeof transaction.yParity === \"undefined\"\n                ? ox_Signature__WEBPACK_IMPORTED_MODULE_0__.vToYParity(Number(transaction.v))\n                : Number(transaction.yParity),\n        };\n    })();\n    if (type === \"eip1559\") {\n        const typedTransaction = transaction;\n        ox_TransactionEnvelopeEip1559__WEBPACK_IMPORTED_MODULE_2__.assert(typedTransaction);\n        return ox_TransactionEnvelopeEip1559__WEBPACK_IMPORTED_MODULE_2__.serialize(typedTransaction, {\n            signature,\n        });\n    }\n    if (type === \"legacy\") {\n        const typedTransaction = transaction;\n        ox_TransactionEnvelopeLegacy__WEBPACK_IMPORTED_MODULE_3__.assert(typedTransaction);\n        return ox_TransactionEnvelopeLegacy__WEBPACK_IMPORTED_MODULE_3__.serialize(typedTransaction, {\n            signature,\n        });\n    }\n    if (type === \"eip2930\") {\n        const typedTransaction = transaction;\n        ox_TransactionEnvelopeEip2930__WEBPACK_IMPORTED_MODULE_4__.assert(typedTransaction);\n        return ox_TransactionEnvelopeEip2930__WEBPACK_IMPORTED_MODULE_4__.serialize(typedTransaction, {\n            signature,\n        });\n    }\n    if (type === \"eip7702\") {\n        const typedTransaction = transaction;\n        ox_TransactionEnvelopeEip7702__WEBPACK_IMPORTED_MODULE_5__.assert(typedTransaction);\n        return ox_TransactionEnvelopeEip7702__WEBPACK_IMPORTED_MODULE_5__.serialize(typedTransaction, {\n            signature,\n        });\n    }\n    throw new Error(\"Invalid transaction type\");\n}\n/**\n * @internal\n */\nfunction getTransactionEnvelopeType(transactionEnvelope) {\n    if (typeof transactionEnvelope.type !== \"undefined\") {\n        return transactionEnvelope.type;\n    }\n    if (typeof transactionEnvelope.authorizationList !== \"undefined\") {\n        return \"eip7702\";\n    }\n    if (typeof transactionEnvelope.maxFeePerGas !== \"undefined\" ||\n        typeof transactionEnvelope.maxPriorityFeePerGas !== \"undefined\") {\n        return \"eip1559\";\n    }\n    if (typeof transactionEnvelope.gasPrice !== \"undefined\") {\n        if (typeof transactionEnvelope.accessList !== \"undefined\") {\n            return \"eip2930\";\n        }\n        return \"legacy\";\n    }\n    throw new Error(\"Invalid transaction type\");\n}\n//# sourceMappingURL=serialize-transaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aGlyZHdlYi9kaXN0L2VzbS90cmFuc2FjdGlvbi9zZXJpYWxpemUtdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFrQztBQUNZO0FBQ2tDO0FBQ0E7QUFDQTtBQUNGO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHVCQUF1QjtBQUNuQztBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNPO0FBQ1AsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvREFBd0I7QUFDL0MsdUJBQXVCLDRDQUFnQjtBQUN2Qyx1QkFBdUIsNENBQWdCO0FBQ3ZDO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxtQkFBbUIsNENBQWdCO0FBQ25DLG1CQUFtQiw0Q0FBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRDQUFnQjtBQUNsQztBQUNBO0FBQ0Esa0JBQWtCLDRDQUFnQjtBQUNsQztBQUNBO0FBQ0Esa0JBQWtCLG9EQUF3QjtBQUMxQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxRQUFRLGlFQUFxQztBQUM3QyxlQUFlLG9FQUF3QztBQUN2RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdFQUFvQztBQUM1QyxlQUFlLG1FQUF1QztBQUN0RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFxQztBQUM3QyxlQUFlLG9FQUF3QztBQUN2RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxRQUFRLGlFQUFxQztBQUM3QyxlQUFlLG9FQUF3QztBQUN2RDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbWlpbmFkb2kvRGVza3RvcC9naXRodWJQcm9qZWN0L3Rocmlkd2VidHV0b3JpYWwvbm9kZV9tb2R1bGVzL3RoaXJkd2ViL2Rpc3QvZXNtL3RyYW5zYWN0aW9uL3NlcmlhbGl6ZS10cmFuc2FjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBveF9fSGV4IGZyb20gXCJveC9IZXhcIjtcbmltcG9ydCAqIGFzIG94X19TaWduYXR1cmUgZnJvbSBcIm94L1NpZ25hdHVyZVwiO1xuaW1wb3J0ICogYXMgb3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5IGZyb20gXCJveC9UcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OVwiO1xuaW1wb3J0ICogYXMgb3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwIGZyb20gXCJveC9UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMFwiO1xuaW1wb3J0ICogYXMgb3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyIGZyb20gXCJveC9UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMlwiO1xuaW1wb3J0ICogYXMgb3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3kgZnJvbSBcIm94L1RyYW5zYWN0aW9uRW52ZWxvcGVMZWdhY3lcIjtcbi8qKlxuICogU2VyaWFsaXplcyBhIGxlZ2FjeSwgRUlQLTE1NTksIEVJUC0yOTMwLCBFSVAtNDg0NCwgb3IgRUlQLTc3MDIgdHJhbnNhY3Rpb24gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIC0gVGhlIHNlcmlhbGl6YXRpb24gb3B0aW9ucy5cbiAqIEBwYXJhbSBvcHRpb25zLnRyYW5zYWN0aW9uIC0gVGhlIHRyYW5zYWN0aW9uIG9iamVjdCB0byBiZSBzZXJpYWxpemVkLlxuICogQHBhcmFtIFtvcHRpb25zLnNpZ25hdHVyZV0gLSBUaGUgc2lnbmF0dXJlIHRvIGluY2x1ZGUgd2l0aCB0aGUgdHJhbnNhY3Rpb24sIGlmIG5lY2Vzc2FyeS5cbiAqIEByZXR1cm5zIFRoZSBzZXJpYWxpemVkIHRyYW5zYWN0aW9uLlxuICogQHRocm93cyBBbiBlcnJvciBpZiB0aGUgcHJvdmlkZWQgdHJhbnNhY3Rpb24gb2JqZWN0IGlzIGludmFsaWQuXG4gKiBAdHJhbnNhY3Rpb25cbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgc2VyaWFsaXplVHJhbnNhY3Rpb24gfSBmcm9tIFwidGhpcmR3ZWJcIjtcbiAqXG4gKiBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBzZXJpYWxpemVUcmFuc2FjdGlvbih7IHRyYW5zYWN0aW9uOiB7XG4gKiAgICB0bzogXCIweFwiLFxuICogICAgdmFsdWU6IDBuLFxuICogIH1cbiAqIH0pO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVUcmFuc2FjdGlvbihvcHRpb25zKSB7XG4gICAgY29uc3QgeyB0cmFuc2FjdGlvbiB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB0eXBlID0gZ2V0VHJhbnNhY3Rpb25FbnZlbG9wZVR5cGUodHJhbnNhY3Rpb24pO1xuICAgIC8vIFRoaXMgaXMgdG8gbWFpbnRhaW4gY29tcGF0aWJpbGl0eSB3aXRoIG91ciBvbGQgaW50ZXJmYWNlIChpbmNsdWRpbmcgdGhlIHNpZ25hdHVyZSBpbiB0aGUgdHJhbnNhY3Rpb24gb2JqZWN0KVxuICAgIGNvbnN0IHNpZ25hdHVyZSA9ICgoKSA9PiB7XG4gICAgICAgIGlmIChvcHRpb25zLnNpZ25hdHVyZSkge1xuICAgICAgICAgICAgaWYgKFwidlwiIGluIG9wdGlvbnMuc2lnbmF0dXJlICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIG9wdGlvbnMuc2lnbmF0dXJlLnYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3hfX1NpZ25hdHVyZS5mcm9tTGVnYWN5KHtcbiAgICAgICAgICAgICAgICAgICAgcjogb3hfX0hleC50b0JpZ0ludChvcHRpb25zLnNpZ25hdHVyZS5yKSxcbiAgICAgICAgICAgICAgICAgICAgczogb3hfX0hleC50b0JpZ0ludChvcHRpb25zLnNpZ25hdHVyZS5zKSxcbiAgICAgICAgICAgICAgICAgICAgdjogTnVtYmVyKG9wdGlvbnMuc2lnbmF0dXJlLnYpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICByOiBveF9fSGV4LnRvQmlnSW50KG9wdGlvbnMuc2lnbmF0dXJlLnIpLFxuICAgICAgICAgICAgICAgIHM6IG94X19IZXgudG9CaWdJbnQob3B0aW9ucy5zaWduYXR1cmUucyksXG4gICAgICAgICAgICAgICAgLy8gV2UgZm9yY2UgdGhlIFNpZ25hdHVyZSB0eXBlIGhlcmUgYmVjYXVzZSB3ZSBmaWx0ZXIgZm9yIGxlZ2FjeSB0eXBlIGFib3ZlXG4gICAgICAgICAgICAgICAgeVBhcml0eTogb3B0aW9ucy5zaWduYXR1cmVcbiAgICAgICAgICAgICAgICAgICAgLnlQYXJpdHksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb24udiA9PT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgdHlwZW9mIHRyYW5zYWN0aW9uLnlQYXJpdHkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnIgPT09IHVuZGVmaW5lZCB8fCB0cmFuc2FjdGlvbi5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmF0dXJlIHByb3ZpZGVkIHdpdGggdHJhbnNhY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHI6IHR5cGVvZiB0cmFuc2FjdGlvbi5yID09PSBcImJpZ2ludFwiXG4gICAgICAgICAgICAgICAgPyB0cmFuc2FjdGlvbi5yXG4gICAgICAgICAgICAgICAgOiBveF9fSGV4LnRvQmlnSW50KHRyYW5zYWN0aW9uLnIpLFxuICAgICAgICAgICAgczogdHlwZW9mIHRyYW5zYWN0aW9uLnMgPT09IFwiYmlnaW50XCJcbiAgICAgICAgICAgICAgICA/IHRyYW5zYWN0aW9uLnNcbiAgICAgICAgICAgICAgICA6IG94X19IZXgudG9CaWdJbnQodHJhbnNhY3Rpb24ucyksXG4gICAgICAgICAgICB5UGFyaXR5OiB0eXBlb2YgdHJhbnNhY3Rpb24udiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiB0cmFuc2FjdGlvbi55UGFyaXR5ID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgPyBveF9fU2lnbmF0dXJlLnZUb1lQYXJpdHkoTnVtYmVyKHRyYW5zYWN0aW9uLnYpKVxuICAgICAgICAgICAgICAgIDogTnVtYmVyKHRyYW5zYWN0aW9uLnlQYXJpdHkpLFxuICAgICAgICB9O1xuICAgIH0pKCk7XG4gICAgaWYgKHR5cGUgPT09IFwiZWlwMTU1OVwiKSB7XG4gICAgICAgIGNvbnN0IHR5cGVkVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgb3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAxNTU5LmFzc2VydCh0eXBlZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIG94X19UcmFuc2FjdGlvbkVudmVsb3BlRWlwMTU1OS5zZXJpYWxpemUodHlwZWRUcmFuc2FjdGlvbiwge1xuICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwibGVnYWN5XCIpIHtcbiAgICAgICAgY29uc3QgdHlwZWRUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5hc3NlcnQodHlwZWRUcmFuc2FjdGlvbik7XG4gICAgICAgIHJldHVybiBveF9fVHJhbnNhY3Rpb25FbnZlbG9wZUxlZ2FjeS5zZXJpYWxpemUodHlwZWRUcmFuc2FjdGlvbiwge1xuICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiZWlwMjkzMFwiKSB7XG4gICAgICAgIGNvbnN0IHR5cGVkVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgb3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXAyOTMwLmFzc2VydCh0eXBlZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIG94X19UcmFuc2FjdGlvbkVudmVsb3BlRWlwMjkzMC5zZXJpYWxpemUodHlwZWRUcmFuc2FjdGlvbiwge1xuICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiZWlwNzcwMlwiKSB7XG4gICAgICAgIGNvbnN0IHR5cGVkVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbjtcbiAgICAgICAgb3hfX1RyYW5zYWN0aW9uRW52ZWxvcGVFaXA3NzAyLmFzc2VydCh0eXBlZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgcmV0dXJuIG94X19UcmFuc2FjdGlvbkVudmVsb3BlRWlwNzcwMi5zZXJpYWxpemUodHlwZWRUcmFuc2FjdGlvbiwge1xuICAgICAgICAgICAgc2lnbmF0dXJlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0cmFuc2FjdGlvbiB0eXBlXCIpO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25FbnZlbG9wZVR5cGUodHJhbnNhY3Rpb25FbnZlbG9wZSkge1xuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25FbnZlbG9wZS50eXBlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiB0cmFuc2FjdGlvbkVudmVsb3BlLnR5cGU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25FbnZlbG9wZS5hdXRob3JpemF0aW9uTGlzdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gXCJlaXA3NzAyXCI7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25FbnZlbG9wZS5tYXhGZWVQZXJHYXMgIT09IFwidW5kZWZpbmVkXCIgfHxcbiAgICAgICAgdHlwZW9mIHRyYW5zYWN0aW9uRW52ZWxvcGUubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZWlwMTU1OVwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uRW52ZWxvcGUuZ2FzUHJpY2UgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbkVudmVsb3BlLmFjY2Vzc0xpc3QgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBcImVpcDI5MzBcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJsZWdhY3lcIjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCB0cmFuc2FjdGlvbiB0eXBlXCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyaWFsaXplLXRyYW5zYWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/thirdweb/dist/esm/transaction/serialize-transaction.js\n"));

/***/ })

}]);